<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[夏树正茂]]></title>
  <link href="http://summertreee.github.io/atom.xml" rel="self"/>
  <link href="http://summertreee.github.io/"/>
  <updated>2015-11-22T22:25:26+08:00</updated>
  <id>http://summertreee.github.io/</id>
  <author>
    <name><![CDATA[梁炜V]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Auto Layout使用小技巧]]></title>
    <link href="http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao/"/>
    <updated>2015-11-22T22:20:31+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<p>目前由于Apple自己的Auto Layout写法比较啰嗦，所以出现了许多对原生语句进行封装的第三方开发库，这其中<code>Masonry</code>广受开发者的喜爱，所以以下都以<code>Masonry</code>来做演示说明，但对于Apple原生的写法也同样适用。</p>

<h3>1、图片+文字居中显示</h3>

<p>很多时候我们都会遇到这样的需求：一张图片旁边接上一段文字，然后让他们相对于父视图居中显示，以前我的做法是先知道图片的尺寸，然后来计算他们相对于父视图中心的偏移量，再进行布局。需求的样式大致如下：</p>

<p><img src="http://summertreee.github.io/Users/baidu/Desktop/yangshi.png" alt="大致效果" /></p>

<p>但是这样的缺点是每次都需要去据算距离中心的偏移量，很麻烦，对于这种情况其实可以添加一个辅助视图，让这个辅助视图的左边等于图片的左边，右边和文字的右边对齐，然后这个辅助视图相对于父视图居中显示就行。</p>

<pre><code>- (void)layoutImageAndText {
UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"av_colum"]];
[self.view addSubview:imageView];
[imageView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(@10);
    make.left.greaterThanOrEqualTo(self.view);
}];

UILabel *label = [UILabel new];
label.text = @"梁朝伟";
label.font = [UIFont systemFontOfSize:17];
label.textAlignment = NSTextAlignmentLeft;
label.backgroundColor = [UIColor clearColor];
[self.view addSubview:label];
[label mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView.mas_right).offset(5);
    make.centerY.equalTo(imageView);
}];

UIView *limitView = [UIView new];
[self.view addSubview:limitView];
[limitView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView);//和图片左边对齐
    make.right.equalTo(label);//和文字右边对齐
    make.centerX.equalTo(self.view);//指定limitView居中显示
}];
}
</code></pre>

<h3>2、处理复合型布局</h3>

<p>直接上图说明需求，页面上有四个可见的视图：红、绿、蓝三个<code>UIView</code>，最下面是一个<code>UIButton</code>,想要达到的效果是点击button触发事件将中间的绿色视图隐藏，下面的蓝色视图和button移动到红色视图下，我们想要的效果如下：</p>

<p><img src="http://summertreee.github.io/Users/baidu/Desktop/3.gif" alt="需要的效果" /></p>

<p>如果只是将中间的绿色的视图hidden掉，是达不到这样的效果的：</p>

<p><img src="http://summertreee.github.io/Users/baidu/Desktop/33.png" alt="影藏中间的绿色视图" /></p>

<p>要达到这样的效果可以利用<code>MASConstraint</code>的<code>deactivate</code>和<code>activate</code>方法，他们的作用是让一个constraint<strong>不生效</strong>和<strong>生效</strong>，<code>Masonry</code>的每个Constraint都会产生一个<code>MASConstraint</code>，所以我们可以保存一些需要改变的constraint，在需要的时候使用这两个方法。</p>

<pre><code>//.h
@interface ViewController ()

@property (nonatomic, strong) UIView *greenView;
@property (nonatomic, strong) MASConstraint *gHeightConstraint;//保存关键的constraint

@end
//.m
@implementation ViewController

- (void)testComplexLayout {
NSNumber *viewHeight = @80;
UIView *redView = [UIView new];
redView.backgroundColor = [UIColor redColor];
[self.view addSubview:redView];
[redView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.left.right.equalTo(self.view);
    make.height.equalTo(viewHeight);
}];

_greenView = [UIView new];
[self.view addSubview:_greenView];
[_greenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.right.equalTo(redView);
    make.top.equalTo(redView.mas_bottom);
    self.gHeightConstraint = make.height.equalTo(@0).priorityHigh();//设为高优先级，首先满足它的需求
}];
[self.gHeightConstraint deactivate];//最开始让它不生效，就是高为0的限制暂不生效
_greenView.clipsToBounds = YES;//不显示超过bounds本身的部分，因为在它里面加了subView
//subGreenView是真实的显示绿色部分，它添加在greenView上
UIView *subGreenView = [UIView new];
subGreenView.backgroundColor = [UIColor greenColor];
[_greenView addSubview:subGreenView];
[subGreenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.edges.equalTo(self.greenView).priorityLow();
    make.height.equalTo(viewHeight);
}];

UIView *blueView = [UIView new];
blueView.backgroundColor = [UIColor blueColor];
[self.view addSubview:blueView];
[blueView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.height.left.right.equalTo(redView);
    make.top.equalTo(self.greenView.mas_bottom);
}];

UIButton *hiddenButton = [UIButton buttonWithType:UIButtonTypeCustom];
[hiddenButton setTitle:@"影藏中间的View" forState:UIControlStateNormal];
[hiddenButton addTarget:self action:@selector(hiddenAction:) forControlEvents:UIControlEventTouchUpInside];
[hiddenButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
[self.view addSubview:hiddenButton];
[hiddenButton mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.equalTo(self.view);
    make.top.equalTo(blueView.mas_bottom).offset(40);
}];
}

static bool isActive = NO;
- (void)hiddenAction:(id)sender {
if (isActive) {
    [_gHeightConstraint deactivate];
} else {
    [_gHeightConstraint activate];
}
//动画展示
[UIView animateWithDuration:.25 animations:^{
    [self.view layoutIfNeeded];
}];

isActive = !isActive;
}
</code></pre>

<h3>3、Preview的使用</h3>

<p>这段时间在学习storyBoard相关的一些知识，RW上的两篇文章：<a href="http://www.raywenderlich.com/50308/storyboards-tutorial-in-ios-7-part-1">Part1</a>和<a href="http://www.raywenderlich.com/50310/storyboards-tutorial-in-ios-7-part-2">Part2</a>非常适合初学者学习，已经有人翻译成了中文<a href="http://www.cocoachina.com/industry/20131213/7537.html">Part1</a>，<a href="http://blog.sina.com.cn/s/blog_5c5c87d80101dzyh.html">Part2</a>。</p>

<p><code>Xcode</code>提供了一个很重要的功能<code>Preview</code>。当我们在<code>Storyboard</code>上使用<code>Auto Layout</code>上进行布局以后，由于目前的画布<code>canvas</code>已经没有尺寸的概念，我们布局完成后需要在3.5、4.0、4.7、5.5英寸的设备上测试，如果支持旋转或者支持iPad，一个效果我们会build多次在不同的设备上查看效果。非常的麻烦，但是有了<code>Preview</code>后一切都变得简单起来。
使用<code>Preview</code>的步奏如下：</p>

<p>1、选中<code>Main.storyboard</code>,如下图所示，选取的时候按下<code>option+shift</code>按键。</p>

<p><img src="http://summertreee.github.io/Users/baidu/Desktop/44.png" alt="选择storyboard" /></p>

<p>2、选取<code>Preview</code>后会出来如下的界面，选择界面右边的<code>+</code>号，按<code>回车</code>。</p>

<p><img src="http://summertreee.github.io/Users/baidu/Desktop/55.png" alt="image" /></p>

<p>3、通过步骤<code>2</code>后，会出现以下的界面：</p>

<p><img src="http://summertreee.github.io/Users/baidu/Desktop/66.png" height="520" width="500" alt="Preview界面" /></p>

<p>关键的几个地方我都用红方框圈了起来，左下角的<code>+</code>能模拟不同的设备，中间的红框部位可以模拟设备的旋转，
右下角的<code>English</code>部位可以模拟布局中的文学信息双倍后的布局表现，这几个功能都非常的方便。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App中拨打电话一点小总结]]></title>
    <link href="http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-%5B%3F%5D-dian-xiao-zong-jie/"/>
    <updated>2015-08-23T12:27:08+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-[?]-dian-xiao-zong-jie</id>
    <content type="html"><![CDATA[<h3>App内发起电话拨打的一点小技巧</h3>

<h4>一、拨打电话</h4>

<p>在App内发起电话拨打主要有两种方式：</p>

<p>1、利用这种方式发起的电话拨打，通话结束后不会直接返回App内，而是停留在通信录里面：</p>

<pre><code> NSString *str = [[NSString alloc] initWithFormat:@"tel:%@",@"131xxxx1909"];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:str]];
</code></pre>

<!--more-->


<p>2、利用<code>UIWebView</code>实现电话拨打，会弹出拨打提示，并且拨打完成后会返回App内：</p>

<pre><code>NSString *phone = @"131****1909";
NSString *cleanedString =[[phone componentsSeparatedByCharactersInSet:[[NSCharacterSet characterSetWithCharactersInString:@"0123456789-+()"] invertedSet]] componentsJoinedByString:@""];
NSString *escapedPhoneNumber = [cleanedString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSURL *telURL = [NSURL URLWithString:[NSString stringWithFormat:@"tel://%@",escapedPhoneNumber]];
UIWebView *mCallWebview = [[UIWebView alloc] init] ;

[self.view addSubview:mCallWebview];
[mCallWebview loadRequest:[NSURLRequest requestWithURL:telURL]];
</code></pre>

<h4>二、检测通话时间</h4>

<p>利用<code>CTCallCenter</code>我们可以检测在使用App期间拨打电话出去以及电话打入的时机，以及通话结束的时机。实现如下：</p>

<pre><code> #import &lt;CoreTelephony/CTCallCenter.h&gt;
 #import &lt;CoreTelephony/CTCall.h&gt;

 @interface AppDelegate : UIResponder&lt;UIApplicationDelegate&gt;
 @property (nonatomic, strong) CTCallCenter *callCenter;
 @end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.callCenter = [[CTCallCenter alloc] init];
  [self handleCall];
  return YES;
}

-(void)handleCall
{
   self.callCenter.callEventHandler = ^(CTCall *call) {
    if ([call.callState isEqualToString: CTCallStateConnected])
    {
        NSLog(@"接通电话");
    }
    else if ([call.callState isEqualToString: CTCallStateDialing])
    {
        NSLog(@"发起呼叫");
    }
    else if ([call.callState isEqualToString: CTCallStateDisconnected])
    {
        NSLog(@"结束电话");
    }
    else if ([call.callState isEqualToString: CTCallStateIncoming])
    {
        NSLog(@"打入电话");
    }
   };
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode控制台打印CGRect]]></title>
    <link href="http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect/"/>
    <updated>2015-06-15T21:15:58+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect</id>
    <content type="html"><![CDATA[<p>在用Xcode调试开发的时候，我们经常需要在控制台打印某个视图的frame，以前的时候相当麻烦，但是从Xcode6.3以后，打印frame变得很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Before
</span><span class='line'>(lldb) p (CGRect) [self frame]
</span><span class='line'>(CGRect) $0 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span><span class='line'> 
</span><span class='line'>// After
</span><span class='line'>(lldb) expr @import UIKit
</span><span class='line'>(lldb) p self.frame
</span><span class='line'>(CGRect) $1 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking2.0使用心得]]></title>
    <link href="http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de/"/>
    <updated>2015-05-13T13:56:23+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de</id>
    <content type="html"><![CDATA[<p>这段时间要将公司项目中的网络引擎由<a href="http://allseeing-i.com/ASIHTTPRequest/">ASIHTTPRequest</a>替换为<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>,替换的过程比较曲折，在此记录下自己替换过程中得心得：</p>

<h3>1、建立数据请求中介者</h3>

<p>建立<code>中介者</code>是指项目中的数据请求都通过它去实现，而不是每一个数据请求都直接与<code>AFNetworking</code>打交道，这样做的好处是：</p>

<ul>
<li>将网络请求与第三方库依赖隔离开来，方便以后对第三方库的替换。</li>
<li>方便处理网络请求的公共逻辑。</li>
</ul>


<!--more-->


<h3>2、使用completionQueue</h3>

<p>默认情况下<code>AFURLConnectionOperation</code>或者<code>AFHTTPRequestOperation</code>请求结束以后会在主线程将结果传递回来，如果你要将请求的结果做一些耗时的复杂的处理，就会<em>block</em>住主线程，所以这种情况下你就需要对请求的Operation传递<code>completionQueue</code>参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperation *request = [[AFHTTPRequestOperation alloc] initWithRequest:urlrequest];
</span><span class='line'>
</span><span class='line'>request.responseSerializer = [AFJSONResponseSerializer serializer];
</span><span class='line'>//设置回调的queue，默认是在mainQueue执行block回调
</span><span class='line'>request.completionQueue = your_request_operation_completion_queue();
</span><span class='line'>[request setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>         //设置了'completionQueue'后，就可以在这里处理复杂的逻辑
</span><span class='line'>         //不用担心block住了主线程
</span><span class='line'>    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>
</span><span class='line'> }];
</span><span class='line'> [request start];
</span></code></pre></td></tr></table></div></figure>


<h3>3、如何知道AFHTTPRequestOperationManager执行完成</h3>

<p>开始以为直接设置<code>AFHTTPRequestOperationManager</code>的<em>completionGroup</em>，然后利用<code>dispatch_group_notify</code>来获取operationQueue执行结束的通知，最后才发现，这样根本不行，看了源码才知道：<code>AFHTTPRequestOperationManager</code>直接将<em>completionGroup</em>赋值给了他的每一个<em>operation</em>，在<em>operation</em>的completionBlock里面利用<em>completionGroup</em>，来确保在operation的处理完成后，将completionBlock置为nil，防止循环引用。</p>

<p>虽然说这样不能知道<code>AFHTTPRequestOperationManager</code>什么时候执行完成，但是生活还得继续下去啊！在<code>AFURLConnectionOperation</code>中有一个方法叫：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSArray *)batchOfRequestOperations:(NSArray *)operations
</span><span class='line'>                        progressBlock:(void (^)(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations))progressBlock
</span><span class='line'>                      completionBlock:(void (^)(NSArray *operations))completionBlock;
</span></code></pre></td></tr></table></div></figure>


<p>这个方法就是能够发一组请求，跟<code>AFHTTPRequestOperationManager</code>比起来的缺点就是没法设置并发数，但是它却能实现检测一组请求什么时候结束，能检测完成了多少请求，它是怎么做到的呢？</p>

<p>原来他也是利用<strong>dispatch_group_async</strong>和<strong>dispatch_group_notify</strong></p>

<p>一般的我们要把一个任务加入一个group里是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    block();
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这个写法等价于</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(queue, ^{
</span><span class='line'>    dispatch_group_enter(group);
</span><span class='line'>    block()
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>如果要把一个异步任务加入group，这样就行不通了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    [self performBlock:^(){
</span><span class='line'>        block();
</span><span class='line'>    }];
</span><span class='line'>    //未执行到block() group任务就已经完成了
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这是就需要用到<code>batchOfRequestOperations</code>里的实现了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_enter(group);
</span><span class='line'>[self performBlock:^(){
</span><span class='line'>    block();
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>}];
</span></code></pre></td></tr></table></div></figure>


<p>其实这个和引用计数差不多，<em>dispatch_group_enter</em>时引用计数+1，<em>dispatch_group_leave</em>时引用计数-1，引用计数为0时执行<em>dispatch_group_notify</em>的内容。具体过程大致如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperationManager *downloadManager = [AFHTTPRequestOperationManager manager];
</span><span class='line'>    //设置最大并发数
</span><span class='line'>    [downloadManager.operationQueue setMaxConcurrentOperationCount:([NSProcessInfo processInfo].processorCount) * 2];
</span><span class='line'>    //创建一个group
</span><span class='line'>    __block dispatch_group_t group = dispatch_group_create();
</span><span class='line'>    for (NSURL *url in urlArray) {
</span><span class='line'>        NSURLRequest *requestUrl = [NSURLRequest requestWithURL:url];
</span><span class='line'>        AFHTTPRequestOperation *requestOperation = [[AFHTTPRequestOperation alloc] initWithRequest:requestUrl];
</span><span class='line'>        [requestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        }];
</span><span class='line'>        //将请求加入队列中
</span><span class='line'>        [downloadManager.operationQueue addOperation:requestOperation];
</span><span class='line'>        dispatch_group_enter(group);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
</span><span class='line'>        //全部请求完成
</span><span class='line'>        
</span><span class='line'>    });  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>4、实现断点续传</h3>

<p><code>AFNetworking</code>虽然支持文件下载的暂停和继续，但是当缓存清空重新启动时，它并没有记录下下载的状态，无法续传，但是可以通过<a href="http://https://github.com/steipete/AFDownloadRequestOperation">AFDownloadRequestOperation</a>来简单的实现，其实过程也不是很复杂，大致如下，感兴趣的朋友可以阅读<code>AFDownloadRequestOperation</code>是实现部分：</p>

<p>1、设置<code>AFHTTPRequestOperation</code>的请求<code>NSMutableURLRequest</code><em>HTTPHeader</em>的<strong>Range</strong>字段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableURLRequest *mutableURLRequest = [self.request mutableCopy];
</span><span class='line'>//offset是指断点续传文件已经下载的大小
</span><span class='line'>[mutableURLRequest setValue:[NSString stringWithFormat:@"bytes=%llu-", offset] forHTTPHeaderField:@"Range"];</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>2、设置<code>AFHTTPRequestOperation</code>的<em>outputStream</em>属性。</p>

<pre><code class="` "> //downloadPath是指文件下载存放的路径
downloadOperation.outputStream = [NSOutputStream outputStreamToFileAtPath:downloadPath append:YES];
</code></pre>

<h3>结尾</h3>

<p>对于<code>ASIHTTPRequest</code>和<code>AFNetworking</code>的比较网上有很多很好的文章，一搜一大把，对于普通的使用来说感觉区别不大，请求速度什么的也没什么感觉，以上若有错误，还望大家多多
指正😃。</p>
]]></content>
  </entry>
  
</feed>
