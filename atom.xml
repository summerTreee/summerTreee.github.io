<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[夏树正茂]]></title>
  <link href="http://summertreee.github.io/atom.xml" rel="self"/>
  <link href="http://summertreee.github.io/"/>
  <updated>2016-05-22T14:48:39+08:00</updated>
  <id>http://summertreee.github.io/</id>
  <author>
    <name><![CDATA[梁炜V]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我所理解的Runtime]]></title>
    <link href="http://summertreee.github.io/blog/2016/05/22/wo-suo-li-jie-de-runtime/"/>
    <updated>2016-05-22T14:46:14+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/05/22/wo-suo-li-jie-de-runtime</id>
    <content type="html"><![CDATA[<p>Objective-C是一门基于对象的动态语言，它里面所有的继承自<code>NSObject</code>的类本身以及类所实例化的对象都是对象，好像有点儿绕，大意就是这是一门基于对象的语言，就连类自己也是一个对象，程序运行起来以后类本身也会被初始化，也占有内存空间。<br/>
在这篇笔记里，我会记录如下的一些信息：</p>

<ul>
<li>消息传递</li>
<li>runtime如何处理对象</li>
<li>self 和 super</li>
<li>Method Swizzling</li>
<li>消息转发</li>
</ul>


<!--more-->


<h4>消息传递</h4>

<p>Objective-C是一门动态的语言，当我们在某个对象上调用方法是，<code>Objective—C</code>里面叫做<code>消息传递</code>，和<code>C语言</code>的函数调用在本质上就不一样，<code>C语言</code>使用<code>静态绑定</code>，在编译器就能决定运行时应该调用的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//代码一
</span><span class='line'>void printHello() {
</span><span class='line'>    printf("Hello, world!\n");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void printGoodbye() {
</span><span class='line'>    printf("Goodbye, world!\n");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void doSomeThing(int type) {
</span><span class='line'>    if (type == 0) {
</span><span class='line'>        printHello();
</span><span class='line'>    } else {
</span><span class='line'>        printGoodbye();
</span><span class='line'>    }
</span><span class='line'>}  
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>以上的代码在编译器编译代码的时候就已经知道程序中有 <strong>printHello</strong> 和 <strong>printGoodbye</strong> 这两个函数了，于是就直接生成调用这些函数的指令。而函数地址实际上是硬编码在指令之中的。但是，对于<code>Objective—C</code>来说，如果像下面这样写，情况会完全不一样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  //代码二 
</span><span class='line'>  void printHello() {
</span><span class='line'>    printf("Hello, world!\n");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void printGoodbye() {
</span><span class='line'>    printf("Goodbye, world!\n");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void doSomeThing(int type) {
</span><span class='line'>    void (*funcation)();
</span><span class='line'>    if (type == 0) {
</span><span class='line'>        funcation = printHello;
</span><span class='line'>    } else {
</span><span class='line'>        funcation = printGoodbye;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>   funcation();
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这时就需要使用<code>动态绑定</code>了，因为实际调用的方法在运行期根据<strong>type</strong>的值才能确定，在<strong>代码一</strong>中，<strong>if</strong>和<strong>else</strong>里面都有函数调用指令，而在<code>代码二</code>中，只有一个函数调用指令，而且待调用的函数地址无法硬编码到指令中，而是需要在运行期间读取出来。<br/>
在底层，所以的方法都是普通的<code>C语言</code>函数，当对象接收到消息之后，究竟该调用哪个方法完全是运行期决定的，甚至可以在运行期改变以及交换某些函数的实现，这就是<code>runtime</code>所体现出来的异于其他编程语言的特点。<br/>
当给某个对象传递一个消息：</p>

<pre><code>id returnValue = [someObject messageName:parameter];  
</code></pre>

<p>在这个消息中，<code>someObject</code>叫接收者(receiver)，<code>messageName</code>叫做选择子(selector)，选择子和参数结合起来叫<code>消息</code>(message)。当编译器看到此消息后，会将其转换为标准的<code>C语言</code>函数调用，这是就引出了我们消息传递中最核心的一个函数<code>objc_msgSend</code>，其原型如下：</p>

<pre><code>id objc_msgSend(id self, SEL op, ...)  
</code></pre>

<p>它是一个参数可变的函数，可以接受两个及两个以上的参数。有了这个函数，编译器会把刚才的消息转换为如下的函数：</p>

<pre><code>id returnValue = objc_msgSend(someObjetc,
                              @selector(messageName:),
                              parameter);  
</code></pre>

<p>到了运行期间，为了完成此操作，该方法需要到接受者所属的类中搜索其<strong>方法列表</strong>(后续会有讲到)，如果能找到与<strong>选择子</strong>名称相符的方法，就跳至其实现代码，如果找不到则按照其继承关系向上查找，如果到最终(NSObject)还是没能找到匹配的方法，那就执行<code>消息转发</code>(后续会讲到)。</p>

<p>除了刚才讲到的<code>objc_msgSend</code>外，还有其他的几种处理<code>边界情况</code>的函数：</p>

<pre><code>//处理待发送的消息要返回结构体
objc_msgSend_stret(id self, SEL op, ...)

//处理待发送的消息返回值是浮点数
objc_msgSend_fpret(id self, SEL op, ...) 

//处理将消息发送给超类的情况 
objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</code></pre>

<p>上面讲到了，<code>objc_msgSend</code>函数会根据<strong>选择子</strong>去查找应该调用的方法实现，<strong>选择子</strong>可以理解为一个标记，它其实就是<code>char *</code>字符串，选择字和方法的实现<code>IMP</code>之间是一对一的关系，<code>runtime</code>里面通过结构体<code>objc_method</code>来存储它们：</p>

<pre><code>typedef struct objc_method *Method;
struct objc_method {
    SEL method_name     OBJC2_UNAVAILABLE;
    char *method_types  OBJC2_UNAVAILABLE;
    IMP method_imp      OBJC2_UNAVAILABLE;
}  
</code></pre>

<h4>runtime如何处理对象</h4>

<p><code>Objective-C</code>是一门基于对象的动态语言，它的动态性是建立在对象上面的，从<code>runtime</code> 源码我们可以看到它是由<code>C语言</code>编写，这可以保证它执行的高效性，编译器在编译期会将对象转换为它里面定义的结构体：</p>

<pre><code>struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};
</code></pre>

<p>由此可见，每个对象结构体的首个成员变量是<code>Class</code>类的变量，通过它可以知道对象所属的类，通过<code>isa</code>指针可以访问到。<br/>
比如说我们定义了如下一个类<code>MyClass</code>：</p>

<pre><code>@interface MyClass : NSObject {
    NSString *name;
    NSUInteger age;
}
</code></pre>

<p>编译器编译<code>MyClass</code>类以后，它的实例变量布局如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  struct MyClass {
</span><span class='line'>    struct objc_class {
</span><span class='line'>        Class isa;
</span><span class='line'>    }
</span><span class='line'>    NSString *name;
</span><span class='line'>    NSUInteger age;
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>精简一下，去除<code>struct</code>的壳：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  struct MyClass {
</span><span class='line'>    Class isa;
</span><span class='line'>    NSString *name;
</span><span class='line'>    NSUInteger age;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>isa</code>变量的类型是<code>Class</code>，它的定义在<code>runtime</code>程序库里可以找到，它的定义如下：</p>

<pre><code>typedef struct objc_class *Class;  
</code></pre>

<p>所以由此我们知道<code>isa</code>本身就是一个<code>objc_class</code>类型的指针，同样我们可以在<code>runtime</code>程序库里面找到<code>objc_class</code>的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  struct objc_class {
</span><span class='line'>    Class isa  OBJC_ISA_AVAILABILITY;
</span><span class='line'>
</span><span class='line'>#if !__OBJC2__
</span><span class='line'>    Class super_class                                        OBJC2_UNAVAILABLE;
</span><span class='line'>    const char *name                                         OBJC2_UNAVAILABLE;
</span><span class='line'>    long version                                             OBJC2_UNAVAILABLE;
</span><span class='line'>    long info                                                OBJC2_UNAVAILABLE;
</span><span class='line'>    long instance_size                                       OBJC2_UNAVAILABLE;
</span><span class='line'>    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
</span><span class='line'>    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
</span><span class='line'>    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
</span><span class='line'>    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>} OBJC2_UNAVAILABLE;
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>这个结构体存放了类的所有<code>元数据</code>，例如定义了哪些实例变量，定义了哪些方法，超类等。此结构体的首个变量也是<code>isa</code>指针，说明<code>Class</code>本身也是一个<code>Objective-C</code>对象，<code>Class</code>里面的<code>isa</code>指向的类就是<code>元类</code>，用它来定义类对象本身的<code>元数据</code>。也就是说实例对象的<code>isa</code>指针指向它唯一的类对象，而类对象的<code>isa</code>指针指向它唯一的元类。我们知道，类和实例对象都可以发送<code>class</code>消息，从<code>runtime</code>的源码中有这样的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - class
</span><span class='line'>  {
</span><span class='line'>      return (id)isa;
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  + class
</span><span class='line'>  {
</span><span class='line'>     return self;
</span><span class='line'>  }
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>由上可以看出实例对象的class就是<code>isa</code>指向的class对象，而实例对象的类的class就是自己，这也印证了上面的说法。</p>

<p>在<code>Objective-C</code>中，对象的实例方法存放在它的<code>isa</code>指向的类对象中，类方法存放于类对象的<code>isa</code>指向的元类中，某个类在应用程序范围内，类对象以及它所属的元类只有一个，它们都是<code>单例</code>。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f445qvvtffj21b00o6e81.jpg" alt="image" /></p>

<p>当我们向某个类的实例化对象发送消息时，实例对象通过它的<code>isa</code>指针找到它所属的类对象，再去类对象的方法列表里面根据<code>选择子</code>查找，如果没有找到就去它父类的类对象里面查找。如果是向类对象调用类方法，类对象先通过它的<code>isa</code>指针找到它的<code>元类</code>，在元类的方法列表里面根据<code>选择子</code>查找需要调用的方法，如果找到了则跳转到方法实现，若没有找到则向它的父类的元类里面查找。</p>

<p>实例对象的类以及元类的关系如下图(图片<a href="www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">来源</a>)：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f445qwqwm2j20tg0u4gs1.jpg" alt="image" /></p>

<p>这里需要说明的是：图中类对象<strong>Root class</strong>，也就是<code>NSObject</code>，它的父类是<code>nil</code>，它的<code>元类</code>是<code>NSObject元类</code>，而<code>NSObject元类</code>的元类指向自己，父类指向<code>NSObject</code>类对象，这样刚好形成一个环，可能是苹果设计的需要，因为<code>NSObject</code>里面有很多定义好的行为，比如内存管理，空间开辟等，让所有的类对象都收敛于<code>NSObject</code>，便于统一管理。</p>

<p>好了，说了这么多，下面来做个简单的练习，热热身😃，首先贴出<code>object_getClass</code>方法的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Class object_getClass(id obj)
</span><span class='line'>  {
</span><span class='line'>     if(obj)  return obj-&gt;isa;
</span><span class='line'>     else return Nil;
</span><span class='line'>  }
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>也就是说这个方法会返回传入对象的<code>isa</code>指向。</p>

<p>以下是输出每行对象的内存地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Class class1 = [NSObject class];//0x90620c ①
</span><span class='line'>  id obj1 = [NSObject valueForKey:@"isa"];//0x906220 ②
</span><span class='line'>  id obj2 = [obj1 valueForKey:@"isa"];//0x90620  ③
</span><span class='line'>  NSObject *object = [NSObject new];
</span><span class='line'>  Class class2 = objc_getMetaClass("NSObject");//0x906220 ④
</span><span class='line'>  Class class3 = object_getClass(object);//0x90620c ⑤
</span><span class='line'>  Class class4 = class_getSuperclass(class1);//0x0 ⑥
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>①⑤的指向相同，②③④指向相同，⑥指向nil。<br/>
① 对<code>NSObject</code>调用<code>class</code>方法返回<code>NSObject</code>类对象本身。<br/>
② 获取<code>NSObject</code>类对象的<code>isa</code>变量，它指向<code>NSObject</code>类对象的元类。<br/>
③ 获取<code>NSObject</code>元类的<code>isa</code>变量，它和②的指向一样，说明<strong>NSObject元类</strong>的<strong>isa</strong>指向了<strong>NSObject类对象</strong>自身，和上图中的指向一致。<br/>
④ 获取<strong>NSObject类对象</strong>的元类。<br/>
⑤ 获取<strong>NSObject</strong>实例对象的<code>isa</code>指向，其实就是<strong>NSObject类对象</strong>，所以和①的值相同。<br/>
⑥ 获取<strong>NSObject类对象</strong>的父类，打印<strong>nil</strong>，和上图中标明的一致。</p>

<p>再来一个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  @interface NSObject (Mycategory)
</span><span class='line'>  + (void)foo;
</span><span class='line'>  @end
</span><span class='line'>  
</span><span class='line'>  @implementation NSObject (Mycategory)
</span><span class='line'>  - (void)foo
</span><span class='line'>  {
</span><span class='line'>       NSLog(@"%s",__PRETTY_FUNCTION__);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>@end
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>如果执行下面的代码会输出什么呢？ 😖</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[NSObject foo]; //①
</span><span class='line'>[[NSObject new] performSelector:@selector(foo)];  //②
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>①:对<code>NSObject</code>发送<code>foo</code>消息，会到<strong>NSObject类对象</strong>的元类中查找，理所当然没能找到，然后去到<strong>NSObject类对象元类</strong>的父类里面查找，它的父类是<code>NSObject</code>，然后在<code>NSObject类对象</code>的方法列表里面查找，这时找到了<code>- (void)foo</code>方法，然后跳到函数入口处执行，输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-[NSObject(Mycategory) foo]    </span></code></pre></td></tr></table></div></figure>


<p>②:首先初始化一个<strong>NSObject</strong>实例对象，然后发送<code>foo</code>消息，这是会到<code>NSObject类对象</code>里面查找，这是找到了<code>- (void)foo</code>方法，然后跳到函数入口处执行，输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> -[NSObject(Mycategory) foo]  
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>self和super</h4>

<ul>
<li>在实例方法中<code>self</code>代表着<code>对象</code>本身。</li>
<li>在类方法中，<code>self</code>代表当前<code>类</code>。</li>
</ul>


<p>万变不离其宗，记住一句话就行了：<code>self</code>代表着当前方法的调用者。<br/>
上面讲到了，在<code>Objective-C</code>中对<code>super</code>发送消息时，编译后会被转换为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>接下来我们看看<code>super</code>指针的类型<code>objc_super</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  /// Specifies the superclass of an instance. 
</span><span class='line'>struct objc_super {
</span><span class='line'>    /// Specifies an instance of a class.
</span><span class='line'>    __unsafe_unretained id receiver;
</span><span class='line'>
</span><span class='line'>    /// Specifies the particular superclass of the instance to message. 
</span><span class='line'>#if !defined(__cplusplus)  &&  !__OBJC2__
</span><span class='line'>    /* For compatibility with old objc-runtime.h header */
</span><span class='line'>    __unsafe_unretained Class class;
</span><span class='line'>#else
</span><span class='line'>    __unsafe_unretained Class super_class;
</span><span class='line'>#endif
</span><span class='line'>    /* super_class is the first class to search */
</span><span class='line'>};
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>通过上面的结构我们可以看出：对<code>super</code>发送消息，<code>receiver</code>还是<code>self</code>，唯一的区别是查找方法时不是从本类开始，而是从<code>super_class</code>开始。下面我们来看看一个测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Father : NSObject
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation Father
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@interface Son : Father
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation Son
</span><span class='line'>
</span><span class='line'>- (instancetype)init
</span><span class='line'>{
</span><span class='line'>    self = [super init];
</span><span class='line'>    if (self) {
</span><span class='line'>        NSLog(@"%@",NSStringFromClass([self class]));
</span><span class='line'>        NSLog(@"%@",NSStringFromClass([super class]));
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>运行结果都是输出：<code>Son</code>。由于<code>class</code>在基类<code>NSObject</code>里面有实现，所以两个输出都是输出调用者自己所属的类，这里都输出了<code>Son</code>，而没有输出<code>Father</code>，所以说<code>super</code>只是一个标记符，标记消息的查找是从<code>superClass</code>开始，其他和<code>self</code>没有任何区别。</p>

<h4>Method Swizzling</h4>

<p>我们有时候为了调试方便或者想对系统的方法进行自定义的改造，这是我们可以利用<code>Method Swizzling</code>来进行方法实现的交换。<br/>
对方法的交换我们可以在<code>load</code>或者<code>initialize</code>里面进行，但是需要根据自己的需要进行选择，它们的区别如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f445qxsptrj219m0oo1kk.jpg" alt="image" /></p>

<p>方法的交换就是更改选择子(selector)所对应的<code>IMP</code>，如下：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f445qynrpmj20p40fsapj.jpg" alt="image" /></p>

<p>下面贴上一段<code>Method Swizzling</code>(方法调配)的示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - (void)load
</span><span class='line'>{
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        Class currentClass = [self class];
</span><span class='line'>        SEL originSelector = @selector(foo);
</span><span class='line'>        SEL swizzedSelector = @selector(st_foo);
</span><span class='line'>        
</span><span class='line'>        Method originMethod = class_getInstanceMethod(currentClass, originMethod);
</span><span class='line'>        Method swizzedMethod = class_getInstanceMethod(currentClass, swizzedSelector);
</span><span class='line'>        if (class_addMethod(currentClass, originSelector, method_getImplementation(swizzedMethod), method_getTypeEncoding(swizzedMethod))) {
</span><span class='line'>            class_addMethod(currentClass, swizzedSelector, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));
</span><span class='line'>        } else {
</span><span class='line'>            method_exchangeImplementations(originMethod, swizzedMethod);
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这里需要说明的是<code>if</code>条件里面的判断，如果为真则表示<code>currentClass</code>没有<code>originSelector</code>的方法，然后进行该方法的添加，如果为假则表示<code>currentClass</code>里面已经有了<code>originSelector</code>方法。这里这么做的原因是我们只想对当前类进行方法调配，而不想对父类造成影响。比如当前类的父类里面有一个方法，当前类没有进行覆盖，当我们在当前类里进行<code>方法调配</code>对这个方法的实现进行重新定义，如果直接进行<code>method_exchangeImplementations</code>则交换的是父类的方法。结果会与我们预想的不符。</p>

<h4>消息转发</h4>

<p>前面讲了<code>Objective-C</code>里面的<code>消息传递</code>机制，当我们向一个对象传递一个消息，而当程序运行中无法找到该消息对应的实现，这是就会启动<code>消息转发</code>(message forwarding)机制，这个时候我们可以进行一些操作来防止程序crash。<br/>
我们经常遇到程序异常，控制台输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[ViewController TestMessage]: unrecognized selector sent to instance 0x7fd41075b6a0'
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>这就是向对象传递了无法识别的消息报的异常信息。我们在开发中，可以在进入<code>消息转发</code>后执行预定的逻辑，从而避免奔溃。</p>

<p><code>消息转发</code>大致分为三个步奏：</p>

<h6>1、动态方法解析</h6>

<p>对象在接收到无法识别的消息后，会首先调用所属类的下列方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  + (BOOL)resolveClassMethod:(SEL)sel;//对于类方法
</span><span class='line'>  + (BOOL)resolveInstanceMethod:(SEL)sel;//对于实例方法
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>参数就是无法识别的<code>选择子</code>，这时我们可以在该方法里面为该选择子添加一个实现，返回<code>YES</code>，系统会对该方法再进行一次传递，这时就能正常运行了，但它的前提是添加的实现必须是已经定义好的。如果返回<code>NO</code>，则会就行下一步(下面会说到)，这里贴出简单的示例代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (BOOL)resolveInstanceMethod:(SEL)sel
</span><span class='line'>{
</span><span class='line'>    NSString *selectorString = NSStringFromSelector(sel);
</span><span class='line'>    if ([selectorString isEqualToString:@"foo"]) {
</span><span class='line'>        Method myMethod = class_getInstanceMethod(self, @selector(myFoo));
</span><span class='line'>        class_addMethod(self, sel, method_getImplementation(myMethod), method_getTypeEncoding(myMethod));
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return NO;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h6>2、备援接受者</h6>

<p>如果步骤一未能处理，运行期系统则会看看能不能把消息转发到其他对象，因为当前类肯定<code>组合</code>了一些其他的对象，这时调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> - (id)forwardingTargetForSelector:(SEL)aSelector; 
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>若当前对象能找到合适的消息接受者，则将该接受者返回，若找不到则返回nil，消息转发会进行下一步，这里需要注意的是，未知消息到了这里只能将消息的转发给其他对象，无法修改消息的内容。</p>

<h6>3、完整的消息转发</h6>

<p>如果前两步都没能将未知消息进行有效的处理，则会进入<code>完整的消息转发</code>，首先需要重写<code>methodSignatureForSelector:</code>方法来获取未知消息的参数和返回值类型，如果这个方法里返回<code>nil</code>则消息转发结束，系统发出<code>doesNotRecognizeSelector:</code>消息，然后就挂掉了，如果返回一个签名函数，<code>runtime</code>就会创建一个<code>NSInvocation</code>对象，把未知消息相关的全部细节封装在里面：选择子、target、参数。然后发送<code>-forwardInvocation:</code>消息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - (NSMethodSignature *) methodSignatureForSelector : (SEL)selector
</span><span class='line'>  {  
</span><span class='line'>    NSMethodSignature *signature = [super methodSignatureForSelector:selector];  
</span><span class='line'>      
</span><span class='line'>    if(nil == signature){  
</span><span class='line'>        signature = [self.otherObject methodSignatureForSelector:selector];  
</span><span class='line'>    }  
</span><span class='line'>    
</span><span class='line'>    return signature;  
</span><span class='line'>} 
</span><span class='line'>  
</span><span class='line'>  - (void)forwardInvocation:(NSInvocation *)invocation {  
</span><span class='line'>    SEL selector = [invocation selector];  
</span><span class='line'>      
</span><span class='line'>    if([self.otherObject respondsToSelector:selector]){  
</span><span class='line'>        [invocation invokeWithTarget:self.otherObject];  
</span><span class='line'>    }  
</span><span class='line'>} 
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>综合起来如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f445r01c5qj21f80uk4qq.jpg" alt="image" /></p>

<h6>参考</h6>

<p><a href="http://opensource.apple.com//source/objc4/">runtime源码</a><br/>
<a href="http://tech.glowing.com/cn/objective-c-runtime/">http://tech.glowing.com/cn/objective-c-runtime/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[定制自己的单元测试]]></title>
    <link href="http://summertreee.github.io/blog/2016/05/03/ding-zhi-zi-ji-de-dan-yuan-ce-shi/"/>
    <updated>2016-05-03T09:18:10+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/05/03/ding-zhi-zi-ji-de-dan-yuan-ce-shi</id>
    <content type="html"><![CDATA[<p>我们在进行开发的过程中，会对新开发的功能进行但愿测试，不管是TDD还是BDD，我们都需要利用单元测试来保证我们新功能的正确性，这其中包括执行结果是否正确，对边界处理是否周全，一些特殊情况的测试，这对于一些功能较少的工程可能写好一个<code>testXXX</code>函数，执行一遍单元测试，不会花太多时间，但是对于一些大的工程，可能测试的类会有成百甚至上千个，当你想专注于测试新开发的功能是，每次测试都全部跑一次完整的单元测试，这显然是很耗费时间的行为。</p>

<!--more-->


<p>对于这种情况，我们可以利用<code>Xcode</code>来新建一个<code>scheme</code>，专门只是测试当前新开发的功能的单元测试，步骤如下：</p>

<h6>1、新建一个scheme</h6>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1f3hxfjso7oj208u062dgf.jpg" alt="image" /></p>

<h6>2、对scheme命名</h6>

<p>在新的窗口中，<code>target</code>的下拉框中选择<code>*Tests</code>，这里命名为<code>MyCustomTests</code>。</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1f3hxfkav8jj20r409ugmw.jpg" alt="image" /></p>

<h6>3、定制自己的单元测试</h6>

<p>选择刚才新创建的<code>scheme</code>，进入<code>Edit Scheme...</code>,进入<code>Test</code>选项中，右边就能对需要测试的文件进行筛选：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1f3hxfknumnj21dk0rwagm.jpg" alt="image" /></p>

<p>这是我们再进行单元测试时，就只会执行我们刚才勾选的单元测试文件：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1f3hxflboq8j20ea0a276i.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift脚本编辑]]></title>
    <link href="http://summertreee.github.io/blog/2016/03/28/swiftjiao-ben-bian-ji/"/>
    <updated>2016-03-28T07:23:47+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/03/28/swiftjiao-ben-bian-ji</id>
    <content type="html"><![CDATA[<p><code>Swift</code>是一种编译型语言，功能强大而且灵活性十足，现在你甚至可以在<code>shell</code>脚本中运行<code>Swift</code>代码。</p>

<p>编写<code>shell</code>脚本包括以下几个步骤：</p>

<ol>
<li>使用编辑器创建脚本。</li>
<li>设置脚本的权限，使其能够执行。</li>
<li>执行脚本。</li>
</ol>


<!--more-->


<h4>1、编辑脚本</h4>

<p>我们可以使用<code>Xcode</code>来直接创建<code>shell</code>脚本：</p>

<p>选择菜单 <code>File -&gt; New -&gt; File</code>,在<code>iOS</code>下选择<code>Other</code>，再在右边选择<code>Shell Script</code></p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f2c7xkqp1vj20kc0ehq4t.jpg" alt="image" /></p>

<p>单击<code>Next</code>按钮，将新建的文件保存，命名为<strong>SwiftScript</strong>，Xcode会自动为其添加<code>.sh</code>的后缀名。这时你就可以在新出现的窗口中编辑脚本了。</p>

<p><code>Xcode</code>将自动为这个文件添加几行代码，其中最重要的一行是：</p>

<pre><code>#!/bin/sh  
</code></pre>

<p>这被称为<code>hash bang</code>语法，指定了要用来运行后续代码行的<code>shell</code>在文件系统中的完整路径。这里指定的是<code>/bin/sh（Bash shell）</code>。进行<code>Swift</code>脚本编程时，需要移除这行代码。事实上，请删除所有这些代码行，并输入如下代码行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/env xcrun swift
</span><span class='line'>import Foundation
</span><span class='line'>
</span><span class='line'>class Execution {
</span><span class='line'>class func execute(path path: String, arguments: [String]? = nil) -&gt; Int {
</span><span class='line'>   let task = NSTask()
</span><span class='line'>   task.launchPath = path
</span><span class='line'>   if arguments != nil {
</span><span class='line'>     task.arguments = arguments!
</span><span class='line'>   }
</span><span class='line'>
</span><span class='line'>   task.launch()
</span><span class='line'>   task.waitUntilExit()
</span><span class='line'>   return Int(task.terminationStatus)
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var status : Int = 0
</span><span class='line'>status = Execution.execute(path: "/bin/ls")
</span><span class='line'>print("Status = \(status)")
</span><span class='line'>
</span><span class='line'>status = Execution.execute(path: "/bin/ls", arguments:["/"])
</span><span class='line'>print("Status = \(status)")
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>该脚本的含义将在稍后介绍。</p>

<h4>2、设置权限</h4>

<p>脚本是从命令行运行的，所以启动<code>Terminal</code>，进入到你刚才所写<strong>shell</strong>的文件夹下，执行如下命令：</p>

<pre><code>chmod +x SwiftScript.sh  
</code></pre>

<p>它设置脚本文件的权限，使其能够被<code>shell</code>执行。</p>

<h4>3、运行脚本</h4>

<p>运行脚本很容易，只需要指定脚本的名称，如下：</p>

<pre><code>./SwiftScript.sh  
</code></pre>

<p><strong>./</strong>是告诉shell，需要执行的脚本位于当前目录中，必须显式地指出这一点，否则shell会找不到脚本。</p>

<p>该脚本运行后，你将看到该<code>shell</code>所在文件夹以及磁盘根文件夹的文件清单，你还将看到<code>Status = 0</code>，它指出用于显示文件命令运行正常，没有出现问题。</p>

<h4>4、工作原理</h4>

<p>第一行是前面说过的<code>hash bang</code>，这里指定的应用路径为<code>/usr/bin/env</code>,它是一个为shell脚本设置环境的特殊命令，路径后面是一个你很熟悉的命令&mdash;启动<code>REPL</code>的命令<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #!/usr/bin/env xcrun swift  
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>下一条命令是一个<code>import</code>命令，与我们应用程序一样，<code>Swift</code>脚本也需要有基本的代码库才能运行。<code>Foundation</code>是向<code>Swift</code>脚本提供基本功能的框架，因此这里导入它：</p>

<pre><code>import Foundation  
</code></pre>

<p>接下来是一个名为<code>Execution</code>的<code>Swift</code>类，其使命是执行命令，将需要执行的命令封装在类中，后面的执行将容易很多。</p>

<pre><code>class Execution {

}  
</code></pre>

<p>这个类中只有唯一的类方法<code>execute</code>，用关键字<code>class</code>定义：一个名为<code>path</code>的<strong>String</strong>参数(用于指定要运行的可执行文件的路径)以及一个名为<code>arguments</code>的<strong>String</strong>数组参数(这个参数是可选的，默认值是<em>nil</em>)。这个方法的返回值是一个<code>Int</code>值，指出了命令的执行状态。</p>

<p>在<code>execute</code>方法中使用<code>Foundation</code>类的<code>NSTask</code>来设置启动路径和参数：</p>

<pre><code>let task = NSTask()  
task.launchPath = path
</code></pre>

<p>对于参数<code>arguments</code>，必须检查其为非<strong>nil</strong>才能使用<code>!</code>将其解包并赋值给<code>task</code>对象的属性<code>arguments</code>。</p>

<pre><code>if arguments != nil {
    task.arguments = arguments!
}
</code></pre>

<p>设置好<code>task</code>对象后，调用其<code>launch</code>命令来执行指定的命令：</p>

<pre><code>task.launch()    
</code></pre>

<p>有关<code>NSTask</code>的文档指出，必须调用方法<code>waitUntilExit</code>让任务结束。</p>

<pre><code>task.waitUntilExit()  
</code></pre>

<p>最后，将<code>task</code>对象的属性<code>terminationStatus</code>作为<code>Int</code>值返回（这个属性的类型为<code>Int32</code>，因此这里将其转换为<code>Int</code>，以方便调用者）：</p>

<pre><code>return Int(task.terminationStatus)  
</code></pre>

<p>在类定义的后面，定义了一个变量用于存储方法<code>execute</code>方法的返回值：</p>

<pre><code>var status : Int = 0  
</code></pre>

<p>接下来，调用<code>execute</code>来执行命令<code>、bin/ls</code>（它显示目录中的文件）。<br/>
另外，注意到一开始没有传入参数<code>arguments</code>：</p>

<pre><code>status = Execution.execute(path: "/bin/ls")
println("Status = \(status)")
</code></pre>

<p>接下来，再次调用方法execute来执行命令<code>/bin/ls</code>，但这次通过参数<code>arguments</code>指定了根路径<code>/</code>。</p>

<pre><code>status = Execution.execute(path: "/bin/ls", arguments:["/"])
print("Status = \(status)")  
</code></pre>

<p>你可以使用<code>Swift</code>编写一个类，并在<code>Shell</code>脚本中使用。</p>

<h5>参考文献：</h5>

<p>Swift基础教程</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>REPL(Read-Eval-Print-Loop)是一个命令行工具，可用于快速尝试<code>Swift</code>代码，在<code>Mac OPX</code>中，可在应用程序<code>Terminal</code>中运行它。   <a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试精选：链表问题集锦]]></title>
    <link href="http://summertreee.github.io/blog/2016/03/27/mian-shi-jing-xuan-:lian-biao-wen-ti-ji-jin/"/>
    <updated>2016-03-27T22:13:23+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/03/27/mian-shi-jing-xuan-:lian-biao-wen-ti-ji-jin</id>
    <content type="html"><![CDATA[<blockquote><p>前言：链表由于其本身的灵活性，很能考察程序员的编程功底，在面试中被问到链表相关的知识的概率很高，所以很值得我们去学习汇总，下面的内容非原创，而是自己在复习链表的过程中从别处摘抄而来，若想查看原文内容，可以看文章末尾的链接。</p></blockquote>

<p>下面是本文所要用到的链表节点的定义：</p>

<pre><code>struct Node{
    int data;
    Node* next;
};    
</code></pre>

<!--more-->


<h4>1、在O(1)时间删除链表节点</h4>

<p><strong>题目描述</strong>：给定链表的头指针和一个节点指针，在O(1)时间删除该节点。[Google面试题]</p>

<p><strong>分析</strong>：本题与《编程之美》上的<code>从无头单链表中删除节点</code>类似。主要思想都是<code>狸猫换太子</code>，即用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。</p>

<p><strong>代码如下：</strong></p>

<pre><code>//O(1)时间删除链表节点，从无头单链表中删除节点
void deleteRandomNode(Node *cur)
{
    assert(cur != NULL);
    assert(cur-&gt;next != NULL);    //不能是尾节点
    Node* pNext = cur-&gt;next;
    cur-&gt;data = pNext-&gt;data;
    cur-&gt;next = pNext-&gt;next;
    delete pNext;
}  
</code></pre>

<h4>2、单链表的转置</h4>

<p><strong>题目描述：</strong>输入一个单向链表，输出逆序反转后的链表。</p>

<p><strong>分析：</strong>链表的转置是一个很常见、很基础的数据结构题了，非递归的算法很简单，用三个临时指针 pre、head、next 在链表上循环一遍即可。递归算法也是比较简单的，但是如果思路不清晰估计一时半会儿也写不出来吧。</p>

<p><code>循环版本</code>和<code>递归版本</code>的链表转置代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  
</span><span class='line'>//单链表的转置,循环方法
</span><span class='line'>Node* reverseByLoop(Node *head)
</span><span class='line'>{
</span><span class='line'>    if(head == NULL || head-&gt;next == NULL)
</span><span class='line'>        return head;
</span><span class='line'>    Node *pre = NULL;
</span><span class='line'>    Node *next = NULL;
</span><span class='line'>    while(head != NULL)
</span><span class='line'>    {
</span><span class='line'>        next = head-&gt;next;
</span><span class='line'>
</span><span class='line'>        head-&gt;next = pre;
</span><span class='line'>        pre = head;
</span><span class='line'>        head = next;
</span><span class='line'>    }
</span><span class='line'>    return pre;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//单链表的转置,递归方法
</span><span class='line'>Node* reverseByRecursion(Node *head)
</span><span class='line'>{
</span><span class='line'>    //第一个条件是判断异常，第二个条件是结束判断
</span><span class='line'>    if(head == NULL || head-&gt;next == NULL) 
</span><span class='line'>        return head;
</span><span class='line'>
</span><span class='line'>    Node *newHead = reverseByRecursion(head-&gt;next);
</span><span class='line'>
</span><span class='line'>    head-&gt;next-&gt;next = head;
</span><span class='line'>    head-&gt;next = NULL;
</span><span class='line'>
</span><span class='line'>    return newHead;    //返回新链表的头指针
</span><span class='line'>}
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>3、求链表倒数第k个节点</h4>

<p><strong>题目描述：</strong>输入一个单向链表，输出该链表中倒数第k个节点，链表的倒数第0个节点为链表的尾指针。</p>

<p><strong>分析：</strong>设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//倒数第k个节点
</span><span class='line'>Node* theKthNode(Node *head,int k)
</span><span class='line'>{
</span><span class='line'>    if(k &lt; 0) return NULL;    //异常判断
</span><span class='line'>
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>    int i = k;
</span><span class='line'>    for(;i&gt;0 && fast!=NULL;i--)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(i &gt; 0)    return NULL;    //考虑k大于链表长度的case
</span><span class='line'>
</span><span class='line'>    while(fast != NULL)
</span><span class='line'>    {
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>        fast = fast-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return slow;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>4、求链表的中间节点</h4>

<p><strong>题目描述：</strong>求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。</p>

<p><strong>分析：</strong>此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//求链表的中间节点
</span><span class='line'>Node* theMiddleNode(Node *head)
</span><span class='line'>{
</span><span class='line'>    if(head == NULL)
</span><span class='line'>        return NULL;
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>    //如果要求在链表长度为偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件
</span><span class='line'>    //while(fast && fast-&gt;next != NULL && fast-&gt;next-&gt;next != NULL)  
</span><span class='line'>    while(fast != NULL && fast-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    return slow;
</span><span class='line'>}  
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>5、判断单链表是否存在环</h4>

<p><strong>题目描述：</strong>输入一个单向链表，判断链表是否有环？</p>

<p><strong>分析：</strong>通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//判断单链表是否存在环,参数circleNode是环内节点，后面的题目会用到
</span><span class='line'>bool hasCircle(Node *head,Node *&circleNode)
</span><span class='line'>{
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>    while(fast != NULL && fast-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>        if(fast == slow)
</span><span class='line'>        {
</span><span class='line'>            circleNode = fast;
</span><span class='line'>            return true;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return false;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>6、找到环的入口点</h4>

<p><strong>题目描述：</strong>输入一个单向链表，判断链表是否有环。如果链表存在环，如何找到环的入口点？</p>

<p><strong>解题思路：</strong>由上题可知，按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。</p>

<p><strong>为什么？：</strong>假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有：</p>

<p>p1走的路径：<code>a+b ＝ n</code>；</p>

<p>p2走的路径： <code>a+b+k*L = 2*n</code>； p2 比 p1 多走了k圈环路，总路程是p1的2倍；</p>

<p>根据上述公式可以得到 <code>k*L=a+b=n</code>显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。</p>

<p>显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//找到环的入口点
</span><span class='line'>Node* findLoopPort(Node *head)
</span><span class='line'>{
</span><span class='line'>    //如果head为空，或者为单结点，则不存在环
</span><span class='line'>    if(head == NULL || head-&gt;next == NULL) return NULL;
</span><span class='line'>
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>
</span><span class='line'>    //先判断是否存在环
</span><span class='line'>    while(fast != NULL && fast-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>        if(fast == slow)
</span><span class='line'>            break;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(fast != slow) return NULL;    //不存在环
</span><span class='line'>
</span><span class='line'>    fast = head;                //快指针从头开始走，步长变为1
</span><span class='line'>    while(fast != slow)            //两者相遇即为入口点
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return fast;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>7、编程判断两个链表是否相交</h4>

<p><strong>题目描述：</strong>给出两个单向链表的头指针（如下图所示）：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f2brlca2xlj20d403qaa0.jpg" alt="image" /></p>

<p>比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。</p>

<p><strong>解题思路：</strong></p>

<ol>
<li>直接循环判断第一个链表的每个节点是否在第二个链表中。但，这种方法的时间复杂度为O(Length(h1) * Length(h2))。显然，我们得找到一种更为有效的方法，至少不能是O（N<sup>2</sup>）的复杂度。</li>
<li>针对第一个链表直接构造hash表，然后查询hash表，判断第二个链表的每个节点是否在hash表出现，如果所有的第二个链表的节点都能在hash表中找到，即说明第二个链表与第一个链表有相同的节点。时间复杂度为为线性：O(Length(h1) + Length(h2))，同时为了存储第一个链表的所有节点，空间复杂度为O(Length(h1))。是否还有更好的方法呢，既能够以线性时间复杂度解决问题，又能减少存储空间？</li>
<li>转换为环的问题。把第二个链表接在第一个链表后面，如果得到的链表有环，则说明两个链表相交。如何判断有环的问题上面已经讨论过了，但这里有更简单的方法。因为如果有环，则第二个链表的表头一定也在环上，即第二个链表会构成一个循环链表，我们只需要遍历第二个链表，看是否会回到起始点就可以判断出来。这个方法的时间复杂度是线性的，空间是常熟。</li>
<li>进一步考虑“如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。
所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)，显然比解法三更胜一筹。</li>
</ol>


<p><strong>解法的代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//判断两个链表是否相交
</span><span class='line'>bool isIntersect(Node *h1,Node *h2)
</span><span class='line'>{
</span><span class='line'>    if(h1 == NULL || h2 == NULL) return false;    //异常判断
</span><span class='line'>    while(h1-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        h1 = h1-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    while(h2-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        h2 = h2-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(h1 == h2) return true;        //尾节点是否相同
</span><span class='line'>    else return false;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>8、 扩展：链表有环，如何判断相交</h4>

<p><strong>题目描述：</strong>上面的问题都是针对链表无环的，那么如果现在，链表是有环的呢?上面的方法还同样有效么?</p>

<p><strong>分析：</strong>如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//判断两个带环链表是否相交
</span><span class='line'>bool isIntersectWithLoop(Node *h1,Node *h2)
</span><span class='line'>{
</span><span class='line'>    Node *circleNode1,*circleNode2;
</span><span class='line'>    if(!hasCircle(h1,circleNode1))    //判断链表带不带环，并保存环内节点
</span><span class='line'>        return false;                //不带环，异常退出
</span><span class='line'>    if(!hasCircle(h2,circleNode2))
</span><span class='line'>        return false;
</span><span class='line'>
</span><span class='line'>    Node *temp = circleNode2-&gt;next;
</span><span class='line'>    while(temp != circleNode2)
</span><span class='line'>    {
</span><span class='line'>        if(temp == circleNode1)
</span><span class='line'>            return true;
</span><span class='line'>        temp = temp-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    return false;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>9、扩展：两链表相交的第一个公共节点</h4>

<p><strong>题目描述：</strong>如果两个无环单链表相交，怎么求出他们相交的第一个节点呢？</p>

<p><strong>分析：</strong>采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//求两链表相交的第一个公共节点
</span><span class='line'>Node* findIntersectNode(Node *h1,Node *h2)
</span><span class='line'>{
</span><span class='line'>    int len1 = listLength(h1);          //求链表长度
</span><span class='line'>    int len2 = listLength(h2);
</span><span class='line'>    //对齐两个链表
</span><span class='line'>    if(len1 &gt; len2)
</span><span class='line'>    {
</span><span class='line'>        for(int i=0;i&lt;len1-len2;i++)
</span><span class='line'>            h1=h1-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    else 
</span><span class='line'>    {
</span><span class='line'>        for(int i=0;i&lt;len2-len1;i++)
</span><span class='line'>            h2=h2-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    while(h1 != NULL)
</span><span class='line'>    {
</span><span class='line'>        if(h1 == h2)
</span><span class='line'>            return h1;
</span><span class='line'>        h1 = h1-&gt;next;
</span><span class='line'>        h2 = h2-&gt;next;    
</span><span class='line'>    }
</span><span class='line'>    return NULL;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>原文链接，请戳<a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS测试之UIAutomation介绍]]></title>
    <link href="http://summertreee.github.io/blog/2016/02/29/iosce-shi-zhi-uiautomationjie-shao/"/>
    <updated>2016-02-29T07:47:18+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/02/29/iosce-shi-zhi-uiautomationjie-shao</id>
    <content type="html"><![CDATA[<p>UIAutomation是随着iOS SDK 4.0引入的，帮助开发者在<code>while you sleep</code>的时候也能帮你进行自动化的UI测试，它的测试代码使用Javascript编写，不过别担心，如果你对Javascript不熟悉的话，可以使用Instrument中<code>UIAutomation</code>的录制功能，它能将你的操作转换为测试代码，你只需要保存这些自动生成的代码就行，稍后我们将介绍该功能。</p>

<p>使用<code>UIAutomation</code>做自动化UI测试时，使用者需要做最基本的两件事情是：</p>

<ul>
<li>如何找到界面上的UI元素</li>
<li>如何针对找到的UI元素进行测试操作</li>
</ul>


<!--more-->


<h4>如何找到界面上的UI元素</h4>

<p>在<code>UIAutomation</code>中，界面就是一堆UI元素构建的层级结构，这些元素需要一个叫<code>Accessibility label</code>去标记，它可以在如下所示的地方进行设置：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1q07rxj20bn0d83zs.jpg" alt="image" /></p>

<p><code>UI Accessibility</code>在iOS3.0就被引入了，它是用来辅助身体不便的人士使用APP的，VoiceOver是Apple的屏幕阅读技术，而<code>UI Accessibility</code>的基本原则就是对屏幕上的UI元素进行分类和标记，两者配合，通过阅读和聆听这些元素，用户就可以在不接触屏幕的情况下通过声音使用APP。</p>

<p><code>Accessibility</code> 的核心思想是对 UI 元素进行分类和标记，将屏幕上的UI分类为像是按钮，文本框，Cell或者是静态文本(也就是label) 这样的类型，然后使用<code>identifier</code>来区分不同的UI元素。用户可以通过语音控制app的按钮点击，或是询问某个label的内容等等，十分方便。iOS SDK 中的控件都实现了默认的<code>Accessibility</code>支持，而我们如果使用自定义的控件的话，则需要自行使用 <code>Accessibility</code> 的 API 来进行添加。</p>

<h4>对找到的UI元素进行测试操作</h4>

<h5>1、启动Instruments</h5>

<p>由于<code>UIAutomation</code>被集成到了<code>Instruments</code>中，所以要进行<code>UIAutomation</code>测试，首先打开如下所示的工具<code>Automation</code></p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1qinz2j20l90bz774.jpg" alt="image" /></p>

<h6>2、编写测试代码</h6>

<p>打开<code>Automation</code>如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1r6ehaj20ou0jdq6l.jpg" alt="image" /></p>

<p>在这里我们可以进行测试代码的编写或者在右边区域直接导入已经写好的测试代码，正如前面提到的，这些测试代码需要使用JavaScript进行编写，如果你不熟悉或者嫌麻烦，可以使用底部的录制功能，启用录制后你对屏幕的测试操作都会被自动的转为测试代码，非常方便。</p>

<p>测试如果不通过，就会在顶部的时间轴上标红，测试也会自动停止。</p>

<h6>3、测试代码相关的简介</h6>

<p>在<code>UIAutomation</code>中所有元素都继承自<code>UIAElement</code>，这个对象提供了每个UI元素所应具备的如下属性：</p>

<ul>
<li>name</li>
<li>value</li>
<li>elements</li>
<li>parent</li>
</ul>


<p>一、Target application<br/>
获取方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIAtarget.localTarget().ftontMostApp()  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1rmjppj208u0dw769.jpg" alt="image" /></p>

<p>二、Main Window<br/>
获取到他的方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIAtarget.localTarget().ftontMostApp().mainWindow()  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1rmjppj208u0dw769.jpg" alt="image" /></p>

<p>三、View<br/>
获取主视图的方法如下(eg:UITableView):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().mainWindow ().tableViews()[0]  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1se2hij208u0dwac1.jpg" alt="image" /></p>

<p>四、Element<br/>
例如获取tableView下的第一行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().mainWindow ().tableViews()[0].cells()[0]  </span></code></pre></td></tr></table></div></figure>


<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1t0c7rj208w0dwtao.jpg" alt="image" /></p>

<p>五、Child Element<br/>
例如想获取第一行里面的显示标题的label：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().mainWindow ().tableViews()[0].cells()[0].elements()[“第一章 会计法律制度”]  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1te5d2j208u0dwabz.jpg" alt="image" /></p>

<p>六、button的点击事件<br/>
例如一个叫<code>Edit</code>的button，我们要模拟对他的点击，可以如下测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().navigationBar().buttons()["Add"].tap();  </span></code></pre></td></tr></table></div></figure>


<p>
七、文本的输入<br/>
例如界面上只有一个<code>UITextField</code>，我们要测试对它输入一段文字：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var name = “Turtle Pie”; UIATarget.localTarget().frontMostApp().mainWindow().textFields()[0].setValue(name);  </span></code></pre></td></tr></table></div></figure>


<p>八、Logging<br/>
开始测试和结束测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var testName = "My first test"; UIALogger.logStart(testName); ... // test code ... UIALogger.logPass(testName);</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>测试过程中打印Log信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var testName = "My first test"; UIALogger.logStart(testName); ... UIALogger.logMessage("Logging about my test"); ... UIALogger.logPass(testName);  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>九、模拟点击Home键进入后台一段时间再自动唤起：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> UIALogger.logMessage("Deactivating app");
</span><span class='line'> //10s后自动唤起 UIATarget.localTarget().deactivateAppForDuration(10); UIALogger.logMessage("Resuming test after deactivation");</span></code></pre></td></tr></table></div></figure>


<p>
十、模拟Orientation切换：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var target = UIATarget.localTarget(); var app = target.frontMostApp(); // set landscape left target.setDeviceOrientation(UIA_DEVICE_ORIENTATION_LANDSCAPELEFT); UIALogger.logMessage("Current orientation is " + app.interfaceOrientation()); // portrait target.setDeviceOrientation(UIA_DEVICE_ORIENTATION_PORTRAIT); UIALogger.logMessage("Current orientation is " + app.interfaceOrientation());   </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>模拟手势操作</h5>

<p>一、Taps</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().tap({x:100, y:200});UIATarget.localTarget().doubleTap({x:100, y:200});UIATarget.localTarget().twoFingerTap({x:100, y:200});</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>二、Pinches</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//指定pinch在2秒内完成
</span><span class='line'>UIATarget.localTarget().pinchOpenFromToForDuration({x:20, y:200}, {x:300, y:200},2);UIATarget.localTarget().pinchCloseFromToForDuration({x:20, y:200}, {x:300, y:200}, 2);</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>三、Drag and Flick</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().dragFromToForDuration({x:160, y:200}, {x:160, y:400}, 1);UIATarget.localTarget().flickFromTo({x:160, y:200}, {x:160, y:400});</span></code></pre></td></tr></table></div></figure>


<p>虽然从iOS7开始，<code>UIAutomatation</code>苹果不在维护了，转而支持Xcode中的UI Testing，但是它却可以测试复杂的手势操作，这是目前UI Testing无法完成的。</p>

<h5>参考文章</h5>

<p>1、<a href="https://developer.apple.com/videos/play/wwdc2010/306/">https://developer.apple.com/videos/play/wwdc2010/306/</a><br/>
2、<a href="http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation">http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation</a><br/>
3、<a href="http://onevcat.com/2015/09/ui-testing/">http://onevcat.com/2015/09/ui-testing/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中如何在一个工程创建多个App]]></title>
    <link href="http://summertreee.github.io/blog/2016/01/23/ioszhong-ru-he-zai-%5B%3F%5D-ge-gong-cheng-chuang-jian-duo-ge-app/"/>
    <updated>2016-01-23T20:11:40+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/01/23/ioszhong-ru-he-zai-[?]-ge-gong-cheng-chuang-jian-duo-ge-app</id>
    <content type="html"><![CDATA[<p>一般情况下，我们是一个App应用对应一个<code>Xcode Project</code>，但是如果你需要同时开发多个产品，而这些产品90%的数据结构以及交互方式都一样，呈现在用户面前的这两个产品，最大的不一样就是UI元素以及某些配色时，如果这个时候还是一个App一个<code>Xcode Project</code>，普遍的做法是：</p>

<p>你会先开发完成一个产品，然后在复制到其他的产品中，非常的麻烦而且效率很低，你需要一个一个文件去比对。如果你使用模块的方式，开发完一个模块，然后再利用<code>Pod</code>的方式导入到其他产品中，虽然这样可行，但是涉及到产品的迭代开发以及产品的随时会变的交互，模块的细化分很难实现。</p>

<p>如果你也面临这样的问题，不放考虑一下下面讲的<code>一个工程来开发多个App</code>：</p>

<!--more-->


<h4>1、创建新的Target</h4>

<p>如果现在你已经有个一个产品叫<code>MultipleTargetA</code>，如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f09onfv2lnj20e709xabz.jpg" alt="image" /></p>

<p>这时你想添加一个叫<code>MultipleTargetB</code>的产品，你需要做的是按如下的步奏进行创建：
选择<code>Project -&gt; Targets -&gt; 右击MultipleTargetsA -&gt; 选择Duplicate</code>，这时我们就按照<code>MultipleTargetsA</code>复制了一个产品<code>MultipleTargetsA copy</code>，并且你会看到多出了一个文件<code>MultipleTargetsA copy-Info.plist</code>，如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f09onggesdj20cr0b8q53.jpg" alt="image" /></p>

<p>将<strong>TARGETS</strong>里面的<code>MultipleTargetsA copy</code>改名为<code>MultipleTargetsB</code>（选中回车进入编辑）。</p>

<h4>2、编辑plist文件</h4>

<p>上面讲到了当我们创建新的<code>Target</code>后会多出一个<code>MultipleTargetsA copy-Info.plist</code>文件，这个<code>plist</code>文件就是控制<code>MultipleTargetsB</code>的名称，版本等信息的文件，我们为了统一将他改为<code>MultipleTargetsB-Info.plist</code>，在修改名字之前你需要在<code>MultipleTargetsB</code>的<code>Build Settings</code>中找到<code>MultipleTargetsA copy-Info.plist</code>一项，待会儿我们修改完这个<code>plist</code>文件以后，还需要在这里填入它正切的位置信息。这样程序执行时才能找到它，不然程序是不能通过编译的：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f09ongryr7j20oq0algnp.jpg" alt="image" /></p>

<p>处理完上面的操作后，程序能正常通过编译后我们还需要修改<code>plist</code>文件里面的一下符合我们预期的信息：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f09onhbzvjj20h20aydj0.jpg" alt="image" /></p>

<h4>3、定义Preprocessor Macros</h4>

<p>现在我们的工程里面同时包含了两个<code>Target</code>，现在工程里面的类是这两个<code>Target</code>公用的，如果你想在一个类里面区分是<code>MultipleTargetsA</code>还是<code>MultipleTargetsB</code>，这时你就需要用到<code>Preprocessor Macros</code>了，它的定义很简单，选中一个<code>Target</code>，然后在<code>Build Settings</code>里面搜索<code>Preprocessor Macros</code>一项，然后在里面添加表明是<code>MultipleTargetsA</code>的宏：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f09oni1sa6j20ol0fbwhe.jpg" alt="image" /></p>

<p>假如我们为<code>MultipleTargetsA</code>和<code>MultipleTargetsB</code>分别按如上步奏添加了标识：<code>MultipleTargetsA</code>和<code>MultipleTargetsB</code>,那在某个类里面判断现在编译的目标是哪个<code>Target</code>就变得简单了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)someFunction
</span><span class='line'>{
</span><span class='line'>#ifdef MultipleTargetsA
</span><span class='line'>    NSLog(@"Build For Target MultipleTargetsA!");
</span><span class='line'>#else
</span><span class='line'>    NSLog(@"Build For Target MultipleTargetsB!");
</span><span class='line'>#endif
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>4、修改Scheme</h4>

<p>现在<code>MultipleTargetsB</code>的<code>Scheme</code>还是<code>MultipleTargetsA copy</code>:</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f09onihy4tj20c20820uh.jpg" alt="image" /></p>

<p>我们可以通过<code>Manage Schemes</code>，选择<code>MultipleTargetsA copy</code>，然后按回车键进行编辑，将它改为<code>MultipleTargetsB</code>：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f09onj571gj20m00d4dh4.jpg" alt="image" /></p>

<h4>5、资源文件和类文件</h4>

<p>上面说了几个<code>APP</code>%90是相同的，不同的地方的资源文件和类文件如果要加以区分，比如<code>A.m</code>类属于<code>MultipleTargetsA</code>而不属于<code>MultipleTargetsB</code>，这时我们可以利用<code>Xcode</code>的<code>Target Membership</code>功能，来选择该类属于哪个<code>Target</code>。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f09onjlay4j20dw0a5dh8.jpg" alt="image" /></p>

<p>对于<code>Assets</code>文件来说，它只能整体的选择某个<code>Target</code>，所以不同的<code>Target</code>你可能需要建立不同的<code>Assets</code>文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classes and Metaclasses]]></title>
    <link href="http://summertreee.github.io/blog/2015/12/28/classes-and-metaclasses/"/>
    <updated>2015-12-28T13:53:36+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/12/28/classes-and-metaclasses</id>
    <content type="html"><![CDATA[<p>这是一篇译文，原文<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">在这里</a>，水平有限，翻译难免有错误的地方。</p>

<p><code>Objective-C</code>是一个基于类别对象的系统。每一个对象都是某个类的实例，对象的<code>isa</code>指向它自己的类(Class),这个类描述了该对象所有的数据信息：开辟的空间大小，成员变量类型以及其他信息的排列，这个类同样也描述了该对象可以执行的一些行为：可以响应哪些<code>selector</code>以及它自己实例方法的实现。</p>

<p>类的方法列表里面其实就是该类的所有实例方法的集合，通俗的讲就是该对象可以响应的所有<code>selectors</code>。当你向一个类发送消息时，会通过<code>objc_msgSend()</code>去查找它自身的类的方法列表(如果它有父类的话，也会在它的父类方法列表中去查找)来决定调用哪一个方法。</p>

<!--more-->


<p><code>Objective-C</code>的每一个类也是一个对象，它也有<code>isa</code>指针以及其他的一些信息，同样它也能响应<code>selector</code>，当你调用类方法时，比如：<code>[NSObject alloc]</code>，其实你是在向该类发送消息。</p>

<p>上面说了，类也是一个对象，那它必定也是其他某一个类的一个实例，这就是<code>metaclass</code>，<code>metaclass</code>里面存放了类对象的所有信息，类和<code>metaclass</code>的关系就和刚才上面讲的实例对象和该实例的类的关系一样，<code>metaclass</code>的方法列表里面存放的该类对象能够响应的方法。当你向一个类(这个类是某个metaclass的一个实例对象)发送一个消息时，<code>objc_msgSend()</code>回去遍历<code>metaclass</code>的方法列表，如果它有父类的话，同样也会遍历父类的所有方法列表，从而决定调用哪一个方法。类方法的定义存放与类对象的<code>metaclass</code>，与之相对应的是实例方法的定义存放于实例对象对应的类里面。</p>

<p><code>metaclass</code>究竟是个啥？它也是一直向下的吗？NO，一个<code>metaclass</code>又是某个类的根类的<code>metaclass</code>实例对象，根<code>metaclass</code>又是它自身的一个实例对象，在这里<code>isa</code>指针的指向形成了一个环：实例对象->类->metaclass->根metaclass->它自己(根metaclass)，在实际的使用中我们很少和metaclass直接打交道。</p>

<p><code>metaclass</code>的父类和类的父类直接形成了两条平行线，所有类方法的继承类似于实例方法的继承，并且根<code>metaclass</code>的父类就是根类，所以每个类对象都能响应根类的实例方法，最后需要说一下的是一个类对象是它根类或者根类的一个子类的实例。</p>

<p>是不是觉得有些迷惑，下面的图或许能给你一点帮助，你需要记住的是，当向一个对象发送任何消息是，都是从该对象的<code>isa</code>指针开始，然后按着它的父类一直寻找，直到找到合适的方法去调用，实例方法定义在类里面，类方法定义在<code>metaclass</code>和根类里面。<br/>
<img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0jw1ezfb7ybjzqj20gw0hm40e.jpg" alt="image" /></p>

<p><code>Objective-C</code>为了它的实用性，将类方法由<code>metaclass</code>管理，但另一方面它又想把<code>metaclass</code>影藏起来，例如<code>[NSObject class]</code>和<code>[NSObject self]</code>是完全等价的，其实它这个时候是返回的<code>metaclass</code>，也就是<code>NSObject-&gt;isa</code>所指向的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ContentCompressionResistance和ContentHugging详解]]></title>
    <link href="http://summertreee.github.io/blog/2015/12/13/contentcompressionresistancehe-contenthuggingxiang-jie/"/>
    <updated>2015-12-13T17:07:53+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/12/13/contentcompressionresistancehe-contenthuggingxiang-jie</id>
    <content type="html"><![CDATA[<p>在Auto Layout的使用中，有两个很重要的布局概念：<code>Content Compression Resistance</code>和<code>Content Hugging</code>，从字面的翻译我们大概可以分别翻译为：<code>压缩阻力</code>以及<code>内容吸附</code>。但是光从字面意思来理解很难知道它们如何使用以及确切的设计意图。我最开始也是很迷糊而且在使用Auto Layout的过程中也没有使用过它们，直到最近稍稍研究了一下，发现它们的作用甚是巨大，所以我为了加深记忆，把我最近学习到的关于它们的概念在此稍作整理加以记录。</p>

<blockquote><p>注：以下为了表述方便，将<code>Content Compression Resistance</code>记为<code>压缩阻力</code>，将<code>Content Hugging</code>记为<code>内容吸附</code>。</p></blockquote>

<!--more-->


<h4>Content Compression Resistance</h4>

<p><strong>压缩阻力</strong>属性为了记忆更加形象我们可以把它理解为<strong>离我远点，不许挤到我</strong>，它的优先级（Priority）越高，它的这种抗挤压的能力也就越强，我们可以通过代码在控件的水平或垂直方向上分别设置1（最低优先级）到1000（最高优先级）之间的优先级，默认是750，例如我们可以为一个<strong>UILabel</strong>控件设置一个它在水平方向上优先级为<em>500</em>的压缩阻力：</p>

<pre><code>[label setContentCompressionResistancePriority:500 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>用图来表示，我们可以大致表示如下，视图的压缩阻力就好似它自身往外的张力，优先级越高，视图自己维持自身显示完整性的能力就越强：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwdofkoj208r08r74s.jpg" alt="image" /></p>

<h4>Content Hugging</h4>

<p><strong>内容吸附</strong>属性为了记忆方便我们可以把它理解为<strong>抱紧（Hug）</strong>，视图的大小不会随着superView的变大而扩大，而是只维持能完全显示自己内容的大小，它的这种优先级越高，吸附的能力就越强，和<strong>压缩阻力</strong>一样，<strong>内容吸附</strong>的优先级也可以通过代码来设置，只是它的默认优先级是<em>250</em>：</p>

<pre><code>[label setContentHuggingPriority:251 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>用图来表示，我们可以大致表示如下，视图的内容吸附就好似视图自己有向内抱紧自己的力量一样，优先级越高，它的这种能力就越强：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwdllbej208n08mq3e.jpg" alt="image" /></p>

<p>以上讲了<code>内容吸附</code>和<code>压缩阻力</code>的基本概念，但是这两个属性是建立在<code>Intrinsic Content Size</code>这一概念上的，我们暂且把它翻译为<code>固有尺寸</code>，所有基于UIView的视图都有<code>intrinsicContentSize</code>这个属性，下面我们就介绍一下什么是<code>固有尺寸</code>。</p>

<h4>Intrinsic Content Size</h4>

<p>每个视图都有压缩阻力优先级（Content Compression Resistance Priority）和内容吸附优先级（Content Hugging Priority），但只有视图明确了它的<code>固有尺寸</code>后，这两种优先级才会起作用。我们首先来看一下官方的解释：</p>

<blockquote><p> Custom views typically have content that they display of which the layout system is unaware. Overriding this method allows a custom view to communicate to the layout system what size it would like to be based on its content. This intrinsic size must be independent of the content frame, because there’s no way to dynamically communicate a changed width to the layout system based on a changed height, for example.
If a custom view has no intrinsic size for a given dimension, it can return UIViewNoIntrinsicMetric for that dimension.</p></blockquote>

<p>大致的意思就是我们自定义的视图在默认情况下，它的固有尺寸是返回(UIViewNoIntrinsicMetric，UIViewNoIntrinsicMetric)，也就是(-1,-1)，只有我们根据自定义视图本身的Content来重写该方法，我们自定义的视图才能明确的知道他在显示系统中该展示的大小。<br/>
UILabel和UIButton等这些控件，系统默认是根据他们的内容实现了固有尺寸，所以我们在使用的时候只需要确定origin或者Center它们就能正确的显示。<br/>
由此可见，固有尺寸是为了实现视图的<strong>大小自适应</strong>而存在的。</p>

<p>以下我来自定义一个视图，来测试一下<code>固有尺寸</code>是否有效，由于项目中大家都是用<a href="http://https://github.com/SnapKit/Masonry">Masonry</a>来处理Auto Layout，所以一下的例子都使用<code>Masonry</code>来布局。</p>

<h5>重写Intrinsic Content Size</h5>

<p>我们新建一个继承自<code>UIView</code>的自定义视图<code>IntrinsicView</code>，在一个ViewController中添加一个我们自定义的视图,设置它水平居中，顶部和父视图对齐。</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *intrinsicView = [IntrinsicView new];
    intrinsicView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:intrinsicView];
    [intrinsicView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.mas_equalTo(self.view);
    make.top.mas_equalTo(self.mas_topLayoutGuideBottom);
}];
}
</code></pre>

<p>运行后发现什么也没显示，因为我们没有设置它的宽高，而它默认的固有尺寸是（-1 ，-1）。我们去重写<code>IntrinsicView</code>的<code>- (CGSize)intrinsicContentSize</code>方法：</p>

<pre><code>@implementation IntrinsicView

- (CGSize)intrinsicContentSize
{
    return CGSizeMake(150, 66);
}

@end  
</code></pre>

<p>运行后显示如下：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw65tsuj208y0ddaa5.jpg" alt="image" /></p>

<p>显示出来，它的大小刚好是我们定义的<code>intrinsicContentSize</code>大小。上面介绍了内容吸附和压缩阻力以及固有尺寸的基本概念，下面来测试一下它们应该如何使用。</p>

<h6>1、测试内容吸附优先级</h6>

<p>为了测试内容吸附优先级我们在页面上添加两个<code>IntrinsicView</code>，分别是<code>topView</code>和<code>bottomView</code>，设置他们都水平居中，然后分别和页面的顶部和底部对齐：</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *topView = [IntrinsicView new];
    topView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:topView];
    [topView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(self.mas_topLayoutGuideBottom);//和导航栏底部对齐
    }];

    IntrinsicView *bottomView = [IntrinsicView new];
    bottomView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:bottomView];
    [bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.bottom.mas_equalTo(self.mas_bottomLayoutGuideBottom);//和页面底部对齐
    }];
}  
</code></pre>

<p>运行后展示如下：<br/>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw6ih8aj208w0ddglq.jpg" alt="image" /></p>

<p>下面我们设置<strong>topView</strong>和<strong>bottomView</strong>之间的间距为<em>40</em>，也就是<code>topView.bottom + 40 = bottomView.top</code>。</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *topView = [IntrinsicView new];
    topView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:topView];
    [topView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(self.mas_topLayoutGuideBottom);//和导航栏底部对齐
}];

    IntrinsicView *bottomView = [IntrinsicView new];
    bottomView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:bottomView];
    [bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(topView.mas_bottom).offset(40);
        make.bottom.mas_equalTo(self.mas_bottomLayoutGuideBottom);//和页面底部对齐
 }];
}  
</code></pre>

<p>运行后展示效果如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw6xva7j208v0dcmxb.jpg" alt="image" /></p>

<p>我们发现<code>topView</code>被拉伸了，如果我们不想<code>topView</code>被拉伸，就可以利用<code>内容吸附</code>的特性，因为我们定义了<code>IntrinsicView</code>的固有尺寸，设置<code>topView</code>的<code>内容吸附</code>优先级比<code>bottomView</code>的优先级高，我们上面介绍了<code>内容吸附</code>的默认优先级是<em>250</em>，我们把<code>topView</code>的<code>内容吸附</code>优先级设置为<em>251</em>，在原来<code>layoutSubIntrinsicView</code>函数的最后添加如下语句：</p>

<pre><code>[topView setContentHuggingPriority:251 forAxis:UILayoutConstraintAxisVertical];  
</code></pre>

<p>运行后如下所示，达到了我们想要的效果：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw7a0tqj208w0ddt8v.jpg" alt="image" /></p>

<blockquote><p>251是我随意定的比250大的值，可以是大于250小于1000的任何值。</p></blockquote>

<h6>2、测试压缩阻力优先级</h6>

<p>我们通常会遇到如下图所示的需求：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw7yw9hj20e007cdgi.jpg" alt="image" /></p>

<p>在某个页面上水平放置两个UILabel，<code>leftLabel</code>的左边和父视图的间距固定，<code>rightLabel</code>的右边和父视图的右边有一个小于等于某个间隔的约束，<code>leftLabel</code>和<code>rightLabel</code>之间有一个固定间距，它们的宽度根据他们显示的内容自适应，关键代码如下:</p>

<pre><code>[leftLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    //左边和父视图间隔固定为10
    make.left.mas_equalTo(self.view).offset(10);
    make.top.mas_equalTo(80);//随意设定的值
}];

[rightLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.mas_equalTo(leftLabel);
    //和leftLabel的右边间距固定为20
    make.left.mas_equalTo(leftLabel.mas_right).offset(20);
    //这里注意是‘lessThanOrEqualTo’，也就是‘rightLabel’的右边界
    //和父视图的间距至少为10，内容少时，间距自动调大
    make.right.mas_lessThanOrEqualTo(self.view).offset(-10);
}];  
</code></pre>

<p>在他们的显示内容宽度不超过父视图宽度时，两个label的内容都能正常的完全显示，但是当它们需要显示的内容长度总和超过父视图的宽度时，就会显示如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwckaf2j208x0ddglw.jpg" alt="image" /></p>

<p>一个label被压缩了， <code>rightLabel</code>显示不完全，如果在这种情况下，我们想<code>leftLabel</code>被压缩，而<code>rightLabel</code>尽量完全显示，由于UILabel这类控件，系统自己已经根据它们显示的实际内容实现了<code>固有尺寸</code>的方法，我们可以利用<code>压缩阻力</code>的特性，将<code>rightLabel</code>的<code>压缩阻力</code>优先级设置得比<code>leftLabel</code>高，上面介绍了<code>压缩阻力</code>的默认优先级是<em>750</em>，我们把<code>rightLabel</code>的优先级设置为<em>751</em>，在上面代码的最下面添加如下代码：</p>

<pre><code>[rightLabel setContentCompressionResistancePriority:751 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>运行后显示如下，达到了我们预期的效果：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwd0cbqj208x0dddg4.jpg" alt="image" /></p>

<h6>3、在自动计算UITableViewCell高度中的使用</h6>

<p>对于变高cell的处理，以前我们都是在<code>heightForRowAtIndexPath</code>方法里面，拼凑要展示的变高cell的高度，当我们改变cell中两个控件在垂直方向的布局，或者再添加一个控件时，还要去修改计算cell高度的方法来适应新的变化，非常不方便。但是有了自动布局后，利用好<code>压缩阻力</code>和<code>内容吸附</code>的优先级，可以很精确很简单的由系统来计算出变高cell的高度。</p>

<p>假定我们有如下需求：<br/>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxt9hqfj20e1097dgw.jpg" alt="image" /></p>

<p>我们看到，这个变高cell里面高度不定的是中间的<code>ContentLabel</code>，它会根据内容长度来折行显示，<strong>UILabel</strong>要折行显示我们需要设置它的<code>preferredMaxLayoutWidth</code>和<code>numberOfLines</code>两个属性的值。</p>

<p>首先假定<code>Model</code>的定义如下：</p>

<pre><code>@interface CellModel : NSObject

@property (nonatomic, copy) NSString *name;
@property (nonatomic, copy) NSString *company;
@property (nonatomic, copy) NSString *content;
@property (nonatomic, assign) CGFloat cacheHeight;//缓存当前Model显示的cell高度

@end
</code></pre>

<p>自定义的<code>UITableViewCell</code>的关键代码如下：</p>

<pre><code>//图片距左边距离为10，上下居中
    [_cellImageView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.contentView).offset(10);
        make.centerY.mas_equalTo(self.contentView);
        make.top.mas_greaterThanOrEqualTo(self.contentView).offset(10);
        make.bottom.mas_lessThanOrEqualTo(self.contentView).offset(-10);
    }];
    //标题Label,一行显示
    [_nameLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.cellImageView.mas_right).offset(6);
        make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
        make.top.mas_equalTo(self.contentView).offset(10);
    }];
    //内容label,多行显示
    _contentLabel.numberOfLines = 0;
    [self.contentView addSubview:_contentLabel];
    [_contentLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.nameLabel);
        make.top.mas_equalTo(self.nameLabel.mas_bottom).offset(6);
    }];
    //标题Label,一行显示
    [_companyLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.contentLabel);
        make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
        make.top.mas_equalTo(self.contentLabel.mas_bottom).offset(6);
        make.bottom.mas_equalTo(self.contentView).offset(-10);//设定了这个自动计算cell高度时才知道具体cell的高度
    }];

    [_nameLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
    [_companyLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
    [_contentLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];  
</code></pre>

<p>上面的代码中设置了几个<code>UILabel</code>的<code>内容吸附</code>优先级为最高，这样它们就不会随着cell高度的变化而拉伸高度。上面设置了<code>contentLabel</code>的<code>numberOfLines = 0</code>，还需要设置<code>preferredMaxLayoutWidth</code>才能正确换行显示。由于<code>UITableViewCell</code>在显示出来之前是不知道宽度的，但是为了获取正确的宽度我们可以在<code>- (void)layoutSubviews</code>方法里面设置：</p>

<pre><code>- (void)layoutSubviews
{
    _contentLabel.preferredMaxLayoutWidth = CGRectGetWidth(self.contentView.frame) - 128 - 10 - 6;//后面的数字是前后以及图片的宽度
    [super layoutSubviews];//这个调用是为了改变后更新布局
}
</code></pre>

<p>这样我们设置好cell以及Model以后，其他的方法都和普通的使用一样，唯一不一样的就是计算cell高度的<code>UITableView</code>代理方法<code>heightForRowAtIndexPath</code>，它的实现如下：</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static CodeLayoutCell *singleCell = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
    //这里持有一个cell是为了下面自动计算cell高度的需要
        singleCell = [tableView dequeueReusableCellWithIdentifier:kCellIdentifier];
    });
    //取出Model，如果有缓存的高度值就不计算了
    CellModel *model = _dataSourceArray[indexPath.row];
    if (model.cacheHeight != 0) {
        return model.cacheHeight;
    }
    [singleCell layoutIfNeeded];//强制布局，得到contentView的宽度
    [singleCell setNewCellModel:model];
    //由系统根据我们设定的Layout规则来计算cell显示的Size
    CGSize size = [singleCell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
    model.cacheHeight = size.height + 1;//cell和cell.contentView的高度相差1

    return model.cacheHeight;
}  
</code></pre>

<p>运行的效果如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxuuzclg208u0d51kx.gif" alt="image" /></p>

<p>当图片的高度大于三个<code>UIlabel</code>加上各自上下的间隔的高度时，由于我们设置了三个Label的<code>内容吸附</code>最高的优先级，所以为了满足它们的高度，图片的内容就进行了压缩，如下:</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxtyebuj208w0dbdhk.jpg" alt="image" /></p>

<p>第二个cell的图片被压缩了，如何才能保证它不被压缩呢？留给读到这里的人自己实现吧！😄</p>

<p>暂时先写到这里吧，由于刚接触这两个属性，难免会有遗误之处，请大家多多谅解！</p>

<p>完整的Demo，请戳<a href="https://github.com/liangwei518/AutolayoutDemo1">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Layout使用小技巧]]></title>
    <link href="http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao/"/>
    <updated>2015-11-22T22:58:51+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<p>目前由于Apple自己的Auto Layout写法比较啰嗦，所以出现了许多对原生语句进行封装的第三方开发库，这其中<code>Masonry</code>广受开发者的喜爱，所以以下都以<code>Masonry</code>来做演示说明，但对于Apple原生的写法也同样适用。</p>

<h3>1、图片+文字居中显示</h3>

<p>很多时候我们都会遇到这样的需求：一张图片旁边接上一段文字，然后让他们相对于父视图居中显示，以前我的做法是先知道图片的尺寸，然后来计算他们相对于父视图中心的偏移量，再进行布局。需求的样式大致如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4nyp8qbj208w014a9v.jpg" alt="大致效果" /></p>

<p>但是这样的缺点是每次都需要去据算距离中心的偏移量，很麻烦，对于这种情况其实可以添加一个辅助视图，让这个辅助视图的左边等于图片的左边，右边和文字的右边对齐，然后这个辅助视图相对于父视图居中显示就行。</p>

<!--more-->


<pre><code>- (void)layoutImageAndText {
UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"av_colum"]];
[self.view addSubview:imageView];
[imageView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(@10);
    make.left.greaterThanOrEqualTo(self.view);
}];

UILabel *label = [UILabel new];
label.text = @"梁朝伟";
label.font = [UIFont systemFontOfSize:17];
label.textAlignment = NSTextAlignmentLeft;
label.backgroundColor = [UIColor clearColor];
[self.view addSubview:label];
[label mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView.mas_right).offset(5);
    make.centerY.equalTo(imageView);
}];

UIView *limitView = [UIView new];
[self.view addSubview:limitView];
[limitView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView);//和图片左边对齐
    make.right.equalTo(label);//和文字右边对齐
    make.centerX.equalTo(self.view);//指定limitView居中显示
}];
}
</code></pre>

<h3>2、处理复合型布局</h3>

<p>直接上图说明需求，页面上有四个可见的视图：红、绿、蓝三个<code>UIView</code>，最下面是一个<code>UIButton</code>,想要达到的效果是点击button触发事件将中间的绿色视图隐藏，下面的蓝色视图和button移动到红色视图下，我们想要的效果如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4nz1i8hg208p0bjmxi.gif" alt="需要的效果" /></p>

<p>如果只是将中间的绿色的视图hidden掉，是达不到这样的效果的：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eya4nza0mfj208w0a8748.jpg" alt="影藏中间的绿色视图" /></p>

<p>要达到这样的效果可以利用<code>MASConstraint</code>的<code>deactivate</code>和<code>activate</code>方法，他们的作用是让一个constraint<strong>不生效</strong>和<strong>生效</strong>，<code>Masonry</code>的每个Constraint都会产生一个<code>MASConstraint</code>，所以我们可以保存一些需要改变的constraint，在需要的时候使用这两个方法。</p>

<pre><code>//.h
@interface ViewController ()

@property (nonatomic, strong) UIView *greenView;
@property (nonatomic, strong) MASConstraint *gHeightConstraint;//保存关键的constraint

@end
//.m
@implementation ViewController

- (void)testComplexLayout {
NSNumber *viewHeight = @80;
UIView *redView = [UIView new];
redView.backgroundColor = [UIColor redColor];
[self.view addSubview:redView];
[redView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.left.right.equalTo(self.view);
    make.height.equalTo(viewHeight);
}];

_greenView = [UIView new];
[self.view addSubview:_greenView];
[_greenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.right.equalTo(redView);
    make.top.equalTo(redView.mas_bottom);
    self.gHeightConstraint = make.height.equalTo(@0).priorityHigh();//设为高优先级，首先满足它的需求
}];
[self.gHeightConstraint deactivate];//最开始让它不生效，就是高为0的限制暂不生效
_greenView.clipsToBounds = YES;//不显示超过bounds本身的部分，因为在它里面加了subView
//subGreenView是真实的显示绿色部分，它添加在greenView上
UIView *subGreenView = [UIView new];
subGreenView.backgroundColor = [UIColor greenColor];
[_greenView addSubview:subGreenView];
[subGreenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.edges.equalTo(self.greenView).priorityLow();
    make.height.equalTo(viewHeight);
}];

UIView *blueView = [UIView new];
blueView.backgroundColor = [UIColor blueColor];
[self.view addSubview:blueView];
[blueView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.height.left.right.equalTo(redView);
    make.top.equalTo(self.greenView.mas_bottom);
}];

UIButton *hiddenButton = [UIButton buttonWithType:UIButtonTypeCustom];
[hiddenButton setTitle:@"影藏中间的View" forState:UIControlStateNormal];
[hiddenButton addTarget:self action:@selector(hiddenAction:) forControlEvents:UIControlEventTouchUpInside];
[hiddenButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
[self.view addSubview:hiddenButton];
[hiddenButton mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.equalTo(self.view);
    make.top.equalTo(blueView.mas_bottom).offset(40);
}];
}

static bool isActive = NO;
- (void)hiddenAction:(id)sender {
if (isActive) {
    [_gHeightConstraint deactivate];
} else {
    [_gHeightConstraint activate];
}
//动画展示
[UIView animateWithDuration:.25 animations:^{
    [self.view layoutIfNeeded];
}];

isActive = !isActive;
}
</code></pre>

<h3>3、Preview的使用</h3>

<p>这段时间在学习storyBoard相关的一些知识，RW上的两篇文章：<a href="http://www.raywenderlich.com/50308/storyboards-tutorial-in-ios-7-part-1">Part1</a>和<a href="http://www.raywenderlich.com/50310/storyboards-tutorial-in-ios-7-part-2">Part2</a>非常适合初学者学习，已经有人翻译成了中文<a href="http://www.cocoachina.com/industry/20131213/7537.html">Part1</a>，<a href="http://blog.sina.com.cn/s/blog_5c5c87d80101dzyh.html">Part2</a>。</p>

<p><code>Xcode</code>提供了一个很重要的功能<code>Preview</code>。当我们在<code>Storyboard</code>上使用<code>Auto Layout</code>上进行布局以后，由于目前的画布<code>canvas</code>已经没有尺寸的概念，我们布局完成后需要在3.5、4.0、4.7、5.5英寸的设备上测试，如果支持旋转或者支持iPad，一个效果我们会build多次在不同的设备上查看效果。非常的麻烦，但是有了<code>Preview</code>后一切都变得简单起来。
使用<code>Preview</code>的步奏如下：</p>

<p>1、选中<code>Main.storyboard</code>,如下图所示，选取的时候按下<code>option+shift</code>按键。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eya4nzk6ywj20b204p74o.jpg" alt="选择storyboard" /></p>

<p>2、选取<code>Preview</code>后会出来如下的界面，选择界面右边的<code>+</code>号，按<code>回车</code>。</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eya4nzzeuxj20bc05daae.jpg" alt="image" /></p>

<p>3、通过步骤<code>2</code>后，会出现以下的界面：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4o08srqj20f70gh0t6.jpg" height="520" width="500" alt="Preview界面" /></p>

<p>关键的几个地方我都用红方框圈了起来，左下角的<code>+</code>能模拟不同的设备，中间的红框部位可以模拟设备的旋转，
右下角的<code>English</code>部位可以模拟布局中的文学信息双倍后的布局表现，这几个功能都非常的方便。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App中拨打电话一点小总结]]></title>
    <link href="http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-%5B%3F%5D-dian-xiao-zong-jie/"/>
    <updated>2015-08-23T12:27:08+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-[?]-dian-xiao-zong-jie</id>
    <content type="html"><![CDATA[<h3>App内发起电话拨打的一点小技巧</h3>

<h4>一、拨打电话</h4>

<p>在App内发起电话拨打主要有两种方式：</p>

<p>1、利用这种方式发起的电话拨打，通话结束后不会直接返回App内，而是停留在通信录里面：</p>

<pre><code> NSString *str = [[NSString alloc] initWithFormat:@"tel:%@",@"131xxxx1909"];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:str]];
</code></pre>

<!--more-->


<p>2、利用<code>UIWebView</code>实现电话拨打，会弹出拨打提示，并且拨打完成后会返回App内：</p>

<pre><code>NSString *phone = @"131****1909";
NSString *cleanedString =[[phone componentsSeparatedByCharactersInSet:[[NSCharacterSet characterSetWithCharactersInString:@"0123456789-+()"] invertedSet]] componentsJoinedByString:@""];
NSString *escapedPhoneNumber = [cleanedString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSURL *telURL = [NSURL URLWithString:[NSString stringWithFormat:@"tel://%@",escapedPhoneNumber]];
UIWebView *mCallWebview = [[UIWebView alloc] init] ;

[self.view addSubview:mCallWebview];
[mCallWebview loadRequest:[NSURLRequest requestWithURL:telURL]];
</code></pre>

<h4>二、检测通话时间</h4>

<p>利用<code>CTCallCenter</code>我们可以检测在使用App期间拨打电话出去以及电话打入的时机，以及通话结束的时机。实现如下：</p>

<pre><code> #import &lt;CoreTelephony/CTCallCenter.h&gt;
 #import &lt;CoreTelephony/CTCall.h&gt;

 @interface AppDelegate : UIResponder&lt;UIApplicationDelegate&gt;
 @property (nonatomic, strong) CTCallCenter *callCenter;
 @end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.callCenter = [[CTCallCenter alloc] init];
  [self handleCall];
  return YES;
}

-(void)handleCall
{
   self.callCenter.callEventHandler = ^(CTCall *call) {
    if ([call.callState isEqualToString: CTCallStateConnected])
    {
        NSLog(@"接通电话");
    }
    else if ([call.callState isEqualToString: CTCallStateDialing])
    {
        NSLog(@"发起呼叫");
    }
    else if ([call.callState isEqualToString: CTCallStateDisconnected])
    {
        NSLog(@"结束电话");
    }
    else if ([call.callState isEqualToString: CTCallStateIncoming])
    {
        NSLog(@"打入电话");
    }
   };
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode控制台打印CGRect]]></title>
    <link href="http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect/"/>
    <updated>2015-06-15T21:15:58+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect</id>
    <content type="html"><![CDATA[<p>在用Xcode调试开发的时候，我们经常需要在控制台打印某个视图的frame，以前的时候相当麻烦，但是从Xcode6.3以后，打印frame变得很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Before
</span><span class='line'>(lldb) p (CGRect) [self frame]
</span><span class='line'>(CGRect) $0 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span><span class='line'> 
</span><span class='line'>// After
</span><span class='line'>(lldb) expr @import UIKit
</span><span class='line'>(lldb) p self.frame
</span><span class='line'>(CGRect) $1 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking2.0使用心得]]></title>
    <link href="http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de/"/>
    <updated>2015-05-13T13:56:23+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de</id>
    <content type="html"><![CDATA[<p>这段时间要将公司项目中的网络引擎由<a href="http://allseeing-i.com/ASIHTTPRequest/">ASIHTTPRequest</a>替换为<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>,替换的过程比较曲折，在此记录下自己替换过程中得心得：</p>

<h3>1、建立数据请求中介者</h3>

<p>建立<code>中介者</code>是指项目中的数据请求都通过它去实现，而不是每一个数据请求都直接与<code>AFNetworking</code>打交道，这样做的好处是：</p>

<ul>
<li>将网络请求与第三方库依赖隔离开来，方便以后对第三方库的替换。</li>
<li>方便处理网络请求的公共逻辑。</li>
</ul>


<!--more-->


<h3>2、使用completionQueue</h3>

<p>默认情况下<code>AFURLConnectionOperation</code>或者<code>AFHTTPRequestOperation</code>请求结束以后会在主线程将结果传递回来，如果你要将请求的结果做一些耗时的复杂的处理，就会<em>block</em>住主线程，所以这种情况下你就需要对请求的Operation传递<code>completionQueue</code>参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperation *request = [[AFHTTPRequestOperation alloc] initWithRequest:urlrequest];
</span><span class='line'>
</span><span class='line'>request.responseSerializer = [AFJSONResponseSerializer serializer];
</span><span class='line'>//设置回调的queue，默认是在mainQueue执行block回调
</span><span class='line'>request.completionQueue = your_request_operation_completion_queue();
</span><span class='line'>[request setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>         //设置了'completionQueue'后，就可以在这里处理复杂的逻辑
</span><span class='line'>         //不用担心block住了主线程
</span><span class='line'>    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>
</span><span class='line'> }];
</span><span class='line'> [request start];
</span></code></pre></td></tr></table></div></figure>


<h3>3、如何知道AFHTTPRequestOperationManager执行完成</h3>

<p>开始以为直接设置<code>AFHTTPRequestOperationManager</code>的<em>completionGroup</em>，然后利用<code>dispatch_group_notify</code>来获取operationQueue执行结束的通知，最后才发现，这样根本不行，看了源码才知道：<code>AFHTTPRequestOperationManager</code>直接将<em>completionGroup</em>赋值给了他的每一个<em>operation</em>，在<em>operation</em>的completionBlock里面利用<em>completionGroup</em>，来确保在operation的处理完成后，将completionBlock置为nil，防止循环引用。</p>

<p>虽然说这样不能知道<code>AFHTTPRequestOperationManager</code>什么时候执行完成，但是生活还得继续下去啊！在<code>AFURLConnectionOperation</code>中有一个方法叫：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSArray *)batchOfRequestOperations:(NSArray *)operations
</span><span class='line'>                        progressBlock:(void (^)(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations))progressBlock
</span><span class='line'>                      completionBlock:(void (^)(NSArray *operations))completionBlock;
</span></code></pre></td></tr></table></div></figure>


<p>这个方法就是能够发一组请求，跟<code>AFHTTPRequestOperationManager</code>比起来的缺点就是没法设置并发数，但是它却能实现检测一组请求什么时候结束，能检测完成了多少请求，它是怎么做到的呢？</p>

<p>原来他也是利用<strong>dispatch_group_async</strong>和<strong>dispatch_group_notify</strong></p>

<p>一般的我们要把一个任务加入一个group里是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    block();
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这个写法等价于</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(queue, ^{
</span><span class='line'>    dispatch_group_enter(group);
</span><span class='line'>    block()
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>如果要把一个异步任务加入group，这样就行不通了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    [self performBlock:^(){
</span><span class='line'>        block();
</span><span class='line'>    }];
</span><span class='line'>    //未执行到block() group任务就已经完成了
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这是就需要用到<code>batchOfRequestOperations</code>里的实现了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_enter(group);
</span><span class='line'>[self performBlock:^(){
</span><span class='line'>    block();
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>}];
</span></code></pre></td></tr></table></div></figure>


<p>其实这个和引用计数差不多，<em>dispatch_group_enter</em>时引用计数+1，<em>dispatch_group_leave</em>时引用计数-1，引用计数为0时执行<em>dispatch_group_notify</em>的内容。具体过程大致如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperationManager *downloadManager = [AFHTTPRequestOperationManager manager];
</span><span class='line'>    //设置最大并发数
</span><span class='line'>    [downloadManager.operationQueue setMaxConcurrentOperationCount:([NSProcessInfo processInfo].processorCount) * 2];
</span><span class='line'>    //创建一个group
</span><span class='line'>    __block dispatch_group_t group = dispatch_group_create();
</span><span class='line'>    for (NSURL *url in urlArray) {
</span><span class='line'>        NSURLRequest *requestUrl = [NSURLRequest requestWithURL:url];
</span><span class='line'>        AFHTTPRequestOperation *requestOperation = [[AFHTTPRequestOperation alloc] initWithRequest:requestUrl];
</span><span class='line'>        [requestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        }];
</span><span class='line'>        //将请求加入队列中
</span><span class='line'>        [downloadManager.operationQueue addOperation:requestOperation];
</span><span class='line'>        dispatch_group_enter(group);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
</span><span class='line'>        //全部请求完成
</span><span class='line'>        
</span><span class='line'>    });  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>4、实现断点续传</h3>

<p><code>AFNetworking</code>虽然支持文件下载的暂停和继续，但是当缓存清空重新启动时，它并没有记录下下载的状态，无法续传，但是可以通过<a href="http://https://github.com/steipete/AFDownloadRequestOperation">AFDownloadRequestOperation</a>来简单的实现，其实过程也不是很复杂，大致如下，感兴趣的朋友可以阅读<code>AFDownloadRequestOperation</code>是实现部分：</p>

<p>1、设置<code>AFHTTPRequestOperation</code>的请求<code>NSMutableURLRequest</code><em>HTTPHeader</em>的<strong>Range</strong>字段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableURLRequest *mutableURLRequest = [self.request mutableCopy];
</span><span class='line'>//offset是指断点续传文件已经下载的大小
</span><span class='line'>[mutableURLRequest setValue:[NSString stringWithFormat:@"bytes=%llu-", offset] forHTTPHeaderField:@"Range"];</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>2、设置<code>AFHTTPRequestOperation</code>的<em>outputStream</em>属性。</p>

<pre><code class="` "> //downloadPath是指文件下载存放的路径
downloadOperation.outputStream = [NSOutputStream outputStreamToFileAtPath:downloadPath append:YES];
</code></pre>

<h3>结尾</h3>

<p>对于<code>ASIHTTPRequest</code>和<code>AFNetworking</code>的比较网上有很多很好的文章，一搜一大把，对于普通的使用来说感觉区别不大，请求速度什么的也没什么感觉，以上若有错误，还望大家多多
指正😃。</p>
]]></content>
  </entry>
  
</feed>
