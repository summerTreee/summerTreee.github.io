<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[夏树正茂]]></title>
  <link href="http://summertreee.github.io/atom.xml" rel="self"/>
  <link href="http://summertreee.github.io/"/>
  <updated>2015-12-13T17:18:49+08:00</updated>
  <id>http://summertreee.github.io/</id>
  <author>
    <name><![CDATA[梁炜V]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ContentCompressionResistance和ContentHugging详解]]></title>
    <link href="http://summertreee.github.io/blog/2015/12/13/contentcompressionresistancehe-contenthuggingxiang-jie/"/>
    <updated>2015-12-13T17:07:53+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/12/13/contentcompressionresistancehe-contenthuggingxiang-jie</id>
    <content type="html"><![CDATA[<p>在Auto Layout的使用中，有两个很重要的布局概念：<code>Content Compression Resistance</code>和<code>Content Hugging</code>，从字面的翻译我们大概可以分别翻译为：<code>压缩阻力</code>以及<code>内容吸附</code>。但是光从字面意思来理解很难知道它们如何使用以及确切的设计意图。我最开始也是很迷糊而且在使用Auto Layout的过程中也没有使用过它们，直到最近稍稍研究了一下，发现它们的作用甚是巨大，所以我为了加深记忆，把我最近学习到的关于它们的概念在此稍作整理加以记录。</p>

<blockquote><p>注：以下为了表述方便，将<code>Content Compression Resistance</code>记为<code>压缩阻力</code>，将<code>Content Hugging</code>记为<code>内容吸附</code>。</p></blockquote>

<!--more-->


<h4>Content Compression Resistance</h4>

<p><strong>压缩阻力</strong>属性为了记忆更加形象我们可以把它理解为<strong>离我远点，不许挤到我</strong>，它的优先级（Priority）越高，它的这种抗挤压的能力也就越强，我们可以通过代码在控件的水平或垂直方向上分别设置1（最低优先级）到1000（最高优先级）之间的优先级，默认是750，例如我们可以为一个<strong>UILabel</strong>控件设置一个它在水平方向上优先级为<em>500</em>的压缩阻力：</p>

<pre><code>[label setContentCompressionResistancePriority:500 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>用图来表示，我们可以大致表示如下，视图的压缩阻力就好似它自身往外的张力，优先级越高，视图自己维持自身显示完整性的能力就越强：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwdofkoj208r08r74s.jpg" alt="image" /></p>

<h4>Content Hugging</h4>

<p><strong>内容吸附</strong>属性为了记忆方便我们可以把它理解为<strong>抱紧（Hug）</strong>，视图的大小不会随着superView的变大而扩大，而是只维持能完全显示自己内容的大小，它的这种优先级越高，吸附的能力就越强，和<strong>压缩阻力</strong>一样，<strong>内容吸附</strong>的优先级也可以通过代码来设置，只是它的默认优先级是<em>250</em>：</p>

<pre><code>[label setContentHuggingPriority:251 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>用图来表示，我们可以大致表示如下，视图的内容吸附就好似视图自己有向内抱紧自己的力量一样，优先级越高，它的这种能力就越强：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwdllbej208n08mq3e.jpg" alt="image" /></p>

<p>以上讲了<code>内容吸附</code>和<code>压缩阻力</code>的基本概念，但是这两个属性是建立在<code>Intrinsic Content Size</code>这一概念上的，我们暂且把它翻译为<code>固有尺寸</code>，所有基于UIView的视图都有<code>intrinsicContentSize</code>这个属性，下面我们就介绍一下什么是<code>固有尺寸</code>。</p>

<h4>Intrinsic Content Size</h4>

<p>每个视图都有压缩阻力优先级（Content Compression Resistance Priority）和内容吸附优先级（Content Hugging Priority），但只有视图明确了它的<code>固有尺寸</code>后，这两种优先级才会起作用。我们首先来看一下官方的解释：</p>

<blockquote><p> Custom views typically have content that they display of which the layout system is unaware. Overriding this method allows a custom view to communicate to the layout system what size it would like to be based on its content. This intrinsic size must be independent of the content frame, because there’s no way to dynamically communicate a changed width to the layout system based on a changed height, for example.
If a custom view has no intrinsic size for a given dimension, it can return UIViewNoIntrinsicMetric for that dimension.</p></blockquote>

<p>大致的意思就是我们自定义的视图在默认情况下，它的固有尺寸是返回(UIViewNoIntrinsicMetric，UIViewNoIntrinsicMetric)，也就是(-1,-1)，只有我们根据自定义视图本身的Content来重写该方法，我们自定义的视图才能明确的知道他在显示系统中该展示的大小。<br/>
UILabel和UIButton等这些控件，系统默认是根据他们的内容实现了固有尺寸，所以我们在使用的时候只需要确定origin或者Center它们就能正确的显示。<br/>
由此可见，固有尺寸是为了实现视图的<strong>大小自适应</strong>而存在的。</p>

<p>以下我来自定义一个视图，来测试一下<code>固有尺寸</code>是否有效，由于项目中大家都是用<a href="http://https://github.com/SnapKit/Masonry">Masonry</a>来处理Auto Layout，所以一下的例子都使用<code>Masonry</code>来布局。</p>

<h5>重写Intrinsic Content Size</h5>

<p>我们新建一个继承自<code>UIView</code>的自定义视图<code>IntrinsicView</code>，在一个ViewController中添加一个我们自定义的视图,设置它水平居中，顶部和父视图对齐。</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *intrinsicView = [IntrinsicView new];
    intrinsicView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:intrinsicView];
    [intrinsicView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.mas_equalTo(self.view);
    make.top.mas_equalTo(self.mas_topLayoutGuideBottom);
}];
}
</code></pre>

<p>运行后发现什么也没显示，因为我们没有设置它的宽高，而它默认的固有尺寸是（-1 ，-1）。我们去重写<code>IntrinsicView</code>的<code>- (CGSize)intrinsicContentSize</code>方法：</p>

<pre><code>@implementation IntrinsicView

- (CGSize)intrinsicContentSize
{
    return CGSizeMake(150, 66);
}

@end  
</code></pre>

<p>运行后显示如下：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw65tsuj208y0ddaa5.jpg" alt="image" /></p>

<p>显示出来，它的大小刚好是我们定义的<code>intrinsicContentSize</code>大小。上面介绍了内容吸附和压缩阻力以及固有尺寸的基本概念，下面来测试一下它们应该如何使用。</p>

<h6>1、测试内容吸附优先级</h6>

<p>为了测试内容吸附优先级我们在页面上添加两个<code>IntrinsicView</code>，分别是<code>topView</code>和<code>bottomView</code>，设置他们都水平居中，然后分别和页面的顶部和底部对齐：</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *topView = [IntrinsicView new];
    topView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:topView];
    [topView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(self.mas_topLayoutGuideBottom);//和导航栏底部对齐
    }];

    IntrinsicView *bottomView = [IntrinsicView new];
    bottomView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:bottomView];
    [bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.bottom.mas_equalTo(self.mas_bottomLayoutGuideBottom);//和页面底部对齐
    }];
}  
</code></pre>

<p>运行后展示如下：<br/>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw6ih8aj208w0ddglq.jpg" alt="image" /></p>

<p>下面我们设置<strong>topView</strong>和<strong>bottomView</strong>之间的间距为<em>40</em>，也就是<code>topView.bottom + 40 = bottomView.top</code>。</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *topView = [IntrinsicView new];
    topView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:topView];
    [topView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(self.mas_topLayoutGuideBottom);//和导航栏底部对齐
}];

    IntrinsicView *bottomView = [IntrinsicView new];
    bottomView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:bottomView];
    [bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(topView.mas_bottom).offset(40);
        make.bottom.mas_equalTo(self.mas_bottomLayoutGuideBottom);//和页面底部对齐
 }];
}  
</code></pre>

<p>运行后展示效果如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw6xva7j208v0dcmxb.jpg" alt="image" /></p>

<p>我们发现<code>topView</code>被拉伸了，如果我们不想<code>topView</code>被拉伸，就可以利用<code>内容吸附</code>的特性，因为我们定义了<code>IntrinsicView</code>的固有尺寸，设置<code>topView</code>的<code>内容吸附</code>优先级比<code>bottomView</code>的优先级高，我们上面介绍了<code>内容吸附</code>的默认优先级是<em>250</em>，我们把<code>topView</code>的<code>内容吸附</code>优先级设置为<em>251</em>，在原来<code>layoutSubIntrinsicView</code>函数的最后添加如下语句：</p>

<pre><code>[topView setContentHuggingPriority:251 forAxis:UILayoutConstraintAxisVertical];  
</code></pre>

<p>运行后如下所示，达到了我们想要的效果：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw7a0tqj208w0ddt8v.jpg" alt="image" /></p>

<blockquote><p>251是我随意定的比250大的值，可以是大于250小于1000的任何值。</p></blockquote>

<h6>2、测试压缩阻力优先级</h6>

<p>我们通常会遇到如下图所示的需求：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw7yw9hj20e007cdgi.jpg" alt="image" /></p>

<p>在某个页面上水平放置两个UILabel，<code>leftLabel</code>的左边和父视图的间距固定，<code>rightLabel</code>的右边和父视图的右边有一个小于等于某个间隔的约束，<code>leftLabel</code>和<code>rightLabel</code>之间有一个固定间距，它们的宽度根据他们显示的内容自适应，关键代码如下:</p>

<pre><code>[leftLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    //左边和父视图间隔固定为10
    make.left.mas_equalTo(self.view).offset(10);
    make.top.mas_equalTo(80);//随意设定的值
}];

[rightLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.mas_equalTo(leftLabel);
    //和leftLabel的右边间距固定为20
    make.left.mas_equalTo(leftLabel.mas_right).offset(20);
    //这里注意是‘lessThanOrEqualTo’，也就是‘rightLabel’的右边界
    //和父视图的间距至少为10，内容少时，间距自动调大
    make.right.mas_lessThanOrEqualTo(self.view).offset(-10);
}];  
</code></pre>

<p>在他们的显示内容宽度不超过父视图宽度时，两个label的内容都能正常的完全显示，但是当它们需要显示的内容长度总和超过父视图的宽度时，就会显示如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwckaf2j208x0ddglw.jpg" alt="image" /></p>

<p>一个label被压缩了， <code>rightLabel</code>显示不完全，如果在这种情况下，我们想<code>leftLabel</code>被压缩，而<code>rightLabel</code>尽量完全显示，由于UILabel这类控件，系统自己已经根据它们显示的实际内容实现了<code>固有尺寸</code>的方法，我们可以利用<code>压缩阻力</code>的特性，将<code>rightLabel</code>的<code>压缩阻力</code>优先级设置得比<code>leftLabel</code>高，上面介绍了<code>压缩阻力</code>的默认优先级是<em>750</em>，我们把<code>rightLabel</code>的优先级设置为<em>751</em>，在上面代码的最下面添加如下代码：</p>

<pre><code>[rightLabel setContentCompressionResistancePriority:751 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>运行后显示如下，达到了我们预期的效果：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwd0cbqj208x0dddg4.jpg" alt="image" /></p>

<h6>3、在自动计算UITableViewCell高度中的使用</h6>

<p>对于变高cell的处理，以前我们都是在<code>heightForRowAtIndexPath</code>方法里面，拼凑要展示的变高cell的高度，当我们改变cell中两个控件在垂直方向的布局，或者再添加一个控件时，还要去修改计算cell高度的方法来适应新的变化，非常不方便。但是有了自动布局后，利用好<code>压缩阻力</code>和<code>内容吸附</code>的优先级，可以很精确很简单的由系统来计算出变高cell的高度。</p>

<p>假定我们有如下需求：<br/>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxt9hqfj20e1097dgw.jpg" alt="image" /></p>

<p>我们看到，这个变高cell里面高度不定的是中间的<code>ContentLabel</code>，它会根据内容长度来折行显示，<strong>UILabel</strong>要折行显示我们需要设置它的<code>preferredMaxLayoutWidth</code>和<code>numberOfLines</code>两个属性的值。</p>

<p>首先假定<code>Model</code>的定义如下：</p>

<pre><code>@interface CellModel : NSObject

@property (nonatomic, copy) NSString *name;
@property (nonatomic, copy) NSString *company;
@property (nonatomic, copy) NSString *content;
@property (nonatomic, assign) CGFloat cacheHeight;//缓存当前Model显示的cell高度

@end
</code></pre>

<p>自定义的<code>UITableViewCell</code>的关键代码如下：</p>

<pre><code>//图片距左边距离为10，上下居中
    [_cellImageView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.contentView).offset(10);
        make.centerY.mas_equalTo(self.contentView);
        make.top.mas_greaterThanOrEqualTo(self.contentView).offset(10);
        make.bottom.mas_lessThanOrEqualTo(self.contentView).offset(-10);
    }];
    //标题Label,一行显示
    [_nameLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.cellImageView.mas_right).offset(6);
        make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
        make.top.mas_equalTo(self.contentView).offset(10);
    }];
    //内容label,多行显示
    _contentLabel.numberOfLines = 0;
    [self.contentView addSubview:_contentLabel];
    [_contentLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.nameLabel);
        make.top.mas_equalTo(self.nameLabel.mas_bottom).offset(6);
    }];
    //标题Label,一行显示
    [_companyLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.contentLabel);
        make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
        make.top.mas_equalTo(self.contentLabel.mas_bottom).offset(6);
        make.bottom.mas_equalTo(self.contentView).offset(-10);//设定了这个自动计算cell高度时才知道具体cell的高度
    }];

    [_nameLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
    [_companyLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
    [_contentLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];  
</code></pre>

<p>上面的代码中设置了几个<code>UILabel</code>的<code>内容吸附</code>优先级为最高，这样它们就不会随着cell高度的变化而拉伸高度。上面设置了<code>contentLabel</code>的<code>numberOfLines = 0</code>，还需要设置<code>preferredMaxLayoutWidth</code>才能正确换行显示。由于<code>UITableViewCell</code>在显示出来之前是不知道宽度的，但是为了获取正确的宽度我们可以在<code>- (void)layoutSubviews</code>方法里面设置：</p>

<pre><code>- (void)layoutSubviews
{
    _contentLabel.preferredMaxLayoutWidth = CGRectGetWidth(self.contentView.frame) - 128 - 10 - 6;//后面的数字是前后以及图片的宽度
    [super layoutSubviews];//这个调用是为了改变后更新布局
}
</code></pre>

<p>这样我们设置好cell以及Model以后，其他的方法都和普通的使用一样，唯一不一样的就是计算cell高度的<code>UITableView</code>代理方法<code>heightForRowAtIndexPath</code>，它的实现如下：</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static CodeLayoutCell *singleCell = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
    //这里持有一个cell是为了下面自动计算cell高度的需要
        singleCell = [tableView dequeueReusableCellWithIdentifier:kCellIdentifier];
    });
    //取出Model，如果有缓存的高度值就不计算了
    CellModel *model = _dataSourceArray[indexPath.row];
    if (model.cacheHeight != 0) {
        return model.cacheHeight;
    }
    [singleCell layoutIfNeeded];//强制布局，得到contentView的宽度
    [singleCell setNewCellModel:model];
    //由系统根据我们设定的Layout规则来计算cell显示的Size
    CGSize size = [singleCell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
    model.cacheHeight = size.height + 1;//cell和cell.contentView的高度相差1

    return model.cacheHeight;
}  
</code></pre>

<p>运行的效果如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxuuzclg208u0d51kx.gif" alt="image" /></p>

<p>当图片的高度大于三个<code>UIlabel</code>加上各自上下的间隔的高度时，由于我们设置了三个Label的<code>内容吸附</code>最高的优先级，所以为了满足它们的高度，图片的内容就进行了压缩，如下:</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxtyebuj208w0dbdhk.jpg" alt="image" /></p>

<p>第二个cell的图片被压缩了，如何才能保证它不被压缩呢？留给读到这里的人自己实现吧！😄</p>

<p>暂时先写到这里吧，由于刚接触这两个属性，难免会有遗误之处，请大家多多谅解！</p>

<p>完整的Demo，请戳<a href="https://github.com/liangwei518/AutolayoutDemo1">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Layout使用小技巧]]></title>
    <link href="http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao/"/>
    <updated>2015-11-22T22:58:51+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<p>目前由于Apple自己的Auto Layout写法比较啰嗦，所以出现了许多对原生语句进行封装的第三方开发库，这其中<code>Masonry</code>广受开发者的喜爱，所以以下都以<code>Masonry</code>来做演示说明，但对于Apple原生的写法也同样适用。</p>

<h3>1、图片+文字居中显示</h3>

<p>很多时候我们都会遇到这样的需求：一张图片旁边接上一段文字，然后让他们相对于父视图居中显示，以前我的做法是先知道图片的尺寸，然后来计算他们相对于父视图中心的偏移量，再进行布局。需求的样式大致如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4nyp8qbj208w014a9v.jpg" alt="大致效果" /></p>

<p>但是这样的缺点是每次都需要去据算距离中心的偏移量，很麻烦，对于这种情况其实可以添加一个辅助视图，让这个辅助视图的左边等于图片的左边，右边和文字的右边对齐，然后这个辅助视图相对于父视图居中显示就行。</p>

<!--more-->


<pre><code>- (void)layoutImageAndText {
UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"av_colum"]];
[self.view addSubview:imageView];
[imageView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(@10);
    make.left.greaterThanOrEqualTo(self.view);
}];

UILabel *label = [UILabel new];
label.text = @"梁朝伟";
label.font = [UIFont systemFontOfSize:17];
label.textAlignment = NSTextAlignmentLeft;
label.backgroundColor = [UIColor clearColor];
[self.view addSubview:label];
[label mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView.mas_right).offset(5);
    make.centerY.equalTo(imageView);
}];

UIView *limitView = [UIView new];
[self.view addSubview:limitView];
[limitView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView);//和图片左边对齐
    make.right.equalTo(label);//和文字右边对齐
    make.centerX.equalTo(self.view);//指定limitView居中显示
}];
}
</code></pre>

<h3>2、处理复合型布局</h3>

<p>直接上图说明需求，页面上有四个可见的视图：红、绿、蓝三个<code>UIView</code>，最下面是一个<code>UIButton</code>,想要达到的效果是点击button触发事件将中间的绿色视图隐藏，下面的蓝色视图和button移动到红色视图下，我们想要的效果如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4nz1i8hg208p0bjmxi.gif" alt="需要的效果" /></p>

<p>如果只是将中间的绿色的视图hidden掉，是达不到这样的效果的：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eya4nza0mfj208w0a8748.jpg" alt="影藏中间的绿色视图" /></p>

<p>要达到这样的效果可以利用<code>MASConstraint</code>的<code>deactivate</code>和<code>activate</code>方法，他们的作用是让一个constraint<strong>不生效</strong>和<strong>生效</strong>，<code>Masonry</code>的每个Constraint都会产生一个<code>MASConstraint</code>，所以我们可以保存一些需要改变的constraint，在需要的时候使用这两个方法。</p>

<pre><code>//.h
@interface ViewController ()

@property (nonatomic, strong) UIView *greenView;
@property (nonatomic, strong) MASConstraint *gHeightConstraint;//保存关键的constraint

@end
//.m
@implementation ViewController

- (void)testComplexLayout {
NSNumber *viewHeight = @80;
UIView *redView = [UIView new];
redView.backgroundColor = [UIColor redColor];
[self.view addSubview:redView];
[redView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.left.right.equalTo(self.view);
    make.height.equalTo(viewHeight);
}];

_greenView = [UIView new];
[self.view addSubview:_greenView];
[_greenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.right.equalTo(redView);
    make.top.equalTo(redView.mas_bottom);
    self.gHeightConstraint = make.height.equalTo(@0).priorityHigh();//设为高优先级，首先满足它的需求
}];
[self.gHeightConstraint deactivate];//最开始让它不生效，就是高为0的限制暂不生效
_greenView.clipsToBounds = YES;//不显示超过bounds本身的部分，因为在它里面加了subView
//subGreenView是真实的显示绿色部分，它添加在greenView上
UIView *subGreenView = [UIView new];
subGreenView.backgroundColor = [UIColor greenColor];
[_greenView addSubview:subGreenView];
[subGreenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.edges.equalTo(self.greenView).priorityLow();
    make.height.equalTo(viewHeight);
}];

UIView *blueView = [UIView new];
blueView.backgroundColor = [UIColor blueColor];
[self.view addSubview:blueView];
[blueView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.height.left.right.equalTo(redView);
    make.top.equalTo(self.greenView.mas_bottom);
}];

UIButton *hiddenButton = [UIButton buttonWithType:UIButtonTypeCustom];
[hiddenButton setTitle:@"影藏中间的View" forState:UIControlStateNormal];
[hiddenButton addTarget:self action:@selector(hiddenAction:) forControlEvents:UIControlEventTouchUpInside];
[hiddenButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
[self.view addSubview:hiddenButton];
[hiddenButton mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.equalTo(self.view);
    make.top.equalTo(blueView.mas_bottom).offset(40);
}];
}

static bool isActive = NO;
- (void)hiddenAction:(id)sender {
if (isActive) {
    [_gHeightConstraint deactivate];
} else {
    [_gHeightConstraint activate];
}
//动画展示
[UIView animateWithDuration:.25 animations:^{
    [self.view layoutIfNeeded];
}];

isActive = !isActive;
}
</code></pre>

<h3>3、Preview的使用</h3>

<p>这段时间在学习storyBoard相关的一些知识，RW上的两篇文章：<a href="http://www.raywenderlich.com/50308/storyboards-tutorial-in-ios-7-part-1">Part1</a>和<a href="http://www.raywenderlich.com/50310/storyboards-tutorial-in-ios-7-part-2">Part2</a>非常适合初学者学习，已经有人翻译成了中文<a href="http://www.cocoachina.com/industry/20131213/7537.html">Part1</a>，<a href="http://blog.sina.com.cn/s/blog_5c5c87d80101dzyh.html">Part2</a>。</p>

<p><code>Xcode</code>提供了一个很重要的功能<code>Preview</code>。当我们在<code>Storyboard</code>上使用<code>Auto Layout</code>上进行布局以后，由于目前的画布<code>canvas</code>已经没有尺寸的概念，我们布局完成后需要在3.5、4.0、4.7、5.5英寸的设备上测试，如果支持旋转或者支持iPad，一个效果我们会build多次在不同的设备上查看效果。非常的麻烦，但是有了<code>Preview</code>后一切都变得简单起来。
使用<code>Preview</code>的步奏如下：</p>

<p>1、选中<code>Main.storyboard</code>,如下图所示，选取的时候按下<code>option+shift</code>按键。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eya4nzk6ywj20b204p74o.jpg" alt="选择storyboard" /></p>

<p>2、选取<code>Preview</code>后会出来如下的界面，选择界面右边的<code>+</code>号，按<code>回车</code>。</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eya4nzzeuxj20bc05daae.jpg" alt="image" /></p>

<p>3、通过步骤<code>2</code>后，会出现以下的界面：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4o08srqj20f70gh0t6.jpg" height="520" width="500" alt="Preview界面" /></p>

<p>关键的几个地方我都用红方框圈了起来，左下角的<code>+</code>能模拟不同的设备，中间的红框部位可以模拟设备的旋转，
右下角的<code>English</code>部位可以模拟布局中的文学信息双倍后的布局表现，这几个功能都非常的方便。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App中拨打电话一点小总结]]></title>
    <link href="http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-%5B%3F%5D-dian-xiao-zong-jie/"/>
    <updated>2015-08-23T12:27:08+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-[?]-dian-xiao-zong-jie</id>
    <content type="html"><![CDATA[<h3>App内发起电话拨打的一点小技巧</h3>

<h4>一、拨打电话</h4>

<p>在App内发起电话拨打主要有两种方式：</p>

<p>1、利用这种方式发起的电话拨打，通话结束后不会直接返回App内，而是停留在通信录里面：</p>

<pre><code> NSString *str = [[NSString alloc] initWithFormat:@"tel:%@",@"131xxxx1909"];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:str]];
</code></pre>

<!--more-->


<p>2、利用<code>UIWebView</code>实现电话拨打，会弹出拨打提示，并且拨打完成后会返回App内：</p>

<pre><code>NSString *phone = @"131****1909";
NSString *cleanedString =[[phone componentsSeparatedByCharactersInSet:[[NSCharacterSet characterSetWithCharactersInString:@"0123456789-+()"] invertedSet]] componentsJoinedByString:@""];
NSString *escapedPhoneNumber = [cleanedString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSURL *telURL = [NSURL URLWithString:[NSString stringWithFormat:@"tel://%@",escapedPhoneNumber]];
UIWebView *mCallWebview = [[UIWebView alloc] init] ;

[self.view addSubview:mCallWebview];
[mCallWebview loadRequest:[NSURLRequest requestWithURL:telURL]];
</code></pre>

<h4>二、检测通话时间</h4>

<p>利用<code>CTCallCenter</code>我们可以检测在使用App期间拨打电话出去以及电话打入的时机，以及通话结束的时机。实现如下：</p>

<pre><code> #import &lt;CoreTelephony/CTCallCenter.h&gt;
 #import &lt;CoreTelephony/CTCall.h&gt;

 @interface AppDelegate : UIResponder&lt;UIApplicationDelegate&gt;
 @property (nonatomic, strong) CTCallCenter *callCenter;
 @end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.callCenter = [[CTCallCenter alloc] init];
  [self handleCall];
  return YES;
}

-(void)handleCall
{
   self.callCenter.callEventHandler = ^(CTCall *call) {
    if ([call.callState isEqualToString: CTCallStateConnected])
    {
        NSLog(@"接通电话");
    }
    else if ([call.callState isEqualToString: CTCallStateDialing])
    {
        NSLog(@"发起呼叫");
    }
    else if ([call.callState isEqualToString: CTCallStateDisconnected])
    {
        NSLog(@"结束电话");
    }
    else if ([call.callState isEqualToString: CTCallStateIncoming])
    {
        NSLog(@"打入电话");
    }
   };
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode控制台打印CGRect]]></title>
    <link href="http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect/"/>
    <updated>2015-06-15T21:15:58+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect</id>
    <content type="html"><![CDATA[<p>在用Xcode调试开发的时候，我们经常需要在控制台打印某个视图的frame，以前的时候相当麻烦，但是从Xcode6.3以后，打印frame变得很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Before
</span><span class='line'>(lldb) p (CGRect) [self frame]
</span><span class='line'>(CGRect) $0 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span><span class='line'> 
</span><span class='line'>// After
</span><span class='line'>(lldb) expr @import UIKit
</span><span class='line'>(lldb) p self.frame
</span><span class='line'>(CGRect) $1 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking2.0使用心得]]></title>
    <link href="http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de/"/>
    <updated>2015-05-13T13:56:23+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de</id>
    <content type="html"><![CDATA[<p>这段时间要将公司项目中的网络引擎由<a href="http://allseeing-i.com/ASIHTTPRequest/">ASIHTTPRequest</a>替换为<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>,替换的过程比较曲折，在此记录下自己替换过程中得心得：</p>

<h3>1、建立数据请求中介者</h3>

<p>建立<code>中介者</code>是指项目中的数据请求都通过它去实现，而不是每一个数据请求都直接与<code>AFNetworking</code>打交道，这样做的好处是：</p>

<ul>
<li>将网络请求与第三方库依赖隔离开来，方便以后对第三方库的替换。</li>
<li>方便处理网络请求的公共逻辑。</li>
</ul>


<!--more-->


<h3>2、使用completionQueue</h3>

<p>默认情况下<code>AFURLConnectionOperation</code>或者<code>AFHTTPRequestOperation</code>请求结束以后会在主线程将结果传递回来，如果你要将请求的结果做一些耗时的复杂的处理，就会<em>block</em>住主线程，所以这种情况下你就需要对请求的Operation传递<code>completionQueue</code>参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperation *request = [[AFHTTPRequestOperation alloc] initWithRequest:urlrequest];
</span><span class='line'>
</span><span class='line'>request.responseSerializer = [AFJSONResponseSerializer serializer];
</span><span class='line'>//设置回调的queue，默认是在mainQueue执行block回调
</span><span class='line'>request.completionQueue = your_request_operation_completion_queue();
</span><span class='line'>[request setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>         //设置了'completionQueue'后，就可以在这里处理复杂的逻辑
</span><span class='line'>         //不用担心block住了主线程
</span><span class='line'>    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>
</span><span class='line'> }];
</span><span class='line'> [request start];
</span></code></pre></td></tr></table></div></figure>


<h3>3、如何知道AFHTTPRequestOperationManager执行完成</h3>

<p>开始以为直接设置<code>AFHTTPRequestOperationManager</code>的<em>completionGroup</em>，然后利用<code>dispatch_group_notify</code>来获取operationQueue执行结束的通知，最后才发现，这样根本不行，看了源码才知道：<code>AFHTTPRequestOperationManager</code>直接将<em>completionGroup</em>赋值给了他的每一个<em>operation</em>，在<em>operation</em>的completionBlock里面利用<em>completionGroup</em>，来确保在operation的处理完成后，将completionBlock置为nil，防止循环引用。</p>

<p>虽然说这样不能知道<code>AFHTTPRequestOperationManager</code>什么时候执行完成，但是生活还得继续下去啊！在<code>AFURLConnectionOperation</code>中有一个方法叫：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSArray *)batchOfRequestOperations:(NSArray *)operations
</span><span class='line'>                        progressBlock:(void (^)(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations))progressBlock
</span><span class='line'>                      completionBlock:(void (^)(NSArray *operations))completionBlock;
</span></code></pre></td></tr></table></div></figure>


<p>这个方法就是能够发一组请求，跟<code>AFHTTPRequestOperationManager</code>比起来的缺点就是没法设置并发数，但是它却能实现检测一组请求什么时候结束，能检测完成了多少请求，它是怎么做到的呢？</p>

<p>原来他也是利用<strong>dispatch_group_async</strong>和<strong>dispatch_group_notify</strong></p>

<p>一般的我们要把一个任务加入一个group里是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    block();
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这个写法等价于</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(queue, ^{
</span><span class='line'>    dispatch_group_enter(group);
</span><span class='line'>    block()
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>如果要把一个异步任务加入group，这样就行不通了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    [self performBlock:^(){
</span><span class='line'>        block();
</span><span class='line'>    }];
</span><span class='line'>    //未执行到block() group任务就已经完成了
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这是就需要用到<code>batchOfRequestOperations</code>里的实现了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_enter(group);
</span><span class='line'>[self performBlock:^(){
</span><span class='line'>    block();
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>}];
</span></code></pre></td></tr></table></div></figure>


<p>其实这个和引用计数差不多，<em>dispatch_group_enter</em>时引用计数+1，<em>dispatch_group_leave</em>时引用计数-1，引用计数为0时执行<em>dispatch_group_notify</em>的内容。具体过程大致如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperationManager *downloadManager = [AFHTTPRequestOperationManager manager];
</span><span class='line'>    //设置最大并发数
</span><span class='line'>    [downloadManager.operationQueue setMaxConcurrentOperationCount:([NSProcessInfo processInfo].processorCount) * 2];
</span><span class='line'>    //创建一个group
</span><span class='line'>    __block dispatch_group_t group = dispatch_group_create();
</span><span class='line'>    for (NSURL *url in urlArray) {
</span><span class='line'>        NSURLRequest *requestUrl = [NSURLRequest requestWithURL:url];
</span><span class='line'>        AFHTTPRequestOperation *requestOperation = [[AFHTTPRequestOperation alloc] initWithRequest:requestUrl];
</span><span class='line'>        [requestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        }];
</span><span class='line'>        //将请求加入队列中
</span><span class='line'>        [downloadManager.operationQueue addOperation:requestOperation];
</span><span class='line'>        dispatch_group_enter(group);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
</span><span class='line'>        //全部请求完成
</span><span class='line'>        
</span><span class='line'>    });  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>4、实现断点续传</h3>

<p><code>AFNetworking</code>虽然支持文件下载的暂停和继续，但是当缓存清空重新启动时，它并没有记录下下载的状态，无法续传，但是可以通过<a href="http://https://github.com/steipete/AFDownloadRequestOperation">AFDownloadRequestOperation</a>来简单的实现，其实过程也不是很复杂，大致如下，感兴趣的朋友可以阅读<code>AFDownloadRequestOperation</code>是实现部分：</p>

<p>1、设置<code>AFHTTPRequestOperation</code>的请求<code>NSMutableURLRequest</code><em>HTTPHeader</em>的<strong>Range</strong>字段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableURLRequest *mutableURLRequest = [self.request mutableCopy];
</span><span class='line'>//offset是指断点续传文件已经下载的大小
</span><span class='line'>[mutableURLRequest setValue:[NSString stringWithFormat:@"bytes=%llu-", offset] forHTTPHeaderField:@"Range"];</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>2、设置<code>AFHTTPRequestOperation</code>的<em>outputStream</em>属性。</p>

<pre><code class="` "> //downloadPath是指文件下载存放的路径
downloadOperation.outputStream = [NSOutputStream outputStreamToFileAtPath:downloadPath append:YES];
</code></pre>

<h3>结尾</h3>

<p>对于<code>ASIHTTPRequest</code>和<code>AFNetworking</code>的比较网上有很多很好的文章，一搜一大把，对于普通的使用来说感觉区别不大，请求速度什么的也没什么感觉，以上若有错误，还望大家多多
指正😃。</p>
]]></content>
  </entry>
  
</feed>
