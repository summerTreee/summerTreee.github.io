<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[夏树正茂]]></title>
  <link href="http://summertreee.github.io/atom.xml" rel="self"/>
  <link href="http://summertreee.github.io/"/>
  <updated>2016-03-27T22:15:41+08:00</updated>
  <id>http://summertreee.github.io/</id>
  <author>
    <name><![CDATA[梁炜V]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[面试精选：链表问题集锦]]></title>
    <link href="http://summertreee.github.io/blog/2016/03/27/mian-shi-jing-xuan-:lian-biao-wen-ti-ji-jin/"/>
    <updated>2016-03-27T22:13:23+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/03/27/mian-shi-jing-xuan-:lian-biao-wen-ti-ji-jin</id>
    <content type="html"><![CDATA[<blockquote><p>前言：链表由于其本身的灵活性，很能考察程序员的编程功底，在面试中被问到链表相关的知识的概率很高，所以很值得我们去学习汇总，下面的内容非原创，而是自己在复习链表的过程中从别处摘抄而来，若想查看原文内容，可以看文章末尾的链接。</p></blockquote>

<p>下面是本文所要用到的链表节点的定义：</p>

<pre><code>struct Node{
    int data;
    Node* next;
};    
</code></pre>

<!--more-->


<h4>1、在O(1)时间删除链表节点</h4>

<p><strong>题目描述</strong>：给定链表的头指针和一个节点指针，在O(1)时间删除该节点。[Google面试题]</p>

<p><strong>分析</strong>：本题与《编程之美》上的<code>从无头单链表中删除节点</code>类似。主要思想都是<code>狸猫换太子</code>，即用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。</p>

<p><strong>代码如下：</strong></p>

<pre><code>//O(1)时间删除链表节点，从无头单链表中删除节点
void deleteRandomNode(Node *cur)
{
    assert(cur != NULL);
    assert(cur-&gt;next != NULL);    //不能是尾节点
    Node* pNext = cur-&gt;next;
    cur-&gt;data = pNext-&gt;data;
    cur-&gt;next = pNext-&gt;next;
    delete pNext;
}  
</code></pre>

<h4>2、单链表的转置</h4>

<p><strong>题目描述：</strong>输入一个单向链表，输出逆序反转后的链表。</p>

<p><strong>分析：</strong>链表的转置是一个很常见、很基础的数据结构题了，非递归的算法很简单，用三个临时指针 pre、head、next 在链表上循环一遍即可。递归算法也是比较简单的，但是如果思路不清晰估计一时半会儿也写不出来吧。</p>

<p><code>循环版本</code>和<code>递归版本</code>的链表转置代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  
</span><span class='line'>//单链表的转置,循环方法
</span><span class='line'>Node* reverseByLoop(Node *head)
</span><span class='line'>{
</span><span class='line'>    if(head == NULL || head-&gt;next == NULL)
</span><span class='line'>        return head;
</span><span class='line'>    Node *pre = NULL;
</span><span class='line'>    Node *next = NULL;
</span><span class='line'>    while(head != NULL)
</span><span class='line'>    {
</span><span class='line'>        next = head-&gt;next;
</span><span class='line'>
</span><span class='line'>        head-&gt;next = pre;
</span><span class='line'>        pre = head;
</span><span class='line'>        head = next;
</span><span class='line'>    }
</span><span class='line'>    return pre;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//单链表的转置,递归方法
</span><span class='line'>Node* reverseByRecursion(Node *head)
</span><span class='line'>{
</span><span class='line'>    //第一个条件是判断异常，第二个条件是结束判断
</span><span class='line'>    if(head == NULL || head-&gt;next == NULL) 
</span><span class='line'>        return head;
</span><span class='line'>
</span><span class='line'>    Node *newHead = reverseByRecursion(head-&gt;next);
</span><span class='line'>
</span><span class='line'>    head-&gt;next-&gt;next = head;
</span><span class='line'>    head-&gt;next = NULL;
</span><span class='line'>
</span><span class='line'>    return newHead;    //返回新链表的头指针
</span><span class='line'>}
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>3、求链表倒数第k个节点</h4>

<p><strong>题目描述：</strong>输入一个单向链表，输出该链表中倒数第k个节点，链表的倒数第0个节点为链表的尾指针。</p>

<p><strong>分析：</strong>设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//倒数第k个节点
</span><span class='line'>Node* theKthNode(Node *head,int k)
</span><span class='line'>{
</span><span class='line'>    if(k &lt; 0) return NULL;    //异常判断
</span><span class='line'>
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>    int i = k;
</span><span class='line'>    for(;i&gt;0 && fast!=NULL;i--)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(i &gt; 0)    return NULL;    //考虑k大于链表长度的case
</span><span class='line'>
</span><span class='line'>    while(fast != NULL)
</span><span class='line'>    {
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>        fast = fast-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return slow;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>4、求链表的中间节点</h4>

<p><strong>题目描述：</strong>求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。</p>

<p><strong>分析：</strong>此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//求链表的中间节点
</span><span class='line'>Node* theMiddleNode(Node *head)
</span><span class='line'>{
</span><span class='line'>    if(head == NULL)
</span><span class='line'>        return NULL;
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>    //如果要求在链表长度为偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件
</span><span class='line'>    //while(fast && fast-&gt;next != NULL && fast-&gt;next-&gt;next != NULL)  
</span><span class='line'>    while(fast != NULL && fast-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    return slow;
</span><span class='line'>}  
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>5、判断单链表是否存在环</h4>

<p><strong>题目描述：</strong>输入一个单向链表，判断链表是否有环？</p>

<p><strong>分析：</strong>通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//判断单链表是否存在环,参数circleNode是环内节点，后面的题目会用到
</span><span class='line'>bool hasCircle(Node *head,Node *&circleNode)
</span><span class='line'>{
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>    while(fast != NULL && fast-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>        if(fast == slow)
</span><span class='line'>        {
</span><span class='line'>            circleNode = fast;
</span><span class='line'>            return true;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return false;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>6、找到环的入口点</h4>

<p><strong>题目描述：</strong>输入一个单向链表，判断链表是否有环。如果链表存在环，如何找到环的入口点？</p>

<p><strong>解题思路：</strong>由上题可知，按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。</p>

<p><strong>为什么？：</strong>假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有：</p>

<p>p1走的路径：<code>a+b ＝ n</code>；</p>

<p>p2走的路径： <code>a+b+k*L = 2*n</code>； p2 比 p1 多走了k圈环路，总路程是p1的2倍；</p>

<p>根据上述公式可以得到 <code>k*L=a+b=n</code>显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。</p>

<p>显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//找到环的入口点
</span><span class='line'>Node* findLoopPort(Node *head)
</span><span class='line'>{
</span><span class='line'>    //如果head为空，或者为单结点，则不存在环
</span><span class='line'>    if(head == NULL || head-&gt;next == NULL) return NULL;
</span><span class='line'>
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>
</span><span class='line'>    //先判断是否存在环
</span><span class='line'>    while(fast != NULL && fast-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>        if(fast == slow)
</span><span class='line'>            break;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(fast != slow) return NULL;    //不存在环
</span><span class='line'>
</span><span class='line'>    fast = head;                //快指针从头开始走，步长变为1
</span><span class='line'>    while(fast != slow)            //两者相遇即为入口点
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return fast;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>7、编程判断两个链表是否相交</h4>

<p><strong>题目描述：</strong>给出两个单向链表的头指针（如下图所示）：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f2brlca2xlj20d403qaa0.jpg" alt="image" /></p>

<p>比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。</p>

<p><strong>解题思路：</strong></p>

<ol>
<li>直接循环判断第一个链表的每个节点是否在第二个链表中。但，这种方法的时间复杂度为O(Length(h1) * Length(h2))。显然，我们得找到一种更为有效的方法，至少不能是O（N<sup>2</sup>）的复杂度。</li>
<li>针对第一个链表直接构造hash表，然后查询hash表，判断第二个链表的每个节点是否在hash表出现，如果所有的第二个链表的节点都能在hash表中找到，即说明第二个链表与第一个链表有相同的节点。时间复杂度为为线性：O(Length(h1) + Length(h2))，同时为了存储第一个链表的所有节点，空间复杂度为O(Length(h1))。是否还有更好的方法呢，既能够以线性时间复杂度解决问题，又能减少存储空间？</li>
<li>转换为环的问题。把第二个链表接在第一个链表后面，如果得到的链表有环，则说明两个链表相交。如何判断有环的问题上面已经讨论过了，但这里有更简单的方法。因为如果有环，则第二个链表的表头一定也在环上，即第二个链表会构成一个循环链表，我们只需要遍历第二个链表，看是否会回到起始点就可以判断出来。这个方法的时间复杂度是线性的，空间是常熟。</li>
<li>进一步考虑“如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。
所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)，显然比解法三更胜一筹。</li>
</ol>


<p><strong>解法的代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//判断两个链表是否相交
</span><span class='line'>bool isIntersect(Node *h1,Node *h2)
</span><span class='line'>{
</span><span class='line'>    if(h1 == NULL || h2 == NULL) return false;    //异常判断
</span><span class='line'>    while(h1-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        h1 = h1-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    while(h2-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        h2 = h2-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(h1 == h2) return true;        //尾节点是否相同
</span><span class='line'>    else return false;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>8、 扩展：链表有环，如何判断相交</h4>

<p><strong>题目描述：</strong>上面的问题都是针对链表无环的，那么如果现在，链表是有环的呢?上面的方法还同样有效么?</p>

<p><strong>分析：</strong>如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//判断两个带环链表是否相交
</span><span class='line'>bool isIntersectWithLoop(Node *h1,Node *h2)
</span><span class='line'>{
</span><span class='line'>    Node *circleNode1,*circleNode2;
</span><span class='line'>    if(!hasCircle(h1,circleNode1))    //判断链表带不带环，并保存环内节点
</span><span class='line'>        return false;                //不带环，异常退出
</span><span class='line'>    if(!hasCircle(h2,circleNode2))
</span><span class='line'>        return false;
</span><span class='line'>
</span><span class='line'>    Node *temp = circleNode2-&gt;next;
</span><span class='line'>    while(temp != circleNode2)
</span><span class='line'>    {
</span><span class='line'>        if(temp == circleNode1)
</span><span class='line'>            return true;
</span><span class='line'>        temp = temp-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    return false;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>9、扩展：两链表相交的第一个公共节点</h4>

<p><strong>题目描述：</strong>如果两个无环单链表相交，怎么求出他们相交的第一个节点呢？</p>

<p><strong>分析：</strong>采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//求两链表相交的第一个公共节点
</span><span class='line'>Node* findIntersectNode(Node *h1,Node *h2)
</span><span class='line'>{
</span><span class='line'>    int len1 = listLength(h1);          //求链表长度
</span><span class='line'>    int len2 = listLength(h2);
</span><span class='line'>    //对齐两个链表
</span><span class='line'>    if(len1 &gt; len2)
</span><span class='line'>    {
</span><span class='line'>        for(int i=0;i&lt;len1-len2;i++)
</span><span class='line'>            h1=h1-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    else 
</span><span class='line'>    {
</span><span class='line'>        for(int i=0;i&lt;len2-len1;i++)
</span><span class='line'>            h2=h2-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    while(h1 != NULL)
</span><span class='line'>    {
</span><span class='line'>        if(h1 == h2)
</span><span class='line'>            return h1;
</span><span class='line'>        h1 = h1-&gt;next;
</span><span class='line'>        h2 = h2-&gt;next;    
</span><span class='line'>    }
</span><span class='line'>    return NULL;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>原文链接，请戳<a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS测试之UIAutomation介绍]]></title>
    <link href="http://summertreee.github.io/blog/2016/02/29/iosce-shi-zhi-uiautomationjie-shao/"/>
    <updated>2016-02-29T07:47:18+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/02/29/iosce-shi-zhi-uiautomationjie-shao</id>
    <content type="html"><![CDATA[<p>UIAutomation是随着iOS SDK 4.0引入的，帮助开发者在<code>while you sleep</code>的时候也能帮你进行自动化的UI测试，它的测试代码使用Javascript编写，不过别担心，如果你对Javascript不熟悉的话，可以使用Instrument中<code>UIAutomation</code>的录制功能，它能将你的操作转换为测试代码，你只需要保存这些自动生成的代码就行，稍后我们将介绍该功能。</p>

<p>使用<code>UIAutomation</code>做自动化UI测试时，使用者需要做最基本的两件事情是：</p>

<ul>
<li>如何找到界面上的UI元素</li>
<li>如何针对找到的UI元素进行测试操作</li>
</ul>


<!--more-->


<h4>如何找到界面上的UI元素</h4>

<p>在<code>UIAutomation</code>中，界面就是一堆UI元素构建的层级结构，这些元素需要一个叫<code>Accessibility label</code>去标记，它可以在如下所示的地方进行设置：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1q07rxj20bn0d83zs.jpg" alt="image" /></p>

<p><code>UI Accessibility</code>在iOS3.0就被引入了，它是用来辅助身体不便的人士使用APP的，VoiceOver是Apple的屏幕阅读技术，而<code>UI Accessibility</code>的基本原则就是对屏幕上的UI元素进行分类和标记，两者配合，通过阅读和聆听这些元素，用户就可以在不接触屏幕的情况下通过声音使用APP。</p>

<p><code>Accessibility</code> 的核心思想是对 UI 元素进行分类和标记，将屏幕上的UI分类为像是按钮，文本框，Cell或者是静态文本(也就是label) 这样的类型，然后使用<code>identifier</code>来区分不同的UI元素。用户可以通过语音控制app的按钮点击，或是询问某个label的内容等等，十分方便。iOS SDK 中的控件都实现了默认的<code>Accessibility</code>支持，而我们如果使用自定义的控件的话，则需要自行使用 <code>Accessibility</code> 的 API 来进行添加。</p>

<h4>对找到的UI元素进行测试操作</h4>

<h5>1、启动Instruments</h5>

<p>由于<code>UIAutomation</code>被集成到了<code>Instruments</code>中，所以要进行<code>UIAutomation</code>测试，首先打开如下所示的工具<code>Automation</code></p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1qinz2j20l90bz774.jpg" alt="image" /></p>

<h6>2、编写测试代码</h6>

<p>打开<code>Automation</code>如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1r6ehaj20ou0jdq6l.jpg" alt="image" /></p>

<p>在这里我们可以进行测试代码的编写或者在右边区域直接导入已经写好的测试代码，正如前面提到的，这些测试代码需要使用JavaScript进行编写，如果你不熟悉或者嫌麻烦，可以使用底部的录制功能，启用录制后你对屏幕的测试操作都会被自动的转为测试代码，非常方便。</p>

<p>测试如果不通过，就会在顶部的时间轴上标红，测试也会自动停止。</p>

<h6>3、测试代码相关的简介</h6>

<p>在<code>UIAutomation</code>中所有元素都继承自<code>UIAElement</code>，这个对象提供了每个UI元素所应具备的如下属性：</p>

<ul>
<li>name</li>
<li>value</li>
<li>elements</li>
<li>parent</li>
</ul>


<p>一、Target application<br/>
获取方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIAtarget.localTarget().ftontMostApp()  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1rmjppj208u0dw769.jpg" alt="image" /></p>

<p>二、Main Window<br/>
获取到他的方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIAtarget.localTarget().ftontMostApp().mainWindow()  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1rmjppj208u0dw769.jpg" alt="image" /></p>

<p>三、View<br/>
获取主视图的方法如下(eg:UITableView):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().mainWindow ().tableViews()[0]  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1se2hij208u0dwac1.jpg" alt="image" /></p>

<p>四、Element<br/>
例如获取tableView下的第一行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().mainWindow ().tableViews()[0].cells()[0]  </span></code></pre></td></tr></table></div></figure>


<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1t0c7rj208w0dwtao.jpg" alt="image" /></p>

<p>五、Child Element<br/>
例如想获取第一行里面的显示标题的label：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().mainWindow ().tableViews()[0].cells()[0].elements()[“第一章 会计法律制度”]  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1te5d2j208u0dwabz.jpg" alt="image" /></p>

<p>六、button的点击事件<br/>
例如一个叫<code>Edit</code>的button，我们要模拟对他的点击，可以如下测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().navigationBar().buttons()["Add"].tap();  </span></code></pre></td></tr></table></div></figure>


<p>
七、文本的输入<br/>
例如界面上只有一个<code>UITextField</code>，我们要测试对它输入一段文字：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var name = “Turtle Pie”; UIATarget.localTarget().frontMostApp().mainWindow().textFields()[0].setValue(name);  </span></code></pre></td></tr></table></div></figure>


<p>八、Logging<br/>
开始测试和结束测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var testName = "My first test"; UIALogger.logStart(testName); ... // test code ... UIALogger.logPass(testName);</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>测试过程中打印Log信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var testName = "My first test"; UIALogger.logStart(testName); ... UIALogger.logMessage("Logging about my test"); ... UIALogger.logPass(testName);  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>九、模拟点击Home键进入后台一段时间再自动唤起：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> UIALogger.logMessage("Deactivating app");
</span><span class='line'> //10s后自动唤起 UIATarget.localTarget().deactivateAppForDuration(10); UIALogger.logMessage("Resuming test after deactivation");</span></code></pre></td></tr></table></div></figure>


<p>
十、模拟Orientation切换：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var target = UIATarget.localTarget(); var app = target.frontMostApp(); // set landscape left target.setDeviceOrientation(UIA_DEVICE_ORIENTATION_LANDSCAPELEFT); UIALogger.logMessage("Current orientation is " + app.interfaceOrientation()); // portrait target.setDeviceOrientation(UIA_DEVICE_ORIENTATION_PORTRAIT); UIALogger.logMessage("Current orientation is " + app.interfaceOrientation());   </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>模拟手势操作</h5>

<p>一、Taps</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().tap({x:100, y:200});UIATarget.localTarget().doubleTap({x:100, y:200});UIATarget.localTarget().twoFingerTap({x:100, y:200});</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>二、Pinches</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//指定pinch在2秒内完成
</span><span class='line'>UIATarget.localTarget().pinchOpenFromToForDuration({x:20, y:200}, {x:300, y:200},2);UIATarget.localTarget().pinchCloseFromToForDuration({x:20, y:200}, {x:300, y:200}, 2);</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>三、Drag and Flick</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().dragFromToForDuration({x:160, y:200}, {x:160, y:400}, 1);UIATarget.localTarget().flickFromTo({x:160, y:200}, {x:160, y:400});</span></code></pre></td></tr></table></div></figure>


<p>虽然从iOS7开始，<code>UIAutomatation</code>苹果不在维护了，转而支持Xcode中的UI Testing，但是它却可以测试复杂的手势操作，这是目前UI Testing无法完成的。</p>

<h5>参考文章</h5>

<p>1、<a href="https://developer.apple.com/videos/play/wwdc2010/306/">https://developer.apple.com/videos/play/wwdc2010/306/</a><br/>
2、<a href="http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation">http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation</a><br/>
3、<a href="http://onevcat.com/2015/09/ui-testing/">http://onevcat.com/2015/09/ui-testing/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中如何在一个工程创建多个App]]></title>
    <link href="http://summertreee.github.io/blog/2016/01/23/ioszhong-ru-he-zai-%5B%3F%5D-ge-gong-cheng-chuang-jian-duo-ge-app/"/>
    <updated>2016-01-23T20:11:40+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/01/23/ioszhong-ru-he-zai-[?]-ge-gong-cheng-chuang-jian-duo-ge-app</id>
    <content type="html"><![CDATA[<p>一般情况下，我们是一个App应用对应一个<code>Xcode Project</code>，但是如果你需要同时开发多个产品，而这些产品90%的数据结构以及交互方式都一样，呈现在用户面前的这两个产品，最大的不一样就是UI元素以及某些配色时，如果这个时候还是一个App一个<code>Xcode Project</code>，普遍的做法是：</p>

<p>你会先开发完成一个产品，然后在复制到其他的产品中，非常的麻烦而且效率很低，你需要一个一个文件去比对。如果你使用模块的方式，开发完一个模块，然后再利用<code>Pod</code>的方式导入到其他产品中，虽然这样可行，但是涉及到产品的迭代开发以及产品的随时会变的交互，模块的细化分很难实现。</p>

<p>如果你也面临这样的问题，不放考虑一下下面讲的<code>一个工程来开发多个App</code>：</p>

<!--more-->


<h4>1、创建新的Target</h4>

<p>如果现在你已经有个一个产品叫<code>MultipleTargetA</code>，如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f09onfv2lnj20e709xabz.jpg" alt="image" /></p>

<p>这时你想添加一个叫<code>MultipleTargetB</code>的产品，你需要做的是按如下的步奏进行创建：
选择<code>Project -&gt; Targets -&gt; 右击MultipleTargetsA -&gt; 选择Duplicate</code>，这时我们就按照<code>MultipleTargetsA</code>复制了一个产品<code>MultipleTargetsA copy</code>，并且你会看到多出了一个文件<code>MultipleTargetsA copy-Info.plist</code>，如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f09onggesdj20cr0b8q53.jpg" alt="image" /></p>

<p>将<strong>TARGETS</strong>里面的<code>MultipleTargetsA copy</code>改名为<code>MultipleTargetsB</code>（选中回车进入编辑）。</p>

<h4>2、编辑plist文件</h4>

<p>上面讲到了当我们创建新的<code>Target</code>后会多出一个<code>MultipleTargetsA copy-Info.plist</code>文件，这个<code>plist</code>文件就是控制<code>MultipleTargetsB</code>的名称，版本等信息的文件，我们为了统一将他改为<code>MultipleTargetsB-Info.plist</code>，在修改名字之前你需要在<code>MultipleTargetsB</code>的<code>Build Settings</code>中找到<code>MultipleTargetsA copy-Info.plist</code>一项，待会儿我们修改完这个<code>plist</code>文件以后，还需要在这里填入它正切的位置信息。这样程序执行时才能找到它，不然程序是不能通过编译的：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f09ongryr7j20oq0algnp.jpg" alt="image" /></p>

<p>处理完上面的操作后，程序能正常通过编译后我们还需要修改<code>plist</code>文件里面的一下符合我们预期的信息：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f09onhbzvjj20h20aydj0.jpg" alt="image" /></p>

<h4>3、定义Preprocessor Macros</h4>

<p>现在我们的工程里面同时包含了两个<code>Target</code>，现在工程里面的类是这两个<code>Target</code>公用的，如果你想在一个类里面区分是<code>MultipleTargetsA</code>还是<code>MultipleTargetsB</code>，这时你就需要用到<code>Preprocessor Macros</code>了，它的定义很简单，选中一个<code>Target</code>，然后在<code>Build Settings</code>里面搜索<code>Preprocessor Macros</code>一项，然后在里面添加表明是<code>MultipleTargetsA</code>的宏：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f09oni1sa6j20ol0fbwhe.jpg" alt="image" /></p>

<p>假如我们为<code>MultipleTargetsA</code>和<code>MultipleTargetsB</code>分别按如上步奏添加了标识：<code>MultipleTargetsA</code>和<code>MultipleTargetsB</code>,那在某个类里面判断现在编译的目标是哪个<code>Target</code>就变得简单了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)someFunction
</span><span class='line'>{
</span><span class='line'>#ifdef MultipleTargetsA
</span><span class='line'>    NSLog(@"Build For Target MultipleTargetsA!");
</span><span class='line'>#else
</span><span class='line'>    NSLog(@"Build For Target MultipleTargetsB!");
</span><span class='line'>#endif
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>4、修改Scheme</h4>

<p>现在<code>MultipleTargetsB</code>的<code>Scheme</code>还是<code>MultipleTargetsA copy</code>:</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f09onihy4tj20c20820uh.jpg" alt="image" /></p>

<p>我们可以通过<code>Manage Schemes</code>，选择<code>MultipleTargetsA copy</code>，然后按回车键进行编辑，将它改为<code>MultipleTargetsB</code>：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f09onj571gj20m00d4dh4.jpg" alt="image" /></p>

<h4>5、资源文件和类文件</h4>

<p>上面说了几个<code>APP</code>%90是相同的，不同的地方的资源文件和类文件如果要加以区分，比如<code>A.m</code>类属于<code>MultipleTargetsA</code>而不属于<code>MultipleTargetsB</code>，这时我们可以利用<code>Xcode</code>的<code>Target Membership</code>功能，来选择该类属于哪个<code>Target</code>。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f09onjlay4j20dw0a5dh8.jpg" alt="image" /></p>

<p>对于<code>Assets</code>文件来说，它只能整体的选择某个<code>Target</code>，所以不同的<code>Target</code>你可能需要建立不同的<code>Assets</code>文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classes and Metaclasses]]></title>
    <link href="http://summertreee.github.io/blog/2015/12/28/classes-and-metaclasses/"/>
    <updated>2015-12-28T13:53:36+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/12/28/classes-and-metaclasses</id>
    <content type="html"><![CDATA[<p>这是一篇译文，原文<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">在这里</a>，水平有限，翻译难免有错误的地方。</p>

<p><code>Objective-C</code>是一个基于类别对象的系统。每一个对象都是某个类的实例，对象的<code>isa</code>指向它自己的类(Class),这个类描述了该对象所有的数据信息：开辟的空间大小，成员变量类型以及其他信息的排列，这个类同样也描述了该对象可以执行的一些行为：可以响应哪些<code>selector</code>以及它自己实例方法的实现。</p>

<p>类的方法列表里面其实就是该类的所有实例方法的集合，通俗的讲就是该对象可以响应的所有<code>selectors</code>。当你向一个类发送消息时，会通过<code>objc_msgSend()</code>去查找它自身的类的方法列表(如果它有父类的话，也会在它的父类方法列表中去查找)来决定调用哪一个方法。</p>

<!--more-->


<p><code>Objective-C</code>的每一个类也是一个对象，它也有<code>isa</code>指针以及其他的一些信息，同样它也能响应<code>selector</code>，当你调用类方法时，比如：<code>[NSObject alloc]</code>，其实你是在向该类发送消息。</p>

<p>上面说了，类也是一个对象，那它必定也是其他某一个类的一个实例，这就是<code>metaclass</code>，<code>metaclass</code>里面存放了类对象的所有信息，类和<code>metaclass</code>的关系就和刚才上面讲的实例对象和该实例的类的关系一样，<code>metaclass</code>的方法列表里面存放的该类对象能够响应的方法。当你向一个类(这个类是某个metaclass的一个实例对象)发送一个消息时，<code>objc_msgSend()</code>回去遍历<code>metaclass</code>的方法列表，如果它有父类的话，同样也会遍历父类的所有方法列表，从而决定调用哪一个方法。类方法的定义存放与类对象的<code>metaclass</code>，与之相对应的是实例方法的定义存放于实例对象对应的类里面。</p>

<p><code>metaclass</code>究竟是个啥？它也是一直向下的吗？NO，一个<code>metaclass</code>又是某个类的根类的<code>metaclass</code>实例对象，根<code>metaclass</code>又是它自身的一个实例对象，在这里<code>isa</code>指针的指向形成了一个环：实例对象->类->metaclass->根metaclass->它自己(根metaclass)，在实际的使用中我们很少和metaclass直接打交道。</p>

<p><code>metaclass</code>的父类和类的父类直接形成了两条平行线，所有类方法的继承类似于实例方法的继承，并且根<code>metaclass</code>的父类就是根类，所以每个类对象都能响应根类的实例方法，最后需要说一下的是一个类对象是它根类或者根类的一个子类的实例。</p>

<p>是不是觉得有些迷惑，下面的图或许能给你一点帮助，你需要记住的是，当向一个对象发送任何消息是，都是从该对象的<code>isa</code>指针开始，然后按着它的父类一直寻找，直到找到合适的方法去调用，实例方法定义在类里面，类方法定义在<code>metaclass</code>和根类里面。<br/>
<img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0jw1ezfb7ybjzqj20gw0hm40e.jpg" alt="image" /></p>

<p><code>Objective-C</code>为了它的实用性，将类方法由<code>metaclass</code>管理，但另一方面它又想把<code>metaclass</code>影藏起来，例如<code>[NSObject class]</code>和<code>[NSObject self]</code>是完全等价的，其实它这个时候是返回的<code>metaclass</code>，也就是<code>NSObject-&gt;isa</code>所指向的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ContentCompressionResistance和ContentHugging详解]]></title>
    <link href="http://summertreee.github.io/blog/2015/12/13/contentcompressionresistancehe-contenthuggingxiang-jie/"/>
    <updated>2015-12-13T17:07:53+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/12/13/contentcompressionresistancehe-contenthuggingxiang-jie</id>
    <content type="html"><![CDATA[<p>在Auto Layout的使用中，有两个很重要的布局概念：<code>Content Compression Resistance</code>和<code>Content Hugging</code>，从字面的翻译我们大概可以分别翻译为：<code>压缩阻力</code>以及<code>内容吸附</code>。但是光从字面意思来理解很难知道它们如何使用以及确切的设计意图。我最开始也是很迷糊而且在使用Auto Layout的过程中也没有使用过它们，直到最近稍稍研究了一下，发现它们的作用甚是巨大，所以我为了加深记忆，把我最近学习到的关于它们的概念在此稍作整理加以记录。</p>

<blockquote><p>注：以下为了表述方便，将<code>Content Compression Resistance</code>记为<code>压缩阻力</code>，将<code>Content Hugging</code>记为<code>内容吸附</code>。</p></blockquote>

<!--more-->


<h4>Content Compression Resistance</h4>

<p><strong>压缩阻力</strong>属性为了记忆更加形象我们可以把它理解为<strong>离我远点，不许挤到我</strong>，它的优先级（Priority）越高，它的这种抗挤压的能力也就越强，我们可以通过代码在控件的水平或垂直方向上分别设置1（最低优先级）到1000（最高优先级）之间的优先级，默认是750，例如我们可以为一个<strong>UILabel</strong>控件设置一个它在水平方向上优先级为<em>500</em>的压缩阻力：</p>

<pre><code>[label setContentCompressionResistancePriority:500 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>用图来表示，我们可以大致表示如下，视图的压缩阻力就好似它自身往外的张力，优先级越高，视图自己维持自身显示完整性的能力就越强：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwdofkoj208r08r74s.jpg" alt="image" /></p>

<h4>Content Hugging</h4>

<p><strong>内容吸附</strong>属性为了记忆方便我们可以把它理解为<strong>抱紧（Hug）</strong>，视图的大小不会随着superView的变大而扩大，而是只维持能完全显示自己内容的大小，它的这种优先级越高，吸附的能力就越强，和<strong>压缩阻力</strong>一样，<strong>内容吸附</strong>的优先级也可以通过代码来设置，只是它的默认优先级是<em>250</em>：</p>

<pre><code>[label setContentHuggingPriority:251 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>用图来表示，我们可以大致表示如下，视图的内容吸附就好似视图自己有向内抱紧自己的力量一样，优先级越高，它的这种能力就越强：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwdllbej208n08mq3e.jpg" alt="image" /></p>

<p>以上讲了<code>内容吸附</code>和<code>压缩阻力</code>的基本概念，但是这两个属性是建立在<code>Intrinsic Content Size</code>这一概念上的，我们暂且把它翻译为<code>固有尺寸</code>，所有基于UIView的视图都有<code>intrinsicContentSize</code>这个属性，下面我们就介绍一下什么是<code>固有尺寸</code>。</p>

<h4>Intrinsic Content Size</h4>

<p>每个视图都有压缩阻力优先级（Content Compression Resistance Priority）和内容吸附优先级（Content Hugging Priority），但只有视图明确了它的<code>固有尺寸</code>后，这两种优先级才会起作用。我们首先来看一下官方的解释：</p>

<blockquote><p> Custom views typically have content that they display of which the layout system is unaware. Overriding this method allows a custom view to communicate to the layout system what size it would like to be based on its content. This intrinsic size must be independent of the content frame, because there’s no way to dynamically communicate a changed width to the layout system based on a changed height, for example.
If a custom view has no intrinsic size for a given dimension, it can return UIViewNoIntrinsicMetric for that dimension.</p></blockquote>

<p>大致的意思就是我们自定义的视图在默认情况下，它的固有尺寸是返回(UIViewNoIntrinsicMetric，UIViewNoIntrinsicMetric)，也就是(-1,-1)，只有我们根据自定义视图本身的Content来重写该方法，我们自定义的视图才能明确的知道他在显示系统中该展示的大小。<br/>
UILabel和UIButton等这些控件，系统默认是根据他们的内容实现了固有尺寸，所以我们在使用的时候只需要确定origin或者Center它们就能正确的显示。<br/>
由此可见，固有尺寸是为了实现视图的<strong>大小自适应</strong>而存在的。</p>

<p>以下我来自定义一个视图，来测试一下<code>固有尺寸</code>是否有效，由于项目中大家都是用<a href="http://https://github.com/SnapKit/Masonry">Masonry</a>来处理Auto Layout，所以一下的例子都使用<code>Masonry</code>来布局。</p>

<h5>重写Intrinsic Content Size</h5>

<p>我们新建一个继承自<code>UIView</code>的自定义视图<code>IntrinsicView</code>，在一个ViewController中添加一个我们自定义的视图,设置它水平居中，顶部和父视图对齐。</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *intrinsicView = [IntrinsicView new];
    intrinsicView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:intrinsicView];
    [intrinsicView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.mas_equalTo(self.view);
    make.top.mas_equalTo(self.mas_topLayoutGuideBottom);
}];
}
</code></pre>

<p>运行后发现什么也没显示，因为我们没有设置它的宽高，而它默认的固有尺寸是（-1 ，-1）。我们去重写<code>IntrinsicView</code>的<code>- (CGSize)intrinsicContentSize</code>方法：</p>

<pre><code>@implementation IntrinsicView

- (CGSize)intrinsicContentSize
{
    return CGSizeMake(150, 66);
}

@end  
</code></pre>

<p>运行后显示如下：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw65tsuj208y0ddaa5.jpg" alt="image" /></p>

<p>显示出来，它的大小刚好是我们定义的<code>intrinsicContentSize</code>大小。上面介绍了内容吸附和压缩阻力以及固有尺寸的基本概念，下面来测试一下它们应该如何使用。</p>

<h6>1、测试内容吸附优先级</h6>

<p>为了测试内容吸附优先级我们在页面上添加两个<code>IntrinsicView</code>，分别是<code>topView</code>和<code>bottomView</code>，设置他们都水平居中，然后分别和页面的顶部和底部对齐：</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *topView = [IntrinsicView new];
    topView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:topView];
    [topView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(self.mas_topLayoutGuideBottom);//和导航栏底部对齐
    }];

    IntrinsicView *bottomView = [IntrinsicView new];
    bottomView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:bottomView];
    [bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.bottom.mas_equalTo(self.mas_bottomLayoutGuideBottom);//和页面底部对齐
    }];
}  
</code></pre>

<p>运行后展示如下：<br/>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw6ih8aj208w0ddglq.jpg" alt="image" /></p>

<p>下面我们设置<strong>topView</strong>和<strong>bottomView</strong>之间的间距为<em>40</em>，也就是<code>topView.bottom + 40 = bottomView.top</code>。</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *topView = [IntrinsicView new];
    topView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:topView];
    [topView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(self.mas_topLayoutGuideBottom);//和导航栏底部对齐
}];

    IntrinsicView *bottomView = [IntrinsicView new];
    bottomView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:bottomView];
    [bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(topView.mas_bottom).offset(40);
        make.bottom.mas_equalTo(self.mas_bottomLayoutGuideBottom);//和页面底部对齐
 }];
}  
</code></pre>

<p>运行后展示效果如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw6xva7j208v0dcmxb.jpg" alt="image" /></p>

<p>我们发现<code>topView</code>被拉伸了，如果我们不想<code>topView</code>被拉伸，就可以利用<code>内容吸附</code>的特性，因为我们定义了<code>IntrinsicView</code>的固有尺寸，设置<code>topView</code>的<code>内容吸附</code>优先级比<code>bottomView</code>的优先级高，我们上面介绍了<code>内容吸附</code>的默认优先级是<em>250</em>，我们把<code>topView</code>的<code>内容吸附</code>优先级设置为<em>251</em>，在原来<code>layoutSubIntrinsicView</code>函数的最后添加如下语句：</p>

<pre><code>[topView setContentHuggingPriority:251 forAxis:UILayoutConstraintAxisVertical];  
</code></pre>

<p>运行后如下所示，达到了我们想要的效果：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw7a0tqj208w0ddt8v.jpg" alt="image" /></p>

<blockquote><p>251是我随意定的比250大的值，可以是大于250小于1000的任何值。</p></blockquote>

<h6>2、测试压缩阻力优先级</h6>

<p>我们通常会遇到如下图所示的需求：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw7yw9hj20e007cdgi.jpg" alt="image" /></p>

<p>在某个页面上水平放置两个UILabel，<code>leftLabel</code>的左边和父视图的间距固定，<code>rightLabel</code>的右边和父视图的右边有一个小于等于某个间隔的约束，<code>leftLabel</code>和<code>rightLabel</code>之间有一个固定间距，它们的宽度根据他们显示的内容自适应，关键代码如下:</p>

<pre><code>[leftLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    //左边和父视图间隔固定为10
    make.left.mas_equalTo(self.view).offset(10);
    make.top.mas_equalTo(80);//随意设定的值
}];

[rightLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.mas_equalTo(leftLabel);
    //和leftLabel的右边间距固定为20
    make.left.mas_equalTo(leftLabel.mas_right).offset(20);
    //这里注意是‘lessThanOrEqualTo’，也就是‘rightLabel’的右边界
    //和父视图的间距至少为10，内容少时，间距自动调大
    make.right.mas_lessThanOrEqualTo(self.view).offset(-10);
}];  
</code></pre>

<p>在他们的显示内容宽度不超过父视图宽度时，两个label的内容都能正常的完全显示，但是当它们需要显示的内容长度总和超过父视图的宽度时，就会显示如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwckaf2j208x0ddglw.jpg" alt="image" /></p>

<p>一个label被压缩了， <code>rightLabel</code>显示不完全，如果在这种情况下，我们想<code>leftLabel</code>被压缩，而<code>rightLabel</code>尽量完全显示，由于UILabel这类控件，系统自己已经根据它们显示的实际内容实现了<code>固有尺寸</code>的方法，我们可以利用<code>压缩阻力</code>的特性，将<code>rightLabel</code>的<code>压缩阻力</code>优先级设置得比<code>leftLabel</code>高，上面介绍了<code>压缩阻力</code>的默认优先级是<em>750</em>，我们把<code>rightLabel</code>的优先级设置为<em>751</em>，在上面代码的最下面添加如下代码：</p>

<pre><code>[rightLabel setContentCompressionResistancePriority:751 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>运行后显示如下，达到了我们预期的效果：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwd0cbqj208x0dddg4.jpg" alt="image" /></p>

<h6>3、在自动计算UITableViewCell高度中的使用</h6>

<p>对于变高cell的处理，以前我们都是在<code>heightForRowAtIndexPath</code>方法里面，拼凑要展示的变高cell的高度，当我们改变cell中两个控件在垂直方向的布局，或者再添加一个控件时，还要去修改计算cell高度的方法来适应新的变化，非常不方便。但是有了自动布局后，利用好<code>压缩阻力</code>和<code>内容吸附</code>的优先级，可以很精确很简单的由系统来计算出变高cell的高度。</p>

<p>假定我们有如下需求：<br/>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxt9hqfj20e1097dgw.jpg" alt="image" /></p>

<p>我们看到，这个变高cell里面高度不定的是中间的<code>ContentLabel</code>，它会根据内容长度来折行显示，<strong>UILabel</strong>要折行显示我们需要设置它的<code>preferredMaxLayoutWidth</code>和<code>numberOfLines</code>两个属性的值。</p>

<p>首先假定<code>Model</code>的定义如下：</p>

<pre><code>@interface CellModel : NSObject

@property (nonatomic, copy) NSString *name;
@property (nonatomic, copy) NSString *company;
@property (nonatomic, copy) NSString *content;
@property (nonatomic, assign) CGFloat cacheHeight;//缓存当前Model显示的cell高度

@end
</code></pre>

<p>自定义的<code>UITableViewCell</code>的关键代码如下：</p>

<pre><code>//图片距左边距离为10，上下居中
    [_cellImageView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.contentView).offset(10);
        make.centerY.mas_equalTo(self.contentView);
        make.top.mas_greaterThanOrEqualTo(self.contentView).offset(10);
        make.bottom.mas_lessThanOrEqualTo(self.contentView).offset(-10);
    }];
    //标题Label,一行显示
    [_nameLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.cellImageView.mas_right).offset(6);
        make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
        make.top.mas_equalTo(self.contentView).offset(10);
    }];
    //内容label,多行显示
    _contentLabel.numberOfLines = 0;
    [self.contentView addSubview:_contentLabel];
    [_contentLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.nameLabel);
        make.top.mas_equalTo(self.nameLabel.mas_bottom).offset(6);
    }];
    //标题Label,一行显示
    [_companyLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.contentLabel);
        make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
        make.top.mas_equalTo(self.contentLabel.mas_bottom).offset(6);
        make.bottom.mas_equalTo(self.contentView).offset(-10);//设定了这个自动计算cell高度时才知道具体cell的高度
    }];

    [_nameLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
    [_companyLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
    [_contentLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];  
</code></pre>

<p>上面的代码中设置了几个<code>UILabel</code>的<code>内容吸附</code>优先级为最高，这样它们就不会随着cell高度的变化而拉伸高度。上面设置了<code>contentLabel</code>的<code>numberOfLines = 0</code>，还需要设置<code>preferredMaxLayoutWidth</code>才能正确换行显示。由于<code>UITableViewCell</code>在显示出来之前是不知道宽度的，但是为了获取正确的宽度我们可以在<code>- (void)layoutSubviews</code>方法里面设置：</p>

<pre><code>- (void)layoutSubviews
{
    _contentLabel.preferredMaxLayoutWidth = CGRectGetWidth(self.contentView.frame) - 128 - 10 - 6;//后面的数字是前后以及图片的宽度
    [super layoutSubviews];//这个调用是为了改变后更新布局
}
</code></pre>

<p>这样我们设置好cell以及Model以后，其他的方法都和普通的使用一样，唯一不一样的就是计算cell高度的<code>UITableView</code>代理方法<code>heightForRowAtIndexPath</code>，它的实现如下：</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static CodeLayoutCell *singleCell = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
    //这里持有一个cell是为了下面自动计算cell高度的需要
        singleCell = [tableView dequeueReusableCellWithIdentifier:kCellIdentifier];
    });
    //取出Model，如果有缓存的高度值就不计算了
    CellModel *model = _dataSourceArray[indexPath.row];
    if (model.cacheHeight != 0) {
        return model.cacheHeight;
    }
    [singleCell layoutIfNeeded];//强制布局，得到contentView的宽度
    [singleCell setNewCellModel:model];
    //由系统根据我们设定的Layout规则来计算cell显示的Size
    CGSize size = [singleCell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
    model.cacheHeight = size.height + 1;//cell和cell.contentView的高度相差1

    return model.cacheHeight;
}  
</code></pre>

<p>运行的效果如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxuuzclg208u0d51kx.gif" alt="image" /></p>

<p>当图片的高度大于三个<code>UIlabel</code>加上各自上下的间隔的高度时，由于我们设置了三个Label的<code>内容吸附</code>最高的优先级，所以为了满足它们的高度，图片的内容就进行了压缩，如下:</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxtyebuj208w0dbdhk.jpg" alt="image" /></p>

<p>第二个cell的图片被压缩了，如何才能保证它不被压缩呢？留给读到这里的人自己实现吧！😄</p>

<p>暂时先写到这里吧，由于刚接触这两个属性，难免会有遗误之处，请大家多多谅解！</p>

<p>完整的Demo，请戳<a href="https://github.com/liangwei518/AutolayoutDemo1">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Layout使用小技巧]]></title>
    <link href="http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao/"/>
    <updated>2015-11-22T22:58:51+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<p>目前由于Apple自己的Auto Layout写法比较啰嗦，所以出现了许多对原生语句进行封装的第三方开发库，这其中<code>Masonry</code>广受开发者的喜爱，所以以下都以<code>Masonry</code>来做演示说明，但对于Apple原生的写法也同样适用。</p>

<h3>1、图片+文字居中显示</h3>

<p>很多时候我们都会遇到这样的需求：一张图片旁边接上一段文字，然后让他们相对于父视图居中显示，以前我的做法是先知道图片的尺寸，然后来计算他们相对于父视图中心的偏移量，再进行布局。需求的样式大致如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4nyp8qbj208w014a9v.jpg" alt="大致效果" /></p>

<p>但是这样的缺点是每次都需要去据算距离中心的偏移量，很麻烦，对于这种情况其实可以添加一个辅助视图，让这个辅助视图的左边等于图片的左边，右边和文字的右边对齐，然后这个辅助视图相对于父视图居中显示就行。</p>

<!--more-->


<pre><code>- (void)layoutImageAndText {
UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"av_colum"]];
[self.view addSubview:imageView];
[imageView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(@10);
    make.left.greaterThanOrEqualTo(self.view);
}];

UILabel *label = [UILabel new];
label.text = @"梁朝伟";
label.font = [UIFont systemFontOfSize:17];
label.textAlignment = NSTextAlignmentLeft;
label.backgroundColor = [UIColor clearColor];
[self.view addSubview:label];
[label mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView.mas_right).offset(5);
    make.centerY.equalTo(imageView);
}];

UIView *limitView = [UIView new];
[self.view addSubview:limitView];
[limitView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView);//和图片左边对齐
    make.right.equalTo(label);//和文字右边对齐
    make.centerX.equalTo(self.view);//指定limitView居中显示
}];
}
</code></pre>

<h3>2、处理复合型布局</h3>

<p>直接上图说明需求，页面上有四个可见的视图：红、绿、蓝三个<code>UIView</code>，最下面是一个<code>UIButton</code>,想要达到的效果是点击button触发事件将中间的绿色视图隐藏，下面的蓝色视图和button移动到红色视图下，我们想要的效果如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4nz1i8hg208p0bjmxi.gif" alt="需要的效果" /></p>

<p>如果只是将中间的绿色的视图hidden掉，是达不到这样的效果的：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eya4nza0mfj208w0a8748.jpg" alt="影藏中间的绿色视图" /></p>

<p>要达到这样的效果可以利用<code>MASConstraint</code>的<code>deactivate</code>和<code>activate</code>方法，他们的作用是让一个constraint<strong>不生效</strong>和<strong>生效</strong>，<code>Masonry</code>的每个Constraint都会产生一个<code>MASConstraint</code>，所以我们可以保存一些需要改变的constraint，在需要的时候使用这两个方法。</p>

<pre><code>//.h
@interface ViewController ()

@property (nonatomic, strong) UIView *greenView;
@property (nonatomic, strong) MASConstraint *gHeightConstraint;//保存关键的constraint

@end
//.m
@implementation ViewController

- (void)testComplexLayout {
NSNumber *viewHeight = @80;
UIView *redView = [UIView new];
redView.backgroundColor = [UIColor redColor];
[self.view addSubview:redView];
[redView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.left.right.equalTo(self.view);
    make.height.equalTo(viewHeight);
}];

_greenView = [UIView new];
[self.view addSubview:_greenView];
[_greenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.right.equalTo(redView);
    make.top.equalTo(redView.mas_bottom);
    self.gHeightConstraint = make.height.equalTo(@0).priorityHigh();//设为高优先级，首先满足它的需求
}];
[self.gHeightConstraint deactivate];//最开始让它不生效，就是高为0的限制暂不生效
_greenView.clipsToBounds = YES;//不显示超过bounds本身的部分，因为在它里面加了subView
//subGreenView是真实的显示绿色部分，它添加在greenView上
UIView *subGreenView = [UIView new];
subGreenView.backgroundColor = [UIColor greenColor];
[_greenView addSubview:subGreenView];
[subGreenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.edges.equalTo(self.greenView).priorityLow();
    make.height.equalTo(viewHeight);
}];

UIView *blueView = [UIView new];
blueView.backgroundColor = [UIColor blueColor];
[self.view addSubview:blueView];
[blueView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.height.left.right.equalTo(redView);
    make.top.equalTo(self.greenView.mas_bottom);
}];

UIButton *hiddenButton = [UIButton buttonWithType:UIButtonTypeCustom];
[hiddenButton setTitle:@"影藏中间的View" forState:UIControlStateNormal];
[hiddenButton addTarget:self action:@selector(hiddenAction:) forControlEvents:UIControlEventTouchUpInside];
[hiddenButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
[self.view addSubview:hiddenButton];
[hiddenButton mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.equalTo(self.view);
    make.top.equalTo(blueView.mas_bottom).offset(40);
}];
}

static bool isActive = NO;
- (void)hiddenAction:(id)sender {
if (isActive) {
    [_gHeightConstraint deactivate];
} else {
    [_gHeightConstraint activate];
}
//动画展示
[UIView animateWithDuration:.25 animations:^{
    [self.view layoutIfNeeded];
}];

isActive = !isActive;
}
</code></pre>

<h3>3、Preview的使用</h3>

<p>这段时间在学习storyBoard相关的一些知识，RW上的两篇文章：<a href="http://www.raywenderlich.com/50308/storyboards-tutorial-in-ios-7-part-1">Part1</a>和<a href="http://www.raywenderlich.com/50310/storyboards-tutorial-in-ios-7-part-2">Part2</a>非常适合初学者学习，已经有人翻译成了中文<a href="http://www.cocoachina.com/industry/20131213/7537.html">Part1</a>，<a href="http://blog.sina.com.cn/s/blog_5c5c87d80101dzyh.html">Part2</a>。</p>

<p><code>Xcode</code>提供了一个很重要的功能<code>Preview</code>。当我们在<code>Storyboard</code>上使用<code>Auto Layout</code>上进行布局以后，由于目前的画布<code>canvas</code>已经没有尺寸的概念，我们布局完成后需要在3.5、4.0、4.7、5.5英寸的设备上测试，如果支持旋转或者支持iPad，一个效果我们会build多次在不同的设备上查看效果。非常的麻烦，但是有了<code>Preview</code>后一切都变得简单起来。
使用<code>Preview</code>的步奏如下：</p>

<p>1、选中<code>Main.storyboard</code>,如下图所示，选取的时候按下<code>option+shift</code>按键。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eya4nzk6ywj20b204p74o.jpg" alt="选择storyboard" /></p>

<p>2、选取<code>Preview</code>后会出来如下的界面，选择界面右边的<code>+</code>号，按<code>回车</code>。</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eya4nzzeuxj20bc05daae.jpg" alt="image" /></p>

<p>3、通过步骤<code>2</code>后，会出现以下的界面：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4o08srqj20f70gh0t6.jpg" height="520" width="500" alt="Preview界面" /></p>

<p>关键的几个地方我都用红方框圈了起来，左下角的<code>+</code>能模拟不同的设备，中间的红框部位可以模拟设备的旋转，
右下角的<code>English</code>部位可以模拟布局中的文学信息双倍后的布局表现，这几个功能都非常的方便。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App中拨打电话一点小总结]]></title>
    <link href="http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-%5B%3F%5D-dian-xiao-zong-jie/"/>
    <updated>2015-08-23T12:27:08+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-[?]-dian-xiao-zong-jie</id>
    <content type="html"><![CDATA[<h3>App内发起电话拨打的一点小技巧</h3>

<h4>一、拨打电话</h4>

<p>在App内发起电话拨打主要有两种方式：</p>

<p>1、利用这种方式发起的电话拨打，通话结束后不会直接返回App内，而是停留在通信录里面：</p>

<pre><code> NSString *str = [[NSString alloc] initWithFormat:@"tel:%@",@"131xxxx1909"];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:str]];
</code></pre>

<!--more-->


<p>2、利用<code>UIWebView</code>实现电话拨打，会弹出拨打提示，并且拨打完成后会返回App内：</p>

<pre><code>NSString *phone = @"131****1909";
NSString *cleanedString =[[phone componentsSeparatedByCharactersInSet:[[NSCharacterSet characterSetWithCharactersInString:@"0123456789-+()"] invertedSet]] componentsJoinedByString:@""];
NSString *escapedPhoneNumber = [cleanedString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSURL *telURL = [NSURL URLWithString:[NSString stringWithFormat:@"tel://%@",escapedPhoneNumber]];
UIWebView *mCallWebview = [[UIWebView alloc] init] ;

[self.view addSubview:mCallWebview];
[mCallWebview loadRequest:[NSURLRequest requestWithURL:telURL]];
</code></pre>

<h4>二、检测通话时间</h4>

<p>利用<code>CTCallCenter</code>我们可以检测在使用App期间拨打电话出去以及电话打入的时机，以及通话结束的时机。实现如下：</p>

<pre><code> #import &lt;CoreTelephony/CTCallCenter.h&gt;
 #import &lt;CoreTelephony/CTCall.h&gt;

 @interface AppDelegate : UIResponder&lt;UIApplicationDelegate&gt;
 @property (nonatomic, strong) CTCallCenter *callCenter;
 @end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.callCenter = [[CTCallCenter alloc] init];
  [self handleCall];
  return YES;
}

-(void)handleCall
{
   self.callCenter.callEventHandler = ^(CTCall *call) {
    if ([call.callState isEqualToString: CTCallStateConnected])
    {
        NSLog(@"接通电话");
    }
    else if ([call.callState isEqualToString: CTCallStateDialing])
    {
        NSLog(@"发起呼叫");
    }
    else if ([call.callState isEqualToString: CTCallStateDisconnected])
    {
        NSLog(@"结束电话");
    }
    else if ([call.callState isEqualToString: CTCallStateIncoming])
    {
        NSLog(@"打入电话");
    }
   };
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode控制台打印CGRect]]></title>
    <link href="http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect/"/>
    <updated>2015-06-15T21:15:58+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect</id>
    <content type="html"><![CDATA[<p>在用Xcode调试开发的时候，我们经常需要在控制台打印某个视图的frame，以前的时候相当麻烦，但是从Xcode6.3以后，打印frame变得很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Before
</span><span class='line'>(lldb) p (CGRect) [self frame]
</span><span class='line'>(CGRect) $0 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span><span class='line'> 
</span><span class='line'>// After
</span><span class='line'>(lldb) expr @import UIKit
</span><span class='line'>(lldb) p self.frame
</span><span class='line'>(CGRect) $1 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking2.0使用心得]]></title>
    <link href="http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de/"/>
    <updated>2015-05-13T13:56:23+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de</id>
    <content type="html"><![CDATA[<p>这段时间要将公司项目中的网络引擎由<a href="http://allseeing-i.com/ASIHTTPRequest/">ASIHTTPRequest</a>替换为<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>,替换的过程比较曲折，在此记录下自己替换过程中得心得：</p>

<h3>1、建立数据请求中介者</h3>

<p>建立<code>中介者</code>是指项目中的数据请求都通过它去实现，而不是每一个数据请求都直接与<code>AFNetworking</code>打交道，这样做的好处是：</p>

<ul>
<li>将网络请求与第三方库依赖隔离开来，方便以后对第三方库的替换。</li>
<li>方便处理网络请求的公共逻辑。</li>
</ul>


<!--more-->


<h3>2、使用completionQueue</h3>

<p>默认情况下<code>AFURLConnectionOperation</code>或者<code>AFHTTPRequestOperation</code>请求结束以后会在主线程将结果传递回来，如果你要将请求的结果做一些耗时的复杂的处理，就会<em>block</em>住主线程，所以这种情况下你就需要对请求的Operation传递<code>completionQueue</code>参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperation *request = [[AFHTTPRequestOperation alloc] initWithRequest:urlrequest];
</span><span class='line'>
</span><span class='line'>request.responseSerializer = [AFJSONResponseSerializer serializer];
</span><span class='line'>//设置回调的queue，默认是在mainQueue执行block回调
</span><span class='line'>request.completionQueue = your_request_operation_completion_queue();
</span><span class='line'>[request setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>         //设置了'completionQueue'后，就可以在这里处理复杂的逻辑
</span><span class='line'>         //不用担心block住了主线程
</span><span class='line'>    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>
</span><span class='line'> }];
</span><span class='line'> [request start];
</span></code></pre></td></tr></table></div></figure>


<h3>3、如何知道AFHTTPRequestOperationManager执行完成</h3>

<p>开始以为直接设置<code>AFHTTPRequestOperationManager</code>的<em>completionGroup</em>，然后利用<code>dispatch_group_notify</code>来获取operationQueue执行结束的通知，最后才发现，这样根本不行，看了源码才知道：<code>AFHTTPRequestOperationManager</code>直接将<em>completionGroup</em>赋值给了他的每一个<em>operation</em>，在<em>operation</em>的completionBlock里面利用<em>completionGroup</em>，来确保在operation的处理完成后，将completionBlock置为nil，防止循环引用。</p>

<p>虽然说这样不能知道<code>AFHTTPRequestOperationManager</code>什么时候执行完成，但是生活还得继续下去啊！在<code>AFURLConnectionOperation</code>中有一个方法叫：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSArray *)batchOfRequestOperations:(NSArray *)operations
</span><span class='line'>                        progressBlock:(void (^)(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations))progressBlock
</span><span class='line'>                      completionBlock:(void (^)(NSArray *operations))completionBlock;
</span></code></pre></td></tr></table></div></figure>


<p>这个方法就是能够发一组请求，跟<code>AFHTTPRequestOperationManager</code>比起来的缺点就是没法设置并发数，但是它却能实现检测一组请求什么时候结束，能检测完成了多少请求，它是怎么做到的呢？</p>

<p>原来他也是利用<strong>dispatch_group_async</strong>和<strong>dispatch_group_notify</strong></p>

<p>一般的我们要把一个任务加入一个group里是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    block();
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这个写法等价于</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(queue, ^{
</span><span class='line'>    dispatch_group_enter(group);
</span><span class='line'>    block()
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>如果要把一个异步任务加入group，这样就行不通了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    [self performBlock:^(){
</span><span class='line'>        block();
</span><span class='line'>    }];
</span><span class='line'>    //未执行到block() group任务就已经完成了
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这是就需要用到<code>batchOfRequestOperations</code>里的实现了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_enter(group);
</span><span class='line'>[self performBlock:^(){
</span><span class='line'>    block();
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>}];
</span></code></pre></td></tr></table></div></figure>


<p>其实这个和引用计数差不多，<em>dispatch_group_enter</em>时引用计数+1，<em>dispatch_group_leave</em>时引用计数-1，引用计数为0时执行<em>dispatch_group_notify</em>的内容。具体过程大致如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperationManager *downloadManager = [AFHTTPRequestOperationManager manager];
</span><span class='line'>    //设置最大并发数
</span><span class='line'>    [downloadManager.operationQueue setMaxConcurrentOperationCount:([NSProcessInfo processInfo].processorCount) * 2];
</span><span class='line'>    //创建一个group
</span><span class='line'>    __block dispatch_group_t group = dispatch_group_create();
</span><span class='line'>    for (NSURL *url in urlArray) {
</span><span class='line'>        NSURLRequest *requestUrl = [NSURLRequest requestWithURL:url];
</span><span class='line'>        AFHTTPRequestOperation *requestOperation = [[AFHTTPRequestOperation alloc] initWithRequest:requestUrl];
</span><span class='line'>        [requestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        }];
</span><span class='line'>        //将请求加入队列中
</span><span class='line'>        [downloadManager.operationQueue addOperation:requestOperation];
</span><span class='line'>        dispatch_group_enter(group);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
</span><span class='line'>        //全部请求完成
</span><span class='line'>        
</span><span class='line'>    });  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>4、实现断点续传</h3>

<p><code>AFNetworking</code>虽然支持文件下载的暂停和继续，但是当缓存清空重新启动时，它并没有记录下下载的状态，无法续传，但是可以通过<a href="http://https://github.com/steipete/AFDownloadRequestOperation">AFDownloadRequestOperation</a>来简单的实现，其实过程也不是很复杂，大致如下，感兴趣的朋友可以阅读<code>AFDownloadRequestOperation</code>是实现部分：</p>

<p>1、设置<code>AFHTTPRequestOperation</code>的请求<code>NSMutableURLRequest</code><em>HTTPHeader</em>的<strong>Range</strong>字段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableURLRequest *mutableURLRequest = [self.request mutableCopy];
</span><span class='line'>//offset是指断点续传文件已经下载的大小
</span><span class='line'>[mutableURLRequest setValue:[NSString stringWithFormat:@"bytes=%llu-", offset] forHTTPHeaderField:@"Range"];</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>2、设置<code>AFHTTPRequestOperation</code>的<em>outputStream</em>属性。</p>

<pre><code class="` "> //downloadPath是指文件下载存放的路径
downloadOperation.outputStream = [NSOutputStream outputStreamToFileAtPath:downloadPath append:YES];
</code></pre>

<h3>结尾</h3>

<p>对于<code>ASIHTTPRequest</code>和<code>AFNetworking</code>的比较网上有很多很好的文章，一搜一大把，对于普通的使用来说感觉区别不大，请求速度什么的也没什么感觉，以上若有错误，还望大家多多
指正😃。</p>
]]></content>
  </entry>
  
</feed>
