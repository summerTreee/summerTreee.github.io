<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[夏树正茂]]></title>
  <link href="http://summertreee.github.io/atom.xml" rel="self"/>
  <link href="http://summertreee.github.io/"/>
  <updated>2016-09-07T19:49:18+08:00</updated>
  <id>http://summertreee.github.io/</id>
  <author>
    <name><![CDATA[梁炜V]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Nullable和__kindof的使用]]></title>
    <link href="http://summertreee.github.io/blog/2016/08/15/nullablehe-kindof/"/>
    <updated>2016-08-15T10:59:30+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/08/15/nullablehe-kindof</id>
    <content type="html"><![CDATA[<h3>nullable和__kindof的使用记录</h3>

<p>2015年的WWDC里面介绍了几个新的关键字：<code>__kindof</code>和<code>nullable</code>。如果能很好的使用它们，编译器在我们犯错误的时候就能给予我们提示，将bug扼杀在摇篮里。</p>

<!--more-->


<h5>__kindof</h5>

<p><code>__kindof</code>关键字的使用很简单，直接上一个示例代码就能说明白：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray&lt;UIView *&gt; *subviews = [[NSMutableArray alloc] init];
</span><span class='line'>
</span><span class='line'>[subviews addObject:[[UIView alloc] init]]; // Works
</span><span class='line'>[subviews addObject:[[UIImageView alloc] init]]; // Also works
</span><span class='line'>
</span><span class='line'>UIView *sameView = subviews[0]; // Works
</span><span class='line'>UIImageView *sameImageView = subviews[1]; // Incompatible pointer types initializing 'UIImageView *' with an expression of type 'UIView *'
</span><span class='line'>
</span><span class='line'>NSLog(@"%@", NSStringFromClass([sameView class])); // UIView
</span><span class='line'>NSLog(@"%@", NSStringFromClass([sameImageView class])); // UIImageView
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>上面的代码在编译的时候会给出警告，运行的时候不会crash，下面是使用<code>__kindof</code>的示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableArray&lt;__kindof UIView *&gt; *subviews = [[NSMutableArray alloc] init];
</span><span class='line'>
</span><span class='line'>[subviews addObject:[[UIView alloc] init]]; // Works
</span><span class='line'>[subviews addObject:[[UIImageView alloc] init]]; // Also works
</span><span class='line'>
</span><span class='line'>UIView *sameView = subviews[0]; // No problem
</span><span class='line'>UIImageView *sameImageView = subviews[1]; // No complaints now!
</span><span class='line'>
</span><span class='line'>NSLog(@"%@", NSStringFromClass([sameView class])); // UIView
</span><span class='line'>NSLog(@"%@", NSStringFromClass([sameImageView class])); // UIImageView
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>可以看到在使用了<code>__kindof</code>关键字后，不在有编译警告了，所以对于<code>Objective-C</code>新提供的这个关键字来说，它可以限定返回值或者参数以及像我们例子中的这种泛型的类型，要么是这种类型本身的类型，要么是它的subClass，反之就会给出警告。</p>

<h5>nullable、_Nullable、__nullable</h5>

<p>这些关键字可以限定参数或者返回值可以空。它们的作用相同，但是也有细微的使用差别。</p>

<ol>
<li><strong>_Nullable</strong>是<strong>Xcode7</strong>以后用来替代<strong>__nullable</strong>的，所以能使用<strong>__nullable</strong>的地方就可以使用<strong>_Nullable</strong>。</li>
<li><strong>nullable</strong>放在类型之前，<strong>_Nullable</strong>放在类型之后。</li>
</ol>


<p>以下的示例都是正确并且作用都是等价的：</p>

<p>1、修饰返回值：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (nullable NSNumber *)result
</span><span class='line'>- (NSNumber * __nullable)result
</span><span class='line'>- (NSNumber * _Nullable)result
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>2、修饰参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)doSomethingWithString:(nullable NSString *)str
</span><span class='line'>- (void)doSomethingWithString:(NSString * _Nullable)str
</span><span class='line'>- (void)doSomethingWithString:(NSString * __nullable)str
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>3、修饰property：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@property(nullable) NSNumber *status
</span><span class='line'>@property NSNumber *__nullable status
</span><span class='line'>@property NSNumber * _Nullable status
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>4、修饰指针的指针，不能使用<em>nullable</em>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)compute:(NSError *  _Nullable * _Nullable)error
</span><span class='line'>- (void)compute:(NSError *  __nullable * _Null_unspecified)error
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>5、修饰block：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)executeWithCompletion:(nullable void (^)())handler
</span><span class='line'>- (void)executeWithCompletion:(void (^ _Nullable)())handler
</span><span class='line'>- (void)executeWithCompletion:(void (^ __nullable)())handler
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>6、结论：<br/>
<code>__nullable、_Nullable、nullable</code>以及与它们对应的<code>__nonnull、_Nonnull、nonnull</code>一样，只需要注意它们相对于修饰类型的位置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动画黄金搭档:CADisplayLink&amp;CAShapeLayer]]></title>
    <link href="http://summertreee.github.io/blog/2016/08/07/dong-hua-huang-jin-da-dang-cadisplaylink-and-cashapelayer/"/>
    <updated>2016-08-07T17:36:13+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/08/07/dong-hua-huang-jin-da-dang-cadisplaylink-and-cashapelayer</id>
    <content type="html"><![CDATA[<p>我们在开发中有时会遇到一些看似非常复杂的动画，不知该如何下手，今天的这篇文章中我会讲到如何利用<code>CADisplayLink</code>和<code>CAShapeLayer</code>来构建一些复杂的动画，希望能在你下次构建动画中，给你一些启发。</p>

<p>在接下来的文章中，我们会构建如下的一个动画：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f6lb4ym7ovg207002z3ym.gif" alt="image" /></p>

<p>该动画是在<code>du</code>的轮廓中进行，类似一个镂空效果，轮廓的填充是用双波浪的形式，类似于水流慢慢注入容器的过程。<br/>
动画使用<code>CADisplayLink</code>来进行刷新，保证了动画的流程性，利用<code>CAShapeLayer</code>来构建波浪的轮廓，最后利用<code>CALayer</code>的<code>mask</code>属性来实现逐渐填充的过程。</p>

<!--more-->


<h4>背景知识介绍</h4>

<p>在动画创建过程的讲解之前，先介绍一下会使用到的一些知识点：</p>

<ol>
<li>CADisplayLink</li>
<li>UIBezierPath</li>
<li>CAShapeLayer</li>
<li>mask</li>
</ol>


<p>如果你已经对这些概念有了充分的了解，可以略过<code>背景知识介绍</code>这一节。</p>

<h6>1、CADisplayLink</h6>

<p>用绘制的方式构建的动画，必然需要不断的刷新绘制的内容来呈现流畅的动画，<code>CADisplayLink</code>就像是一个定时器，每隔几毫秒刷新一次屏幕。能让我们以和屏幕刷新频率相同的频率去刷新我们绘制到屏幕上的内容。<br/>
<code>CADisplayLink</code>的使用方式如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  _displayLink = [CADisplayLink displayLinkWithTarget:self
</span><span class='line'>                                            selector:@selector(updateContent:)];
</span><span class='line'>   [_displayLink addToRunLoop:[NSRunLoop currentRunLoop]
</span><span class='line'>                      forMode:NSRunLoopCommonModes];
</span><span class='line'>  
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当<code>CADisplayLink</code>注册到<strong>runloop</strong>以后，屏幕刷新的时候就会调用绑定到它上面的<strong>target</strong>所拥有的<strong>selector</strong>方法。停止<code>CADisplayLink</code>的运行非常的简单，只需要调用它的<code>invalidate</code>方法。</p>

<p><strong>NSTimer和CADisplayLink有什么不同？</strong></p>

<p>iOS设备的屏幕每秒会刷新60次，正常情况下<code>CADisplayLink</code>在屏幕每次刷新时都会调用，精确度非常高，并且<code>CADisplayLink</code>的使用场合相对专一，适合做UI的不停重绘，比如动画的连续绘制。</p>

<p><code>NSTimer</code>的使用范围要广泛很多，可以做单次或者循环处理某个任务，精度相比<strong>CADisplayLink</strong>要低。</p>

<h5>2、UIBezierPath</h5>

<p>使用<code>UIBezierPath</code>类可以创建基于矢量的路径，它是<strong>Core Graphics</strong>框架关于<code>CGPathRef</code>类型数据的封装，利用它创建直线或者曲线来构建我们想要的形状，每一个直线段或者曲线段的结束位置就是下一个线段开始的地方。这些连接的直线或者曲线的集合成为<strong>subpath</strong>。一个<code>UIBezierPath</code>对象的完整路径包括一个或者多个<strong>subpath</strong>。</p>

<p>创建一个完整的<strong>UIBezierPath</strong>对象的完整步骤如下：</p>

<ul>
<li>创建一个Bezier Path对象。</li>
<li>使用方法<strong>moveToPoint:</strong>去设置初始线段的起点。</li>
<li>添加<strong>line</strong>或者<strong>curve</strong>去定义一个或者多个<strong>subpath</strong>。</li>
<li>修改<strong>UIBezierPath</strong>对象跟绘图相关的属性。</li>
</ul>


<h5>3、CAShapeLayer</h5>

<p><code>CAShapeLayer</code>是一个通过矢量图形而不是<strong>bitmap</strong>来绘制的图层子类。<code>CAShapeLayer</code>可以用来绘制所有通过<strong>CGPath</strong>来表示的形状，上面讲到了可以用<code>UIBezierPath</code>来创建任何你想要的路径，使用<code>CAShapeLayer</code>的属性<code>path</code>配合<code>UIBezierPath</code>创建的路径，就可以呈现出我们想要的形状。<br/>
这个形状不一定要闭合，图层路径也不一定是连续不断的，你可以在<code>CAShapeLayer</code>的图层上绘制好几个不同的形状，但是你只有一次机会去设置它的<code>path、lineWith、lineCap</code>等属性，如果你想同时设置几个不同颜色的多个形状，你就需要为每个形状准备一个图层。</p>

<p>下面的示例代码是通过<code>UIBezierPath</code>和<code>CAShapeLayer</code>来创建一个简单的火柴人。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - (void)viewDidLoad {
</span><span class='line'>    [super viewDidLoad];
</span><span class='line'>    
</span><span class='line'>    UIBezierPath *path = [[UIBezierPath alloc] init];
</span><span class='line'>    [path moveToPoint:CGPointMake(175, 100)];
</span><span class='line'>    
</span><span class='line'>    [path addArcWithCenter:CGPointMake(150, 100) radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES];
</span><span class='line'>    [path moveToPoint:CGPointMake(150, 125)];
</span><span class='line'>    [path addLineToPoint:CGPointMake(150, 175)];
</span><span class='line'>    [path addLineToPoint:CGPointMake(125, 225)];
</span><span class='line'>    [path moveToPoint:CGPointMake(150, 175)];
</span><span class='line'>    [path addLineToPoint:CGPointMake(175, 225)];
</span><span class='line'>    [path moveToPoint:CGPointMake(100, 150)];
</span><span class='line'>    [path addLineToPoint:CGPointMake(200, 150)];
</span><span class='line'>    
</span><span class='line'>    //create shape layer
</span><span class='line'>    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
</span><span class='line'>    shapeLayer.strokeColor = [UIColor colorWithRed:147/255.0 green:231/255.0 blue:182/255.0 alpha:1].CGColor;
</span><span class='line'>    shapeLayer.fillColor = [UIColor clearColor].CGColor;
</span><span class='line'>    shapeLayer.lineWidth = 5;
</span><span class='line'>    shapeLayer.lineJoin = kCALineJoinRound;
</span><span class='line'>    shapeLayer.lineCap = kCALineCapRound;
</span><span class='line'>    shapeLayer.path = path.CGPath;
</span><span class='line'>    //add it to our view
</span><span class='line'>    [self.view.layer addSublayer:shapeLayer];
</span><span class='line'>}  
</span></code></pre></td></tr></table></div></figure>


<p>
显示的形状如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0gw1f6lb4z3e4oj209y0aqglo.jpg" alt="image" /></p>

<h5>4、mask</h5>

<p><code>CALayer</code>有一个属性叫做<code>mask</code>，通常被称为蒙版图层，这个属性本身也是<strong>CALayer</strong>类型，有和其他图层一样的绘制和布局属性。它类似于一个子视图，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子视图。不同于一般的<strong>subLayer</strong>，<code>mask</code>定义了父图层的可见区域，简单点说就是最终父视图显示的形态是父视图自身和它的属性<code>mask</code>的交集部分。</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f6lb50rgqbj20go06mwet.jpg" alt="image" /></p>

<p><code>mask</code>图层的<strong>color</strong>属性是无关紧要的，真正重要的是它的轮廓，<code>mask</code>属性就像一个切割机，父视图被<code>mask</code>切割，相交的部分会留下，其他的部分则被丢弃。<br/>
<strong>CALayer</strong>的蒙版图层真正厉害的地方在于蒙版图层不局限于静态图，任何有图层构成的都可以作为<code>mask</code>属性，这意味着蒙版可以通过代码甚至是动画实时生成。这也为我们实现示例中波浪的变化提供了支持。</p>

<h4>绘制波浪轮廓</h4>

<p>我们利用<code>UIBezierPath</code>来绘制波浪的轮廓，通过正弦函数和余弦函数来创建顶部的波浪曲线，在单位为1的右手直角坐标系中的曲线变化如下：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f6lb51vscuj20v007sq4f.jpg" alt="image" /></p>

<p>可以看到在<strong>(-2π , 2π )</strong>的范围类，<code>y</code>值在<code>[-1, 1]</code>之间变化。<br/>
以正弦曲线为例，它可以表示为<code>y=Asin(ωx+φ)+k</code>，公式中各符号表示的含义：</p>

<ul>
<li><strong>A</strong>&ndash;振幅，即波峰的高度。</li>
<li><strong>(ωx+φ)</strong>&ndash;相位，反应了变量<em>y</em>所处的位置。</li>
<li><strong>φ</strong>&ndash;初相，<em>x=0</em>时的相位，反映在坐标系上则为图像的左右移动。</li>
<li><strong>k</strong>&ndash;偏距，反映在坐标系上则为图像的上移或下移。</li>
<li><strong>ω</strong>&ndash;角速度，控制正弦周期(单位角度内震动的次数)。</li>
</ul>


<p>通过上面的函数，我们就能计算出波浪曲线上任意位置的坐标点。通过<code>UIBezierPath</code>的函数<code>addLineToPoint</code>来把这些点连接起来，就构建了波浪形状的<strong>path</strong>。只要我们的设定相邻两点的间距够小，就能构建出平滑的正弦曲线，构建正弦波浪的代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - (UIBezierPath *)createSinPath
</span><span class='line'>{
</span><span class='line'>    UIBezierPath *wavePath = [UIBezierPath bezierPath];
</span><span class='line'>    CGFloat endX = 0;
</span><span class='line'>    for (CGFloat x = 0; x &lt; self.waveWidth + 1; x += 1) {
</span><span class='line'>        endX=x;
</span><span class='line'>        CGFloat y = self.maxAmplitude * sinf(360.0 / _waveWidth * (x  * M_PI / 180) * self.frequency + self.phase * M_PI/ 180) + self.maxAmplitude;
</span><span class='line'>        if (x == 0) {
</span><span class='line'>            [wavePath moveToPoint:CGPointMake(x, y)];
</span><span class='line'>        } else {
</span><span class='line'>            [wavePath addLineToPoint:CGPointMake(x, y)];
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    CGFloat endY = CGRectGetHeight(self.bounds) + 10;
</span><span class='line'>    [wavePath addLineToPoint:CGPointMake(endX, endY)];
</span><span class='line'>    [wavePath addLineToPoint:CGPointMake(0, endY)];
</span><span class='line'>    
</span><span class='line'>    return wavePath;
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>显示的效果如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0gw1f6lb53gapqj20jg06ejrc.jpg" alt="image" /></p>

<p>在这里我们设定了两个正弦曲线上的点的横坐标间距是<strong>1</strong>，现在来解释一下通过横坐标<strong>x</strong>来得出<strong>y</strong>的计算过程：</p>

<pre><code>y = self.maxAmplitude * sinf(360.0 / _waveWidth * (x  * M_PI / 180) * self.frequency + self.phase * M_PI/ 180) + self.maxAmplitude;  
</code></pre>

<p>第一个<code>self.maxAmplitude</code>表示曲线的波峰值，<code>360.0 / _waveWidth</code>计算出单位间距<strong>1pixel</strong>代表的度数，<code>x  * M_PI / 180</code>表示将横坐标值转换为角度。<code>self.frequency</code>表示角速度，即单位面积内波动次数，波浪的大小。<code>self.phase * M_PI/ 180</code>代表上面公式中的初相，通过规律的变化初相，可以制造出曲线上的点动起来的效果，<code>self.maxAmplitude</code>代表偏距，由于我们需要让波浪曲线的波峰在<code>layer</code>的范围内显示，所以需要将整个曲线向下移动波峰大小的单位，因为<code>CALayer</code>使用左手坐标系，所以向下移动需要加上波峰的大小。</p>

<h4>让波浪曲线动起来</h4>

<p>正弦或者余弦曲线上的点，不论角度如何，在<strong>y</strong>轴上的变化范围在它的波峰与波谷之间。拿单位正交直角坐标系来说，只要我们规律性的增加角度值，那么曲线上的点就会在<strong>[1, -1]</strong>之间变化，我们以曲线上<strong>x=0</strong>的点为例，角度的不断增加，会让它的<strong>y</strong>值规律性的来回变化：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f6lb548i4ig205304idft.gif" alt="image" /></p>

<p>如若曲线上的点都能这样规律的变化，我们就能让波浪曲线浪起来。<br/>
要让曲线上所有的点都动起来，在这里我们使用<code>CADisplayLink</code>来不断刷新由<code>UIBezierPath</code>创建的形状，两次刷新之间曲线的变化通过增加初相来实现，代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)startLoading
</span><span class='line'>{
</span><span class='line'>    [_displayLink invalidate];
</span><span class='line'>    self.displayLink = [CADisplayLink displayLinkWithTarget:self
</span><span class='line'>                                                   selector:@selector(updateWave:)];
</span><span class='line'>    [_displayLink addToRunLoop:[NSRunLoop currentRunLoop]
</span><span class='line'>                       forMode:NSRunLoopCommonModes];
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)updateWave:(CADisplayLink *)displayLink
</span><span class='line'>{
</span><span class='line'>    self.phase += 8;//逐渐累加初相
</span><span class='line'>    self.waveSinLayer.path = [self createSinPath].CGPath;
</span><span class='line'>}
</span><span class='line'>  
</span><span class='line'>- (UIBezierPath *)createSinPath
</span><span class='line'>{
</span><span class='line'>    UIBezierPath *wavePath = [UIBezierPath bezierPath];
</span><span class='line'>    CGFloat endX = 0;
</span><span class='line'>    for (CGFloat x = 0; x &lt; self.waveWidth + 1; x += 1) {
</span><span class='line'>        endX=x;
</span><span class='line'>        CGFloat y = self.maxAmplitude * sinf(360.0 / _waveWidth * (x  * M_PI / 180) * self.frequency + self.phase * M_PI/ 180) + self.maxAmplitude;
</span><span class='line'>        if (x == 0) {
</span><span class='line'>            [wavePath moveToPoint:CGPointMake(x, y)];
</span><span class='line'>        } else {
</span><span class='line'>            [wavePath addLineToPoint:CGPointMake(x, y)];
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    CGFloat endY = CGRectGetHeight(self.bounds) + 10;
</span><span class='line'>    [wavePath addLineToPoint:CGPointMake(endX, endY)];
</span><span class='line'>    [wavePath addLineToPoint:CGPointMake(0, endY)];
</span><span class='line'>    
</span><span class='line'>    return wavePath;
</span><span class='line'>} 
</span><span class='line'>  
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>把<code>CAShapeLayer</code>的背景色设置为淡红色，波浪曲线会在<code>Layer</code>的<strong>bounds</strong>类波动，动起来的波浪曲线如下：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f6lb55j45eg208r021dg0.gif" alt="image" /></p>

<h4>构建波浪上升的镂空效果</h4>

<p>到目前为止，我们利用<code>CAShapeLayer</code>、<code>UIBezierPath</code>以及<code>CADisplayLink</code>实现了动起来的波浪效果，下面我们需要实现的是在<code>du</code>的轮廓里，水波不断上升填充的过程，整个动画过程中，会呈现一个<code>du</code>的镂空效果，在它轮廓之外的水波则不会显示，这样的效果需要借助<code>CALayer</code>的<code>mask</code>属性来实现。</p>

<p>我们需要的动画素材如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0gw1f6lb55xrpgj20bm04iaa5.jpg" alt="image" /></p>

<p>将这三个图片位置设置为一样，底层放置动画中一直显示的底层轮廓，中间层用以实现余弦波浪，最外层用于实现正弦波浪，将中间层和最外层图片的<code>mask</code>属性赋值为我们创建的用来呈现余弦波浪和正弦波浪的<code>CAShapeLayer</code>，这样动画开始后，利用<code>CADisplayLink</code>来不断刷新两个<code>CAShapeLayer</code>的<strong>path</strong>来让波浪浪起来，再利用<code>CABasicAnimation</code>来对两个<code>CAShapeLayer</code>的<code>position</code>进行动画，实现从下到上的填充效果。我们想要的效果就完成了：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f6lb4ym7ovg207002z3ym.gif" alt="image" /></p>

<p>完整的代码示例在<a href="https://github.com/liangwei518/WaterWave">这里</a></p>

<h4>参考</h4>

<ul>
<li><a href="http://blog.csdn.net/crayondeng/article/details/11093689">UIBezierPath</a></li>
<li><a href="http://www.cnblogs.com/YouXianMing/p/3678709.html">CAShapeLayer</a></li>
<li><a href="https://zsisme.gitbooks.io/ios-/content/chapter4/layer-masking.html">图层蒙版</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[布局万花筒：UIColletionview]]></title>
    <link href="http://summertreee.github.io/blog/2016/07/25/bu-ju-mo-hua-tong-:uicolletionview/"/>
    <updated>2016-07-25T13:28:11+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/07/25/bu-ju-mo-hua-tong-:uicolletionview</id>
    <content type="html"><![CDATA[<p><strong>UICollectionView</strong>是iOS6的时候引入的，它同<strong>UITableView</strong>共享一套API设计，都是基于<strong>datasource和delegate</strong>，都继承自<strong>UIScrollView</strong>。但它又与<strong>UITableView</strong>有很大不同，它进行了进一步的抽象，将它的所有子视图的位置、大小、transform委托给了一个单独的布局对象：<code>UICollectionViewLayout</code>。这是一个抽象类，我们可以继承它来实现任何想要的布局，系统也为我们提供了一个开箱即食的实现<code>UICollectionViewFlowLayout</code>。在我看来，没有任何排列布局是<code>UICollectionViewLayout</code>不能实现的，如果有那就自定义一个。</p>

<!--more-->


<p><strong>UITableView</strong>只能提供竖直滑动的布局，而且默认情况下<strong>cell</strong>的宽度和tableView的宽度一致，而且<strong>cell</strong>的排列顺序也是挨次排列。<strong>UICollectionView</strong>则为我们提供了另一种可能：它能提供竖直滑动的布局也能提供水平滑动的布局，而且<strong>cell</strong>的位置、大小等完全由你自己决定。所以我们在遇到水平滑动的布局时，不要忙着用<strong>UIScrollView</strong>去实现，可以先考虑<strong>UICollectionView</strong>能不能满足要求，还有一个好处是你不要自己考虑滑动视图(cell)重用的问题。</p>

<p>这篇文章会讲解如何自定义<code>UICollectionViewLayout</code>来实现任意布局，默认你已经会使用系统提供的<code>UICollectionViewFlowLayout</code>来进行标准的<strong>Grid View</strong>布局了。</p>

<h5>1、UICollectionViewFlowLayout</h5>

<p>系统为我们提供了一个自定义的布局实现：<strong>UICollectionViewFlowLayout</strong>，通过它我们可以实现<strong>Grid View</strong>类型的布局，也就是像一个一个格了挨次排列的布局，对于大多数的情况，使用它就能满足我们的要求了。系统为我们提供了布局所需的参数，我们在使用的时候只需要去确定这些参数就行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  NS_CLASS_AVAILABLE_IOS(6_0) @interface UICollectionViewFlowLayout : UICollectionViewLayout
</span><span class='line'>
</span><span class='line'>@property (nonatomic) CGFloat minimumLineSpacing;
</span><span class='line'>@property (nonatomic) CGFloat minimumInteritemSpacing;
</span><span class='line'>@property (nonatomic) CGSize itemSize;
</span><span class='line'>@property (nonatomic) CGSize estimatedItemSize NS_AVAILABLE_IOS(8_0); // defaults to CGSizeZero - setting a non-zero size enables cells that self-size via -preferredLayoutAttributesFittingAttributes:
</span><span class='line'>@property (nonatomic) UICollectionViewScrollDirection scrollDirection; // default is UICollectionViewScrollDirectionVertical
</span><span class='line'>@property (nonatomic) CGSize headerReferenceSize;
</span><span class='line'>@property (nonatomic) CGSize footerReferenceSize;
</span><span class='line'>@property (nonatomic) UIEdgeInsets sectionInset;
</span><span class='line'>
</span><span class='line'>// Set these properties to YES to get headers that pin to the top of the screen and footers that pin to the bottom while scrolling (similar to UITableView).
</span><span class='line'>@property (nonatomic) BOOL sectionHeadersPinToVisibleBounds NS_AVAILABLE_IOS(9_0);
</span><span class='line'>@property (nonatomic) BOOL sectionFootersPinToVisibleBounds NS_AVAILABLE_IOS(9_0);
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>  
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p><strong>Grid View</strong>样式的<code>UICollectionView</code>如下所示：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1f662t6s0soj20eu0oagmn.jpg" alt="image" /></p>

<p>如果上面所说的<strong>Grid View</strong>类型的布局不能满足我们的需求，这时就需要自定义一个<strong>Layout</strong>。</p>

<h5>2、UICollectionViewLayout VS UICollectionViewFlowLayout</h5>

<p><strong>UICollectionViewFlowLayout</strong>继承自<strong>UICollectionViewLayout</strong>，我们可以直接使用它，我们只需要提供<strong>cell</strong>的大小，以及行间距、列间距，它就会自己计算出每个<strong>cell</strong>的位置以及<strong>UICollectionView</strong>的滑动范围<strong>contentSize</strong>。但它只能提供一个方向的滑动，也就是说我们自定义的类如果继承自<strong>UICollectionViewFlowLayout</strong>，则只能是在一个方向上滑动的布局，要么水平方向要么竖直方向。 反之，则需要继承自<strong>UICollectionViewLayout</strong>，<strong>UICollectionViewLayout</strong>是一个抽象类，不能直接使用。</p>

<h5>3、自定义布局需要实现的方法</h5>

<p><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UICollectionViewLayout_class/index.html">UICollectionViewLayout文档</a>为我们列出了需要实现的方法：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1f662wfm214j20sq0ckmzq.jpg" alt="image" /></p>

<p>以上列出的这六个方法不是都需要我们自己实现的，而是根据需要，选择其中的某些方法实现。</p>

<h6>collectionViewContentSize</h6>

<p><strong>UICollection</strong>继承自<strong>UIScrollView</strong>，我们都知道<strong>UIScrollView</strong>的一个重要参数：<strong>contentSize</strong>,如果这个参数不对，那么你布局的内容就不能完全展示，而<strong>collectionViewContentSize</strong>就是为了得到这个参数，<strong>UICollection</strong>就像一个画板，而<strong>collectionViewContentSize</strong>则规定了画板的大小，如果是继承自<strong>UICollectionViewFlowLayout</strong>，而且每个<strong>section</strong>里面的cell大小是通过UICollectionViewFlowLayout的参数设定的，大小和位置也不在自定义的过程中随意更改，那么<em>collectionViewContentSize</em>是可以不自己重写的，系统会自己计算<strong>contentSize</strong>，如果是继承自<strong>UICollectionViewLayout</strong>，那就需要根据你自己的展示布局去提供合适的CGSize给<strong>collectionViewContentSize</strong>。</p>

<h5>layoutAttributesForElementsInRect</h5>

<p>这个方法的参数是<strong>UICollectionView</strong>当前的<strong>bounds</strong>，也就是视图当前的可见区域，返回值是一个包含对象为<strong>UICollectionViewLayoutAttributes</strong>的数组，<strong>UICollectionView</strong>的可见区域内包含<code>cell、supplementary view、decoration view</code>(这里统称cell，因为它们都是collectionView的一个子视图)，它们的位置、大小等信息都由对应的<strong>UICollectionViewLayoutAttributes</strong>控制。默认情况下这个<strong>LayoutAttributes</strong>包含indexPath、frame、center、size、transform3D、alpha以及hidden属性。如果你还需要控制其他的属性，你可以自己自定义一个<strong>UICollectionViewLayoutAttributes</strong>的子类，加上任意你想要的属性。</p>

<p>布局属性对象(UICollectionViewLayoutAttributes)通过<strong>indexPath</strong>和<strong>cell</strong>关联起来，当<strong>collectionView</strong>展示<strong>cell</strong>时，会通过这些布局属性对象拿到布局信息。</p>

<p>返回原话题，<strong>layoutAttributesForElementsInRect</strong>方法的返回值是一个数组，这个数组里面是传递进来的可见区域内的<strong>cell</strong>所对应的<strong>UICollectionViewLayoutAttributes</strong>。</p>

<p>要拿到可见区域内的布局属性，通常的做法如下：<br/>
1、如果你是继承自<strong>UICollectionViewFlowLayout</strong>，并且设置好了itemSize、行间距、列间距等信息，那么你通过<code>[super layoutAttributesForElementsInRect:rect]</code>就能拿到可见区域内的布局属性，反之，则进入步奏2。<br/>
2、创建一个空数组，用于存放可见区域内的布局属性。<br/>
3、从<strong>UICollectionView</strong>的数据源中取出你需要展示的数据，然后根据你想要的布局计算出哪些<strong>indexPath</strong>在当前可见区域内，通过<code>CGRectIntersectsRect</code>函数可以判断两个<code>CGRect</code>是否有交集来确定。然后循环调用<code>layoutAttributesForItemAtIndexPath:</code>来确定每一个布局属性的frame等数据。同样，如果当前区域内有<code>supplementary view</code>或者<code>decoration view</code>，你也需要调用：<code>layoutAttributesForSupplementaryViewOfKind:atIndexPath</code>或者<code>layoutAttributesForDecorationViewOfKind:atIndexPath</code>，最后将这些布局属性添加到数组中返回。这里需要多说一点的是，有些布局属性在<strong>UICollectionViewLayout</strong>的<code>prepareLayout</code>就根据数据源全部计算了出来，比如瀑布流样式的布局，这个时候你就只需要返回布局属性的frame和当前可见区域有交集的对象就行。</p>

<h6>layoutAttributesFor…IndexPath</h6>

<p>这里用三个点，是因为有三个类似的方法:</p>

<ul>
<li>layoutAttributesForItemAtIndexPath:</li>
<li>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</li>
<li>layoutAttributesForDecorationViewOfKind:atIndexPath:</li>
</ul>


<p>它们分别为<strong>cell、supplementaryView、decorationView</strong>返回布局属性，它们的实现不是必须的，它们只是为对应的<code>IndexPath</code>返回布局属性，如果你能通过其他方法拿到对应<code>indexPath</code>处的布局属性，那就没必要非要实现这几个方法。</p>

<p>以<code>layoutAttributesForItemAtIndexPath:</code>为例，你可以通过<code>+[UICollectionViewLayoutAttributes layoutAttributesForCellWithIndexPath:]</code>方法拿到一个布局属性对象，然后你可能需要访问你的数据源去算出该<code>indexPath</code>处的布局属性的frame等信息，然后赋值给它。</p>

<h6>shouldInvalidateLayoutForBoundsChange</h6>

<p>这个是用来告诉<code>collectionView</code>是否需要根据bounds的改变而重新计算布局属性，比如横竖屏的旋转。通常的写法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
</span><span class='line'>{
</span><span class='line'>    CGRect oldBounds = self.collectionView.bounds;
</span><span class='line'>    if (CGRectGetWidth(newBounds) != CGRectGetWidth(oldBounds)) {
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>        return NO;
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>需要注意的是，当在滑动的过程中，需要对某些<strong>cell</strong>的布局进行更改，那么就需要在这个方法里面返回<code>YES</code>，告诉<strong>UICollectionView</strong>重新计算布局。因为一个<strong>cell</strong>的改变会引起整个<strong>UICollectionView</strong>布局的改变。</p>

<h5>4、示例一：瀑布流实现</h5>

<p>瀑布流的排列一般用于图片或者商品的展示，它的布局特点是等宽变高，<strong>cell</strong>的排列是找到最短的那一列，然后把cell放到那个位置，效果如下：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1f662nmt5zbg208m0buwgk.gif" alt="image" /></p>

<p>下面我们来看看具体的实现，这里的布局行间距和列间距都定位10，列数固定为3列，如上图所示。</p>

<p>系统提供给我们的<code>UICollectionViewFlowLayout</code>显然不能实现瀑布流的布局，因为它的默认实现是一行一列整齐对齐的，所以我们需要新建一个继承自<code>UICollectionViewFlowLayout</code>的类，然后来讲解一下这个类的实现。</p>

<h6>prepareLayout</h6>

<p>在讲解如何布局瀑布流之前需要先说明一下<code>UICollectionViewFlowLayout</code>的<strong>prepareLayout</strong>方法，他会在<code>UICollectionView</code>布局之前调用，调用<code>[self.collectionView reloadData]</code>和<code>[self.collectionView.collectionViewLayout invalidateLayout]</code>的时候<strong>prepareLayout</strong>也会进行调用，如果<code>shouldInvalidateLayoutForBoundsChange</code>返回<strong>YES</strong>，<strong>prepareLayout</strong>方法同样也会调用。所以这个函数是提前进行数据布局计算的绝佳地方。</p>

<p>在进行瀑布流布局的时候我们可以在<code>prepareLayout</code>里面根据数据源，计算出所有的布局属性并缓存起来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - (void)prepareLayout {
</span><span class='line'>    [super prepareLayout];
</span><span class='line'>    //记录布局需要的contentSize的高度
</span><span class='line'>    self.contentHeight = 0;
</span><span class='line'>    //columnHeights数组会记录各列的当前布局高度
</span><span class='line'>    [self.columnHeights removeAllObjects];
</span><span class='line'>    
</span><span class='line'>    //默认高度是sectionEdge.top
</span><span class='line'>    for (NSInteger i = 0; i &lt; self.columnCount; i++) {
</span><span class='line'>        [self.columnHeights addObject:@(self.edgeInsets.top)];
</span><span class='line'>    }
</span><span class='line'>    //清除之前所以的布局属性数据
</span><span class='line'>    [self.attrsArray removeAllObjects];
</span><span class='line'>    //通过数据源拿到需要展示的cell数量
</span><span class='line'>    NSInteger count = [self.collectionView numberOfItemsInSection:0];
</span><span class='line'>    //开始创建每一个cell对应的布局属性
</span><span class='line'>    for (NSInteger index = 0; index &lt; count; index++) {
</span><span class='line'>        //创建indexPath
</span><span class='line'>        NSIndexPath *indexPath = [NSIndexPath indexPathForItem:index inSection:0];
</span><span class='line'>        //获取cell布局属性,在layoutAttributesForItemAtIndexPath里面计算具体的布局信息
</span><span class='line'>        UICollectionViewLayoutAttributes *attrs = [self layoutAttributesForItemAtIndexPath:indexPath];
</span><span class='line'>        [self.attrsArray addObject:attrs];
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在<code>layoutAttributesForItemAtIndexPath</code>方法里面去根据参数<strong>indexPath</strong>拿到数据源里面对应位置的展示数据，根据等宽的前提，等比例的获得布局属性的高度，然后根据记录每列当前布局到的高度的数组<code>columnHeights</code>来找到当前布局最短的那一列，从而获取到布局属性的<code>origin</code>信息，这样在等宽的前提下就获取到了当前<code>indexPath</code>处的布局属性的<code>frame</code>信息。然后更新<code>columnHeights</code>里面的数据，并且让记录布局所需高度的变量<code>contentHeight</code>等于当前列高度数组里面的最大值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  -(UICollectionViewLayoutAttributes *)layoutAttributesForItemAtIndexPath:(NSIndexPath *)indexPath {
</span><span class='line'>    //获取一个UICollectionViewLayoutAttributes对象
</span><span class='line'>    UICollectionViewLayoutAttributes *attrs = [super layoutAttributesForItemAtIndexPath:indexPath];
</span><span class='line'>    //列数是3，布局属性的宽度是固定的
</span><span class='line'>    CGFloat collectionViewW = self.collectionView.frame.size.width;
</span><span class='line'>    CGFloat width = (collectionViewW - self.edgeInsets.left - self.edgeInsets.right - (self.columnCount - 1) * self.columnMargin) / self.columnCount;
</span><span class='line'>    CGFloat height = 通过数据源以及宽度信息，获取对应位置的布局属性高度;
</span><span class='line'>    //找到数组内目前高度最小的那一列
</span><span class='line'>    NSInteger destColumn = 0;
</span><span class='line'>    CGFloat minColumnHeight = [self.columnHeights[0] doubleValue];
</span><span class='line'>    for (NSInteger index = 1; index &lt; self.columnCount; index++) {
</span><span class='line'>          CGFloat columnHeight = [self.columnHeights[index] doubleValue];
</span><span class='line'>        if (minColumnHeight &gt; columnHeight) {
</span><span class='line'>            minColumnHeight = columnHeight;
</span><span class='line'>            destColumn = index;
</span><span class='line'>            break;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>    //根据列信息，计算出origin的x
</span><span class='line'>    CGFloat x = self.edgeInsets.left + destColumn * (width +self.columnMargin);
</span><span class='line'>    CGFloat y = minColumnHeight;
</span><span class='line'>    if (y != self.edgeInsets.top) {//不是第一行就加上行间距
</span><span class='line'>        y += self.rowMargin;
</span><span class='line'>    }
</span><span class='line'>    //得到布局属性的frame信息
</span><span class='line'>    attrs.frame = CGRectMake(x, y, width, height);
</span><span class='line'>    //更新最短那列的高度
</span><span class='line'>    self.columnHeights[destColumn] = @(CGRectGetMaxY(attrs.frame));
</span><span class='line'>    //更新记录展示布局所需的高度
</span><span class='line'>    CGFloat columnHeight = [self.columnHeights[destColumn] doubleValue];
</span><span class='line'>    if (self.contentHeight &lt; columnHeight) {
</span><span class='line'>        self.contentHeight = columnHeight;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return attrs;
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>滑动的过程在，<strong>cell</strong>会不断重用，系统会调用<code>layoutAttributesForElementsInRect</code>方法来获取当前可见区域内的布局属性，由于所有的布局属性都缓存了起来，则只需返回布局属性的<strong>frame</strong>和当前可见区域有交集的布局属性就行。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  -(NSArray *)layoutAttributesForElementsInRect:(CGRect)rect {
</span><span class='line'>    NSMutableArray *rArray = [NSMutableArray array];
</span><span class='line'>    for (UICollectionViewLayoutAttributes *cacheAttr in _attrsArray) {
</span><span class='line'>        if (CGRectIntersectsRect(cacheAttr.frame, rect)) {
</span><span class='line'>            [rArray addObject:cacheAttr];
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return rArray;
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>最后由于我们自定义了每个cell的高度及布局，所以系统是不知道<strong>UICollectionView</strong>当前的<strong>contentSize</strong>的大小，所以我们需要在<code>collectionViewContentSize</code>方法里返回正确的<strong>size</strong>以确保所以<strong>cell</strong>都能正常滑动到可见区域里来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  -(CGSize)collectionViewContentSize {
</span><span class='line'>    return CGSizeMake(CGRectGetWidth(self.collectionView.frame), self.contentHeight + self.edgeInsets.bottom);
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>
至此，瀑布流的布局就完成了，实现起来非常简单，最关键的地方就是计算布局属性的<strong>frame</strong>信息。</p>

<h5>5、示例二：卡片吸顶布局</h5>

<p>卡片吸顶布局的效果如下：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1f662nnfgrag208m0bujvj.gif" alt="image" /></p>

<p>可以看到滑到顶部的<strong>cell</strong>本应该移出当前可见区域，但我们实现的效果是移到顶部后就悬停，并且可以被后来的<strong>cell</strong>覆盖。</p>

<p>实现的原理非常简单，<strong>cell</strong>的布局使用<strong>UICollectionViewFlowLayout</strong>就能实现，我们新建一个继承自<strong>UICollectionViewFlowLayout</strong>的子类，利用这个子类创建布局，可以利用<strong>UICollectionViewFlowLayout</strong>提供的参数来构建一个不吸顶展示的<strong>collectionView</strong>：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0jw1f662nnrqqhg208m0bugp0.gif" alt="image" /></p>

<p>只需要提供给<strong>UICollectionViewFlowLayout</strong><code>itemSize</code>和<code>minimumLineSpacing</code>就行，行间距<code>minimumLineSpacing</code>设置为一个负数就能建立起互相叠加的效果。</p>

<p>要建立吸顶的效果，只需要在原来的布局基础上，判断布局属性<code>frame</code>小于布局顶部的<code>y</code>值，就将布局属性的<code>frame</code>的<strong>y</strong>值设置为顶部的<strong>y</strong>值就行，这样滑动到顶部的<strong>cell</strong>都会在顶部悬停下来。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  @implementation CardCollectionViewFlowLayout
</span><span class='line'>
</span><span class='line'>- (NSArray *)layoutAttributesForElementsInRect:(CGRect)rect
</span><span class='line'>{
</span><span class='line'>    //拿到当前可见区域内的布局属性
</span><span class='line'>    NSArray *oldItems = [super layoutAttributesForElementsInRect:rect];
</span><span class='line'>    //处理当前可见区域内的布局属性吸顶
</span><span class='line'>    [oldItems enumerateObjectsUsingBlock:^(UICollectionViewLayoutAttributes *attributes, NSUInteger idx, BOOL *stop) {
</span><span class='line'>        [self recomputeCellAttributesFrame:attributes];
</span><span class='line'>    }];
</span><span class='line'>    
</span><span class='line'>    return oldItems;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (void)recomputeCellAttributesFrame:(UICollectionViewLayoutAttributes *)attributes
</span><span class='line'>{
</span><span class='line'>    //获取悬停处的y值
</span><span class='line'>    CGFloat minY = CGRectGetMinY(self.collectionView.bounds) + self.collectionView.contentInset.top;
</span><span class='line'>    //拿到布局属性应该出现的位置
</span><span class='line'>    CGFloat finalY = MAX(minY, attributes.frame.origin.y);
</span><span class='line'>    
</span><span class='line'>    CGPoint origin = attributes.frame.origin;
</span><span class='line'>    origin.y = finalY;
</span><span class='line'>    attributes.frame = (CGRect){origin, attributes.frame.size};
</span><span class='line'>    //根据IndexPath设置zIndex能确立顶部悬停的cell被后来的cell覆盖的层级关系
</span><span class='line'>    attributes.zIndex = attributes.indexPath.row;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>- (BOOL)shouldInvalidateLayoutForBoundsChange:(CGRect)newBounds
</span><span class='line'>{
</span><span class='line'>    //由于cell在滑动过程中会不断修改cell的位置，所以需要不断重新计算所有布局属性的信息
</span><span class='line'>    return YES;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在实现里面不需要<code>-(CGSize)collectionViewContentSize</code>方法的原因是，对于利用<code>UICollectionViewFlowLayout</code>来进行布局，而不是自定义的布局，系统会自动根据你设置的<code>itemSize</code>等信息计算出<code>contentSize</code>。</p>

<h5>6、总结</h5>

<p>通过上面的例子我们可以看到，<code>UICollectionView</code>相到于一个画板，而<code>UICollectionViewLayout</code>则可以帮我们组织画板的大小，以及画板内容的组织形态。在日常开发需求中，我们也需要重视<code>UICollectionView</code>，利用好它可以达到事半功倍的效果。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何检测iPhone设备处于低电量模式]]></title>
    <link href="http://summertreee.github.io/blog/2016/06/12/ru-he-jian-ce-iphoneshe-bei-chu-yu-di-dian-liang-mo-shi/"/>
    <updated>2016-06-12T20:52:53+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/06/12/ru-he-jian-ce-iphoneshe-bei-chu-yu-di-dian-liang-mo-shi</id>
    <content type="html"><![CDATA[<p>在iOS9中，苹果为iPhone增加了低电量模式，开启低电量模式后，系统会为了节约电量而停止一些耗电的行为，例如接收邮件，通过<code>Hey Siri</code>唤起，后台消息推送等。</p>

<p>很重要的一点是系统不会为用户自动打开低电量模式，而是由用户自己去决定是否进入低电量模式，进入低电量模式后状态栏中的电池会变为黄色：</p>

<!--more-->


<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1f4sqcia5uuj20jq0f4gn2.jpg" alt="image" /></p>

<p>当你充电量达到80%时会自动关闭低电量模式。</p>

<h4>检测低电量模式</h4>

<p>在iOS9里面你可以通过如下方法得知当前设备是不是处于低电量模式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Objective-C
</span><span class='line'>if ([[NSProcessInfo processInfo] isLowPowerModeEnabled]) {
</span><span class='line'>  // stop battery intensive actions
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>并且你可以通过注册<code>NSProcessInfoPowerStateDidChangeNotification</code>通知来检测低电量模式的变化：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Objective-C
</span><span class='line'>[[NSNotificationCenter defaultCenter] addObserver:self
</span><span class='line'>  selector:@selector(didChangePowerMode:)
</span><span class='line'>  name:NSProcessInfoPowerStateDidChangeNotification
</span><span class='line'>  object:nil];
</span><span class='line'>  
</span><span class='line'>  
</span><span class='line'>  // Objective-C
</span><span class='line'>- (void)didChangePowerMode:(NSNotification *)notification {
</span><span class='line'>  if ([[NSProcessInfo processInfo] isLowPowerModeEnabled]) {
</span><span class='line'>    // low power mode on
</span><span class='line'>  } else {
</span><span class='line'>    // low power mode off
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h6>注意：</h6>

<ol>
<li>该通知和<code>lowPowerModeEnabled</code>只有在iOS9里面才有，支持iOS8的App需要自己在代码里面判断。</li>
<li>低电量模式是iPhone设备独有的，在iPad里面会返回false。</li>
</ol>


<p>开启低电量模式后，我们需要采取一些措施去节约电量，比如Apple给的一些建议：</p>

<ul>
<li>停止定位位置更新。</li>
<li>限制动画的使用。</li>
<li>限制后台的网络请求。</li>
<li>关闭<code>motion effects</code>。</li>
</ul>


<p>参考【<a href="http://useyourloaf.com/blog/detecting-low-power-mode/?utm_campaign=iOS%2BDev%2BWeekly&amp;utm_medium=web&amp;utm_source=iOS_Dev_Weekly_Issue_252">链接</a>】</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我所理解的Runtime]]></title>
    <link href="http://summertreee.github.io/blog/2016/05/22/wo-suo-li-jie-de-runtime/"/>
    <updated>2016-05-22T14:46:14+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/05/22/wo-suo-li-jie-de-runtime</id>
    <content type="html"><![CDATA[<p>Objective-C是一门基于对象的动态语言，它里面所有的继承自<code>NSObject</code>的类本身以及类所实例化的对象都是对象，好像有点儿绕，大意就是这是一门基于对象的语言，就连类自己也是一个对象，程序运行起来以后类本身也会被初始化，也占有内存空间。<br/>
在这篇笔记里，我会记录如下的一些信息：</p>

<ul>
<li>消息传递</li>
<li>runtime如何处理对象</li>
<li>self 和 super</li>
<li>Method Swizzling</li>
<li>消息转发</li>
</ul>


<!--more-->


<h4>消息传递</h4>

<p>Objective-C是一门动态的语言，当我们在某个对象上调用方法是，<code>Objective—C</code>里面叫做<code>消息传递</code>，和<code>C语言</code>的函数调用在本质上就不一样，<code>C语言</code>使用<code>静态绑定</code>，在编译器就能决定运行时应该调用的函数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//代码一
</span><span class='line'>void printHello() {
</span><span class='line'>    printf("Hello, world!\n");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void printGoodbye() {
</span><span class='line'>    printf("Goodbye, world!\n");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void doSomeThing(int type) {
</span><span class='line'>    if (type == 0) {
</span><span class='line'>        printHello();
</span><span class='line'>    } else {
</span><span class='line'>        printGoodbye();
</span><span class='line'>    }
</span><span class='line'>}  
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>以上的代码在编译器编译代码的时候就已经知道程序中有 <strong>printHello</strong> 和 <strong>printGoodbye</strong> 这两个函数了，于是就直接生成调用这些函数的指令。而函数地址实际上是硬编码在指令之中的。但是，对于<code>Objective—C</code>来说，如果像下面这样写，情况会完全不一样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  //代码二 
</span><span class='line'>  void printHello() {
</span><span class='line'>    printf("Hello, world!\n");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void printGoodbye() {
</span><span class='line'>    printf("Goodbye, world!\n");
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>void doSomeThing(int type) {
</span><span class='line'>    void (*funcation)();
</span><span class='line'>    if (type == 0) {
</span><span class='line'>        funcation = printHello;
</span><span class='line'>    } else {
</span><span class='line'>        funcation = printGoodbye;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>   funcation();
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这时就需要使用<code>动态绑定</code>了，因为实际调用的方法在运行期根据<strong>type</strong>的值才能确定，在<strong>代码一</strong>中，<strong>if</strong>和<strong>else</strong>里面都有函数调用指令，而在<code>代码二</code>中，只有一个函数调用指令，而且待调用的函数地址无法硬编码到指令中，而是需要在运行期间读取出来。<br/>
在底层，所有的方法都是普通的<code>C语言</code>函数，当对象接收到消息之后，究竟该调用哪个方法完全是运行期决定的，甚至可以在运行期改变以及交换某些函数的实现，这就是<code>runtime</code>所体现出来的异于其他编程语言的特点。<br/>
当给某个对象传递一个消息：</p>

<pre><code>id returnValue = [someObject messageName:parameter];  
</code></pre>

<p>在这个消息中，<code>someObject</code>叫接收者(receiver)，<code>messageName</code>叫做选择子(selector)，选择子和参数结合起来叫<code>消息</code>(message)。当编译器看到此消息后，会将其转换为标准的<code>C语言</code>函数调用，这是就引出了我们消息传递中最核心的一个函数<code>objc_msgSend</code>，其原型如下：</p>

<pre><code>id objc_msgSend(id self, SEL op, ...)  
</code></pre>

<p>它是一个参数可变的函数，可以接受两个及两个以上的参数。有了这个函数，编译器会把刚才的消息转换为如下的函数：</p>

<pre><code>id returnValue = objc_msgSend(someObjetc,
                              @selector(messageName:),
                              parameter);  
</code></pre>

<p>到了运行期间，为了完成此操作，该方法需要到接受者所属的类中搜索其<strong>方法列表</strong>(后续会有讲到)，如果能找到与<strong>选择子</strong>名称相符的方法，就跳至其实现代码，如果找不到则按照其继承关系向上查找，如果到最终(NSObject)还是没能找到匹配的方法，那就执行<code>消息转发</code>(后续会讲到)。</p>

<p>除了刚才讲到的<code>objc_msgSend</code>外，还有其他的几种处理<code>边界情况</code>的函数：</p>

<pre><code>//处理待发送的消息要返回结构体
objc_msgSend_stret(id self, SEL op, ...)

//处理待发送的消息返回值是浮点数
objc_msgSend_fpret(id self, SEL op, ...) 

//处理将消息发送给超类的情况 
objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</code></pre>

<p>上面讲到了，<code>objc_msgSend</code>函数会根据<strong>选择子</strong>去查找应该调用的方法实现，<strong>选择子</strong>可以理解为一个标记，它其实就是<code>char *</code>字符串，选择字和方法的实现<code>IMP</code>之间是一对一的关系，<code>runtime</code>里面通过结构体<code>objc_method</code>来存储它们：</p>

<pre><code>typedef struct objc_method *Method;
struct objc_method {
    SEL method_name     OBJC2_UNAVAILABLE;
    char *method_types  OBJC2_UNAVAILABLE;
    IMP method_imp      OBJC2_UNAVAILABLE;
}  
</code></pre>

<h4>runtime如何处理对象</h4>

<p><code>Objective-C</code>是一门基于对象的动态语言，它的动态性是建立在对象上面的，从<code>runtime</code> 源码我们可以看到它是由<code>C语言</code>编写，这可以保证它执行的高效性，编译器在编译期会将对象转换为它里面定义的结构体：</p>

<pre><code>struct objc_object {
    Class isa  OBJC_ISA_AVAILABILITY;
};
</code></pre>

<p>由此可见，每个对象结构体的首个成员变量是<code>Class</code>类的变量，通过它可以知道对象所属的类，通过<code>isa</code>指针可以访问到。<br/>
比如说我们定义了如下一个类<code>MyClass</code>：</p>

<pre><code>@interface MyClass : NSObject {
    NSString *name;
    NSUInteger age;
}
</code></pre>

<p>编译器编译<code>MyClass</code>类以后，它的实例变量布局如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  struct MyClass {
</span><span class='line'>    struct objc_class {
</span><span class='line'>        Class isa;
</span><span class='line'>    }
</span><span class='line'>    NSString *name;
</span><span class='line'>    NSUInteger age;
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>精简一下，去除<code>struct</code>的壳：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  struct MyClass {
</span><span class='line'>    Class isa;
</span><span class='line'>    NSString *name;
</span><span class='line'>    NSUInteger age;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>isa</code>变量的类型是<code>Class</code>，它的定义在<code>runtime</code>程序库里可以找到，它的定义如下：</p>

<pre><code>typedef struct objc_class *Class;  
</code></pre>

<p>所以由此我们知道<code>isa</code>本身就是一个<code>objc_class</code>类型的指针，同样我们可以在<code>runtime</code>程序库里面找到<code>objc_class</code>的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  struct objc_class {
</span><span class='line'>    Class isa  OBJC_ISA_AVAILABILITY;
</span><span class='line'>
</span><span class='line'>#if !__OBJC2__
</span><span class='line'>    Class super_class                                        OBJC2_UNAVAILABLE;
</span><span class='line'>    const char *name                                         OBJC2_UNAVAILABLE;
</span><span class='line'>    long version                                             OBJC2_UNAVAILABLE;
</span><span class='line'>    long info                                                OBJC2_UNAVAILABLE;
</span><span class='line'>    long instance_size                                       OBJC2_UNAVAILABLE;
</span><span class='line'>    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
</span><span class='line'>    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
</span><span class='line'>    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
</span><span class='line'>    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
</span><span class='line'>#endif
</span><span class='line'>
</span><span class='line'>} OBJC2_UNAVAILABLE;
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>这个结构体存放了类的所有<code>元数据</code>，例如定义了哪些实例变量，定义了哪些方法，超类等。此结构体的首个变量也是<code>isa</code>指针，说明<code>Class</code>本身也是一个<code>Objective-C</code>对象，<code>Class</code>里面的<code>isa</code>指向的类就是<code>元类</code>，用它来定义类对象本身的<code>元数据</code>。也就是说实例对象的<code>isa</code>指针指向它唯一的类对象，而类对象的<code>isa</code>指针指向它唯一的元类。我们知道，类和实例对象都可以发送<code>class</code>消息，从<code>runtime</code>的源码中有这样的定义：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - class
</span><span class='line'>  {
</span><span class='line'>      return (id)isa;
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  + class
</span><span class='line'>  {
</span><span class='line'>     return self;
</span><span class='line'>  }
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>由上可以看出实例对象的class就是<code>isa</code>指向的class对象，而实例对象的类的class就是自己，这也印证了上面的说法。</p>

<p>在<code>Objective-C</code>中，对象的实例方法存放在它的<code>isa</code>指向的类对象中，类方法存放于类对象的<code>isa</code>指向的元类中，某个类在应用程序范围内，类对象以及它所属的元类只有一个，它们都是<code>单例</code>。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f445qvvtffj21b00o6e81.jpg" alt="image" /></p>

<p>当我们向某个类的实例化对象发送消息时，实例对象通过它的<code>isa</code>指针找到它所属的类对象，再去类对象的方法列表里面根据<code>选择子</code>查找，如果没有找到就去它父类的类对象里面查找。如果是向类对象调用类方法，类对象先通过它的<code>isa</code>指针找到它的<code>元类</code>，在元类的方法列表里面根据<code>选择子</code>查找需要调用的方法，如果找到了则跳转到方法实现，若没有找到则向它的父类的元类里面查找。</p>

<p>实例对象的类以及元类的关系如下图(图片<a href="www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">来源</a>)：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f445qwqwm2j20tg0u4gs1.jpg" alt="image" /></p>

<p>这里需要说明的是：图中类对象<strong>Root class</strong>，也就是<code>NSObject</code>，它的父类是<code>nil</code>，它的<code>元类</code>是<code>NSObject元类</code>，而<code>NSObject元类</code>的元类指向自己，父类指向<code>NSObject</code>类对象，这样刚好形成一个环，可能是苹果设计的需要，因为<code>NSObject</code>里面有很多定义好的行为，比如内存管理，空间开辟等，让所有的类对象都收敛于<code>NSObject</code>，便于统一管理。</p>

<p>好了，说了这么多，下面来做个简单的练习，热热身😃，首先贴出<code>object_getClass</code>方法的实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Class object_getClass(id obj)
</span><span class='line'>  {
</span><span class='line'>     if(obj)  return obj-&gt;isa;
</span><span class='line'>     else return Nil;
</span><span class='line'>  }
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>也就是说这个方法会返回传入对象的<code>isa</code>指向。</p>

<p>以下是输出每行对象的内存地址：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  Class class1 = [NSObject class];//0x90620c ①
</span><span class='line'>  id obj1 = [NSObject valueForKey:@"isa"];//0x906220 ②
</span><span class='line'>  id obj2 = [obj1 valueForKey:@"isa"];//0x906220  ③
</span><span class='line'>  NSObject *object = [NSObject new];
</span><span class='line'>  Class class2 = objc_getMetaClass("NSObject");//0x906220 ④
</span><span class='line'>  Class class3 = object_getClass(object);//0x90620c ⑤
</span><span class='line'>  Class class4 = class_getSuperclass(class1);//0x0 ⑥
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>①⑤的指向相同，②③④指向相同，⑥指向nil。<br/>
① 对<code>NSObject</code>调用<code>class</code>方法返回<code>NSObject</code>类对象本身。<br/>
② 获取<code>NSObject</code>类对象的<code>isa</code>变量，它指向<code>NSObject</code>类对象的元类。<br/>
③ 获取<code>NSObject</code>元类的<code>isa</code>变量，它和②的指向一样，说明<strong>NSObject元类</strong>的<strong>isa</strong>指向了<strong>NSObject类对象</strong>自身，和上图中的指向一致。<br/>
④ 获取<strong>NSObject类对象</strong>的元类。<br/>
⑤ 获取<strong>NSObject</strong>实例对象的<code>isa</code>指向，其实就是<strong>NSObject类对象</strong>，所以和①的值相同。<br/>
⑥ 获取<strong>NSObject类对象</strong>的父类，打印<strong>nil</strong>，和上图中标明的一致。</p>

<p>再来一个例子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  @interface NSObject (Mycategory)
</span><span class='line'>  + (void)foo;
</span><span class='line'>  @end
</span><span class='line'>  
</span><span class='line'>  @implementation NSObject (Mycategory)
</span><span class='line'>  - (void)foo
</span><span class='line'>  {
</span><span class='line'>       NSLog(@"%s",__PRETTY_FUNCTION__);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>@end
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>如果执行下面的代码会输出什么呢？ 😖</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[NSObject foo]; //①
</span><span class='line'>[[NSObject new] performSelector:@selector(foo)];  //②
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>①:对<code>NSObject</code>发送<code>foo</code>消息，会到<strong>NSObject类对象</strong>的元类中查找，理所当然没能找到，然后去到<strong>NSObject类对象元类</strong>的父类里面查找，它的父类是<code>NSObject</code>，然后在<code>NSObject类对象</code>的方法列表里面查找，这时找到了<code>- (void)foo</code>方法，然后跳到函数入口处执行，输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-[NSObject(Mycategory) foo]    </span></code></pre></td></tr></table></div></figure>


<p>②:首先初始化一个<strong>NSObject</strong>实例对象，然后发送<code>foo</code>消息，这是会到<code>NSObject类对象</code>里面查找，这是找到了<code>- (void)foo</code>方法，然后跳到函数入口处执行，输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> -[NSObject(Mycategory) foo]  
</span><span class='line'> </span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>self和super</h4>

<ul>
<li>在实例方法中<code>self</code>代表着<code>对象</code>本身。</li>
<li>在类方法中，<code>self</code>代表当前<code>类</code>。</li>
</ul>


<p>万变不离其宗，记住一句话就行了：<code>self</code>代表着当前方法的调用者。<br/>
上面讲到了，在<code>Objective-C</code>中对<code>super</code>发送消息时，编译后会被转换为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> objc_msgSendSuper(struct objc_super *super, SEL op, ...)
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>接下来我们看看<code>super</code>指针的类型<code>objc_super</code>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  /// Specifies the superclass of an instance. 
</span><span class='line'>struct objc_super {
</span><span class='line'>    /// Specifies an instance of a class.
</span><span class='line'>    __unsafe_unretained id receiver;
</span><span class='line'>
</span><span class='line'>    /// Specifies the particular superclass of the instance to message. 
</span><span class='line'>#if !defined(__cplusplus)  &&  !__OBJC2__
</span><span class='line'>    /* For compatibility with old objc-runtime.h header */
</span><span class='line'>    __unsafe_unretained Class class;
</span><span class='line'>#else
</span><span class='line'>    __unsafe_unretained Class super_class;
</span><span class='line'>#endif
</span><span class='line'>    /* super_class is the first class to search */
</span><span class='line'>};
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>通过上面的结构我们可以看出：对<code>super</code>发送消息，<code>receiver</code>还是<code>self</code>，唯一的区别是查找方法时不是从本类开始，而是从<code>super_class</code>开始。下面我们来看看一个测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface Father : NSObject
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation Father
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@interface Son : Father
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@implementation Son
</span><span class='line'>
</span><span class='line'>- (instancetype)init
</span><span class='line'>{
</span><span class='line'>    self = [super init];
</span><span class='line'>    if (self) {
</span><span class='line'>        NSLog(@"%@",NSStringFromClass([self class]));
</span><span class='line'>        NSLog(@"%@",NSStringFromClass([super class]));
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return self;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>运行结果都是输出：<code>Son</code>。由于<code>class</code>在基类<code>NSObject</code>里面有实现，所以两个输出都是输出调用者自己所属的类，这里都输出了<code>Son</code>，而没有输出<code>Father</code>，所以说<code>super</code>只是一个标记符，标记消息的查找是从<code>superClass</code>开始，其他和<code>self</code>没有任何区别。</p>

<h4>Method Swizzling</h4>

<p>我们有时候为了调试方便或者想对系统的方法进行自定义的改造，这是我们可以利用<code>Method Swizzling</code>来进行方法实现的交换。<br/>
对方法的交换我们可以在<code>load</code>或者<code>initialize</code>里面进行，但是需要根据自己的需要进行选择，它们的区别如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f445qxsptrj219m0oo1kk.jpg" alt="image" /></p>

<p>方法的交换就是更改选择子(selector)所对应的<code>IMP</code>，如下：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f445qynrpmj20p40fsapj.jpg" alt="image" /></p>

<p>下面贴上一段<code>Method Swizzling</code>(方法调配)的示例：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - (void)load
</span><span class='line'>{
</span><span class='line'>    static dispatch_once_t onceToken;
</span><span class='line'>    dispatch_once(&onceToken, ^{
</span><span class='line'>        Class currentClass = [self class];
</span><span class='line'>        SEL originSelector = @selector(foo);
</span><span class='line'>        SEL swizzedSelector = @selector(st_foo);
</span><span class='line'>        
</span><span class='line'>        Method originMethod = class_getInstanceMethod(currentClass, originMethod);
</span><span class='line'>        Method swizzedMethod = class_getInstanceMethod(currentClass, swizzedSelector);
</span><span class='line'>        if (class_addMethod(currentClass, originSelector, method_getImplementation(swizzedMethod), method_getTypeEncoding(swizzedMethod))) {
</span><span class='line'>            class_addMethod(currentClass, swizzedSelector, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));
</span><span class='line'>        } else {
</span><span class='line'>            method_exchangeImplementations(originMethod, swizzedMethod);
</span><span class='line'>        }
</span><span class='line'>    });
</span><span class='line'>}
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这里需要说明的是<code>if</code>条件里面的判断，如果为真则表示<code>currentClass</code>没有<code>originSelector</code>的方法，然后进行该方法的添加，如果为假则表示<code>currentClass</code>里面已经有了<code>originSelector</code>方法。这里这么做的原因是我们只想对当前类进行方法调配，而不想对父类造成影响。比如当前类的父类里面有一个方法，当前类没有进行覆盖，当我们在当前类里进行<code>方法调配</code>对这个方法的实现进行重新定义，如果直接进行<code>method_exchangeImplementations</code>则交换的是父类的方法。结果会与我们预想的不符。</p>

<h4>消息转发</h4>

<p>前面讲了<code>Objective-C</code>里面的<code>消息传递</code>机制，当我们向一个对象传递一个消息，而当程序运行中无法找到该消息对应的实现，这是就会启动<code>消息转发</code>(message forwarding)机制，这个时候我们可以进行一些操作来防止程序crash。<br/>
我们经常遇到程序异常，控制台输出：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   *** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[ViewController TestMessage]: unrecognized selector sent to instance 0x7fd41075b6a0'
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p>这就是向对象传递了无法识别的消息报的异常信息。我们在开发中，可以在进入<code>消息转发</code>后执行预定的逻辑，从而避免奔溃。</p>

<p><code>消息转发</code>大致分为三个步奏：</p>

<h6>1、动态方法解析</h6>

<p>对象在接收到无法识别的消息后，会首先调用所属类的下列方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  + (BOOL)resolveClassMethod:(SEL)sel;//对于类方法
</span><span class='line'>  + (BOOL)resolveInstanceMethod:(SEL)sel;//对于实例方法
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>参数就是无法识别的<code>选择子</code>，这时我们可以在该方法里面为该选择子添加一个实现，返回<code>YES</code>，系统会对该方法再进行一次传递，这时就能正常运行了，但它的前提是添加的实现必须是已经定义好的。如果返回<code>NO</code>，则会就行下一步(下面会说到)，这里贴出简单的示例代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (BOOL)resolveInstanceMethod:(SEL)sel
</span><span class='line'>{
</span><span class='line'>    NSString *selectorString = NSStringFromSelector(sel);
</span><span class='line'>    if ([selectorString isEqualToString:@"foo"]) {
</span><span class='line'>        Method myMethod = class_getInstanceMethod(self, @selector(myFoo));
</span><span class='line'>        class_addMethod(self, sel, method_getImplementation(myMethod), method_getTypeEncoding(myMethod));
</span><span class='line'>        return YES;
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    return NO;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h6>2、备援接受者</h6>

<p>如果步骤一未能处理，运行期系统则会看看能不能把消息转发到其他对象，因为当前类肯定<code>组合</code>了一些其他的对象，这时调用：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> - (id)forwardingTargetForSelector:(SEL)aSelector; 
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>若当前对象能找到合适的消息接受者，则将该接受者返回，若找不到则返回nil，消息转发会进行下一步，这里需要注意的是，未知消息到了这里只能将消息的转发给其他对象，无法修改消息的内容。</p>

<h6>3、完整的消息转发</h6>

<p>如果前两步都没能将未知消息进行有效的处理，则会进入<code>完整的消息转发</code>，首先需要重写<code>methodSignatureForSelector:</code>方法来获取未知消息的参数和返回值类型，如果这个方法里返回<code>nil</code>则消息转发结束，系统发出<code>doesNotRecognizeSelector:</code>消息，然后就挂掉了，如果返回一个签名函数，<code>runtime</code>就会创建一个<code>NSInvocation</code>对象，把未知消息相关的全部细节封装在里面：选择子、target、参数。然后发送<code>-forwardInvocation:</code>消息。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  - (NSMethodSignature *) methodSignatureForSelector : (SEL)selector
</span><span class='line'>  {  
</span><span class='line'>    NSMethodSignature *signature = [super methodSignatureForSelector:selector];  
</span><span class='line'>      
</span><span class='line'>    if(nil == signature){  
</span><span class='line'>        signature = [self.otherObject methodSignatureForSelector:selector];  
</span><span class='line'>    }  
</span><span class='line'>    
</span><span class='line'>    return signature;  
</span><span class='line'>} 
</span><span class='line'>  
</span><span class='line'>  - (void)forwardInvocation:(NSInvocation *)invocation {  
</span><span class='line'>    SEL selector = [invocation selector];  
</span><span class='line'>      
</span><span class='line'>    if([self.otherObject respondsToSelector:selector]){  
</span><span class='line'>        [invocation invokeWithTarget:self.otherObject];  
</span><span class='line'>    }  
</span><span class='line'>} 
</span><span class='line'>  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>综合起来如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f445r01c5qj21f80uk4qq.jpg" alt="image" /></p>

<h6>参考</h6>

<p><a href="http://opensource.apple.com//source/objc4/">runtime源码</a><br/>
<a href="http://tech.glowing.com/cn/objective-c-runtime/">http://tech.glowing.com/cn/objective-c-runtime/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[定制自己的单元测试]]></title>
    <link href="http://summertreee.github.io/blog/2016/05/03/ding-zhi-zi-ji-de-dan-yuan-ce-shi/"/>
    <updated>2016-05-03T09:18:10+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/05/03/ding-zhi-zi-ji-de-dan-yuan-ce-shi</id>
    <content type="html"><![CDATA[<p>我们在进行开发的过程中，会对新开发的功能进行但愿测试，不管是TDD还是BDD，我们都需要利用单元测试来保证我们新功能的正确性，这其中包括执行结果是否正确，对边界处理是否周全，一些特殊情况的测试，这对于一些功能较少的工程可能写好一个<code>testXXX</code>函数，执行一遍单元测试，不会花太多时间，但是对于一些大的工程，可能测试的类会有成百甚至上千个，当你想专注于测试新开发的功能是，每次测试都全部跑一次完整的单元测试，这显然是很耗费时间的行为。</p>

<!--more-->


<p>对于这种情况，我们可以利用<code>Xcode</code>来新建一个<code>scheme</code>，专门只是测试当前新开发的功能的单元测试，步骤如下：</p>

<h6>1、新建一个scheme</h6>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1f3hxfjso7oj208u062dgf.jpg" alt="image" /></p>

<h6>2、对scheme命名</h6>

<p>在新的窗口中，<code>target</code>的下拉框中选择<code>*Tests</code>，这里命名为<code>MyCustomTests</code>。</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1f3hxfkav8jj20r409ugmw.jpg" alt="image" /></p>

<h6>3、定制自己的单元测试</h6>

<p>选择刚才新创建的<code>scheme</code>，进入<code>Edit Scheme...</code>,进入<code>Test</code>选项中，右边就能对需要测试的文件进行筛选：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1f3hxfknumnj21dk0rwagm.jpg" alt="image" /></p>

<p>这是我们再进行单元测试时，就只会执行我们刚才勾选的单元测试文件：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1f3hxflboq8j20ea0a276i.jpg" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift脚本编辑]]></title>
    <link href="http://summertreee.github.io/blog/2016/03/28/swiftjiao-ben-bian-ji/"/>
    <updated>2016-03-28T07:23:47+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/03/28/swiftjiao-ben-bian-ji</id>
    <content type="html"><![CDATA[<p><code>Swift</code>是一种编译型语言，功能强大而且灵活性十足，现在你甚至可以在<code>shell</code>脚本中运行<code>Swift</code>代码。</p>

<p>编写<code>shell</code>脚本包括以下几个步骤：</p>

<ol>
<li>使用编辑器创建脚本。</li>
<li>设置脚本的权限，使其能够执行。</li>
<li>执行脚本。</li>
</ol>


<!--more-->


<h4>1、编辑脚本</h4>

<p>我们可以使用<code>Xcode</code>来直接创建<code>shell</code>脚本：</p>

<p>选择菜单 <code>File -&gt; New -&gt; File</code>,在<code>iOS</code>下选择<code>Other</code>，再在右边选择<code>Shell Script</code></p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f2c7xkqp1vj20kc0ehq4t.jpg" alt="image" /></p>

<p>单击<code>Next</code>按钮，将新建的文件保存，命名为<strong>SwiftScript</strong>，Xcode会自动为其添加<code>.sh</code>的后缀名。这时你就可以在新出现的窗口中编辑脚本了。</p>

<p><code>Xcode</code>将自动为这个文件添加几行代码，其中最重要的一行是：</p>

<pre><code>#!/bin/sh  
</code></pre>

<p>这被称为<code>hash bang</code>语法，指定了要用来运行后续代码行的<code>shell</code>在文件系统中的完整路径。这里指定的是<code>/bin/sh（Bash shell）</code>。进行<code>Swift</code>脚本编程时，需要移除这行代码。事实上，请删除所有这些代码行，并输入如下代码行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#!/usr/bin/env xcrun swift
</span><span class='line'>import Foundation
</span><span class='line'>
</span><span class='line'>class Execution {
</span><span class='line'>class func execute(path path: String, arguments: [String]? = nil) -&gt; Int {
</span><span class='line'>   let task = NSTask()
</span><span class='line'>   task.launchPath = path
</span><span class='line'>   if arguments != nil {
</span><span class='line'>     task.arguments = arguments!
</span><span class='line'>   }
</span><span class='line'>
</span><span class='line'>   task.launch()
</span><span class='line'>   task.waitUntilExit()
</span><span class='line'>   return Int(task.terminationStatus)
</span><span class='line'>
</span><span class='line'>}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>var status : Int = 0
</span><span class='line'>status = Execution.execute(path: "/bin/ls")
</span><span class='line'>print("Status = \(status)")
</span><span class='line'>
</span><span class='line'>status = Execution.execute(path: "/bin/ls", arguments:["/"])
</span><span class='line'>print("Status = \(status)")
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>该脚本的含义将在稍后介绍。</p>

<h4>2、设置权限</h4>

<p>脚本是从命令行运行的，所以启动<code>Terminal</code>，进入到你刚才所写<strong>shell</strong>的文件夹下，执行如下命令：</p>

<pre><code>chmod +x SwiftScript.sh  
</code></pre>

<p>它设置脚本文件的权限，使其能够被<code>shell</code>执行。</p>

<h4>3、运行脚本</h4>

<p>运行脚本很容易，只需要指定脚本的名称，如下：</p>

<pre><code>./SwiftScript.sh  
</code></pre>

<p><strong>./</strong>是告诉shell，需要执行的脚本位于当前目录中，必须显式地指出这一点，否则shell会找不到脚本。</p>

<p>该脚本运行后，你将看到该<code>shell</code>所在文件夹以及磁盘根文件夹的文件清单，你还将看到<code>Status = 0</code>，它指出用于显示文件命令运行正常，没有出现问题。</p>

<h4>4、工作原理</h4>

<p>第一行是前面说过的<code>hash bang</code>，这里指定的应用路径为<code>/usr/bin/env</code>,它是一个为shell脚本设置环境的特殊命令，路径后面是一个你很熟悉的命令&mdash;启动<code>REPL</code>的命令<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  #!/usr/bin/env xcrun swift  
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>下一条命令是一个<code>import</code>命令，与我们应用程序一样，<code>Swift</code>脚本也需要有基本的代码库才能运行。<code>Foundation</code>是向<code>Swift</code>脚本提供基本功能的框架，因此这里导入它：</p>

<pre><code>import Foundation  
</code></pre>

<p>接下来是一个名为<code>Execution</code>的<code>Swift</code>类，其使命是执行命令，将需要执行的命令封装在类中，后面的执行将容易很多。</p>

<pre><code>class Execution {

}  
</code></pre>

<p>这个类中只有唯一的类方法<code>execute</code>，用关键字<code>class</code>定义：一个名为<code>path</code>的<strong>String</strong>参数(用于指定要运行的可执行文件的路径)以及一个名为<code>arguments</code>的<strong>String</strong>数组参数(这个参数是可选的，默认值是<em>nil</em>)。这个方法的返回值是一个<code>Int</code>值，指出了命令的执行状态。</p>

<p>在<code>execute</code>方法中使用<code>Foundation</code>类的<code>NSTask</code>来设置启动路径和参数：</p>

<pre><code>let task = NSTask()  
task.launchPath = path
</code></pre>

<p>对于参数<code>arguments</code>，必须检查其为非<strong>nil</strong>才能使用<code>!</code>将其解包并赋值给<code>task</code>对象的属性<code>arguments</code>。</p>

<pre><code>if arguments != nil {
    task.arguments = arguments!
}
</code></pre>

<p>设置好<code>task</code>对象后，调用其<code>launch</code>命令来执行指定的命令：</p>

<pre><code>task.launch()    
</code></pre>

<p>有关<code>NSTask</code>的文档指出，必须调用方法<code>waitUntilExit</code>让任务结束。</p>

<pre><code>task.waitUntilExit()  
</code></pre>

<p>最后，将<code>task</code>对象的属性<code>terminationStatus</code>作为<code>Int</code>值返回（这个属性的类型为<code>Int32</code>，因此这里将其转换为<code>Int</code>，以方便调用者）：</p>

<pre><code>return Int(task.terminationStatus)  
</code></pre>

<p>在类定义的后面，定义了一个变量用于存储方法<code>execute</code>方法的返回值：</p>

<pre><code>var status : Int = 0  
</code></pre>

<p>接下来，调用<code>execute</code>来执行命令<code>、bin/ls</code>（它显示目录中的文件）。<br/>
另外，注意到一开始没有传入参数<code>arguments</code>：</p>

<pre><code>status = Execution.execute(path: "/bin/ls")
println("Status = \(status)")
</code></pre>

<p>接下来，再次调用方法execute来执行命令<code>/bin/ls</code>，但这次通过参数<code>arguments</code>指定了根路径<code>/</code>。</p>

<pre><code>status = Execution.execute(path: "/bin/ls", arguments:["/"])
print("Status = \(status)")  
</code></pre>

<p>你可以使用<code>Swift</code>编写一个类，并在<code>Shell</code>脚本中使用。</p>

<h5>参考文献：</h5>

<p>Swift基础教程</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>REPL(Read-Eval-Print-Loop)是一个命令行工具，可用于快速尝试<code>Swift</code>代码，在<code>Mac OPX</code>中，可在应用程序<code>Terminal</code>中运行它。   <a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面试精选：链表问题集锦]]></title>
    <link href="http://summertreee.github.io/blog/2016/03/27/mian-shi-jing-xuan-:lian-biao-wen-ti-ji-jin/"/>
    <updated>2016-03-27T22:13:23+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/03/27/mian-shi-jing-xuan-:lian-biao-wen-ti-ji-jin</id>
    <content type="html"><![CDATA[<blockquote><p>前言：链表由于其本身的灵活性，很能考察程序员的编程功底，在面试中被问到链表相关的知识的概率很高，所以很值得我们去学习汇总，下面的内容非原创，而是自己在复习链表的过程中从别处摘抄而来，若想查看原文内容，可以看文章末尾的链接。</p></blockquote>

<p>下面是本文所要用到的链表节点的定义：</p>

<pre><code>struct Node{
    int data;
    Node* next;
};    
</code></pre>

<!--more-->


<h4>1、在O(1)时间删除链表节点</h4>

<p><strong>题目描述</strong>：给定链表的头指针和一个节点指针，在O(1)时间删除该节点。[Google面试题]</p>

<p><strong>分析</strong>：本题与《编程之美》上的<code>从无头单链表中删除节点</code>类似。主要思想都是<code>狸猫换太子</code>，即用下一个节点数据覆盖要删除的节点，然后删除下一个节点。但是如果节点是尾节点时，该方法就行不通了。</p>

<p><strong>代码如下：</strong></p>

<pre><code>//O(1)时间删除链表节点，从无头单链表中删除节点
void deleteRandomNode(Node *cur)
{
    assert(cur != NULL);
    assert(cur-&gt;next != NULL);    //不能是尾节点
    Node* pNext = cur-&gt;next;
    cur-&gt;data = pNext-&gt;data;
    cur-&gt;next = pNext-&gt;next;
    delete pNext;
}  
</code></pre>

<h4>2、单链表的转置</h4>

<p><strong>题目描述：</strong>输入一个单向链表，输出逆序反转后的链表。</p>

<p><strong>分析：</strong>链表的转置是一个很常见、很基础的数据结构题了，非递归的算法很简单，用三个临时指针 pre、head、next 在链表上循环一遍即可。递归算法也是比较简单的，但是如果思路不清晰估计一时半会儿也写不出来吧。</p>

<p><code>循环版本</code>和<code>递归版本</code>的链表转置代码如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  
</span><span class='line'>//单链表的转置,循环方法
</span><span class='line'>Node* reverseByLoop(Node *head)
</span><span class='line'>{
</span><span class='line'>    if(head == NULL || head-&gt;next == NULL)
</span><span class='line'>        return head;
</span><span class='line'>    Node *pre = NULL;
</span><span class='line'>    Node *next = NULL;
</span><span class='line'>    while(head != NULL)
</span><span class='line'>    {
</span><span class='line'>        next = head-&gt;next;
</span><span class='line'>
</span><span class='line'>        head-&gt;next = pre;
</span><span class='line'>        pre = head;
</span><span class='line'>        head = next;
</span><span class='line'>    }
</span><span class='line'>    return pre;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>//单链表的转置,递归方法
</span><span class='line'>Node* reverseByRecursion(Node *head)
</span><span class='line'>{
</span><span class='line'>    //第一个条件是判断异常，第二个条件是结束判断
</span><span class='line'>    if(head == NULL || head-&gt;next == NULL) 
</span><span class='line'>        return head;
</span><span class='line'>
</span><span class='line'>    Node *newHead = reverseByRecursion(head-&gt;next);
</span><span class='line'>
</span><span class='line'>    head-&gt;next-&gt;next = head;
</span><span class='line'>    head-&gt;next = NULL;
</span><span class='line'>
</span><span class='line'>    return newHead;    //返回新链表的头指针
</span><span class='line'>}
</span><span class='line'>  
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>3、求链表倒数第k个节点</h4>

<p><strong>题目描述：</strong>输入一个单向链表，输出该链表中倒数第k个节点，链表的倒数第0个节点为链表的尾指针。</p>

<p><strong>分析：</strong>设置两个指针 p1、p2，首先 p1 和 p2 都指向 head，然后 p2 向前走 k 步，这样 p1 和 p2 之间就间隔 k 个节点，最后 p1 和 p2 同时向前移动，直至 p2 走到链表末尾。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//倒数第k个节点
</span><span class='line'>Node* theKthNode(Node *head,int k)
</span><span class='line'>{
</span><span class='line'>    if(k &lt; 0) return NULL;    //异常判断
</span><span class='line'>
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>    int i = k;
</span><span class='line'>    for(;i&gt;0 && fast!=NULL;i--)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(i &gt; 0)    return NULL;    //考虑k大于链表长度的case
</span><span class='line'>
</span><span class='line'>    while(fast != NULL)
</span><span class='line'>    {
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>        fast = fast-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return slow;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>4、求链表的中间节点</h4>

<p><strong>题目描述：</strong>求链表的中间节点，如果链表的长度为偶数，返回中间两个节点的任意一个，若为奇数，则返回中间节点。</p>

<p><strong>分析：</strong>此题的解决思路和第3题「求链表的倒数第 k 个节点」很相似。可以先求链表的长度，然后计算出中间节点所在链表顺序的位置。但是如果要求只能扫描一遍链表，如何解决呢？最高效的解法和第3题一样，通过两个指针来完成。用两个指针从链表头节点开始，一个指针每次向后移动两步，一个每次移动一步，直到快指针移到到尾节点，那么慢指针即是所求。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//求链表的中间节点
</span><span class='line'>Node* theMiddleNode(Node *head)
</span><span class='line'>{
</span><span class='line'>    if(head == NULL)
</span><span class='line'>        return NULL;
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>    //如果要求在链表长度为偶数的情况下，返回中间两个节点的第一个，可以用下面的循环条件
</span><span class='line'>    //while(fast && fast-&gt;next != NULL && fast-&gt;next-&gt;next != NULL)  
</span><span class='line'>    while(fast != NULL && fast-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    return slow;
</span><span class='line'>}  
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>5、判断单链表是否存在环</h4>

<p><strong>题目描述：</strong>输入一个单向链表，判断链表是否有环？</p>

<p><strong>分析：</strong>通过两个指针，分别从链表的头节点出发，一个每次向后移动一步，另一个移动两步，两个指针移动速度不一样，如果存在环，那么两个指针一定会在环里相遇。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//判断单链表是否存在环,参数circleNode是环内节点，后面的题目会用到
</span><span class='line'>bool hasCircle(Node *head,Node *&circleNode)
</span><span class='line'>{
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>    while(fast != NULL && fast-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>        if(fast == slow)
</span><span class='line'>        {
</span><span class='line'>            circleNode = fast;
</span><span class='line'>            return true;
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return false;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>6、找到环的入口点</h4>

<p><strong>题目描述：</strong>输入一个单向链表，判断链表是否有环。如果链表存在环，如何找到环的入口点？</p>

<p><strong>解题思路：</strong>由上题可知，按照 p2 每次两步，p1 每次一步的方式走，发现 p2 和 p1 重合，确定了单向链表有环路了。接下来，让p2回到链表的头部，重新走，每次步长不是走2了，而是走1，那么当 p1 和 p2 再次相遇的时候，就是环路的入口了。</p>

<p><strong>为什么？：</strong>假定起点到环入口点的距离为 a，p1 和 p2 的相交点M与环入口点的距离为b，环路的周长为L，当 p1 和 p2 第一次相遇的时候，假定 p1 走了 n 步。那么有：</p>

<p>p1走的路径：<code>a+b ＝ n</code>；</p>

<p>p2走的路径： <code>a+b+k*L = 2*n</code>； p2 比 p1 多走了k圈环路，总路程是p1的2倍；</p>

<p>根据上述公式可以得到 <code>k*L=a+b=n</code>显然，如果从相遇点M开始，p1 再走 n 步的话，还可以再回到相遇点，同时p2从头开始走的话，经过n步，也会达到相遇点M。</p>

<p>显然在这个步骤当中 p1 和 p2 只有前 a 步走的路径不同，所以当 p1 和 p2 再次重合的时候，必然是在链表的环路入口点上。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//找到环的入口点
</span><span class='line'>Node* findLoopPort(Node *head)
</span><span class='line'>{
</span><span class='line'>    //如果head为空，或者为单结点，则不存在环
</span><span class='line'>    if(head == NULL || head-&gt;next == NULL) return NULL;
</span><span class='line'>
</span><span class='line'>    Node *slow,*fast;
</span><span class='line'>    slow = fast = head;
</span><span class='line'>
</span><span class='line'>    //先判断是否存在环
</span><span class='line'>    while(fast != NULL && fast-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>        if(fast == slow)
</span><span class='line'>            break;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(fast != slow) return NULL;    //不存在环
</span><span class='line'>
</span><span class='line'>    fast = head;                //快指针从头开始走，步长变为1
</span><span class='line'>    while(fast != slow)            //两者相遇即为入口点
</span><span class='line'>    {
</span><span class='line'>        fast = fast-&gt;next;
</span><span class='line'>        slow = slow-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    return fast;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>7、编程判断两个链表是否相交</h4>

<p><strong>题目描述：</strong>给出两个单向链表的头指针（如下图所示）：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f2brlca2xlj20d403qaa0.jpg" alt="image" /></p>

<p>比如h1、h2，判断这两个链表是否相交。这里为了简化问题，我们假设两个链表均不带环。</p>

<p><strong>解题思路：</strong></p>

<ol>
<li>直接循环判断第一个链表的每个节点是否在第二个链表中。但，这种方法的时间复杂度为O(Length(h1) * Length(h2))。显然，我们得找到一种更为有效的方法，至少不能是O（N<sup>2</sup>）的复杂度。</li>
<li>针对第一个链表直接构造hash表，然后查询hash表，判断第二个链表的每个节点是否在hash表出现，如果所有的第二个链表的节点都能在hash表中找到，即说明第二个链表与第一个链表有相同的节点。时间复杂度为为线性：O(Length(h1) + Length(h2))，同时为了存储第一个链表的所有节点，空间复杂度为O(Length(h1))。是否还有更好的方法呢，既能够以线性时间复杂度解决问题，又能减少存储空间？</li>
<li>转换为环的问题。把第二个链表接在第一个链表后面，如果得到的链表有环，则说明两个链表相交。如何判断有环的问题上面已经讨论过了，但这里有更简单的方法。因为如果有环，则第二个链表的表头一定也在环上，即第二个链表会构成一个循环链表，我们只需要遍历第二个链表，看是否会回到起始点就可以判断出来。这个方法的时间复杂度是线性的，空间是常熟。</li>
<li>进一步考虑“如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的”这个特点，我们可以知道，如果它们相交，则最后一个节点一定是共有的。而我们很容易能得到链表的最后一个节点，所以这成了我们简化解法的一个主要突破口。那么，我们只要判断两个链表的尾指针是否相等。相等，则链表相交；否则，链表不相交。
所以，先遍历第一个链表，记住最后一个节点。然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则，不相交。这样我们就得到了一个时间复杂度，它为O((Length(h1) + Length(h2))，而且只用了一个额外的指针来存储最后一个节点。这个方法时间复杂度为线性O(N)，空间复杂度为O(1)，显然比解法三更胜一筹。</li>
</ol>


<p><strong>解法的代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//判断两个链表是否相交
</span><span class='line'>bool isIntersect(Node *h1,Node *h2)
</span><span class='line'>{
</span><span class='line'>    if(h1 == NULL || h2 == NULL) return false;    //异常判断
</span><span class='line'>    while(h1-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        h1 = h1-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    while(h2-&gt;next != NULL)
</span><span class='line'>    {
</span><span class='line'>        h2 = h2-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    if(h1 == h2) return true;        //尾节点是否相同
</span><span class='line'>    else return false;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>8、 扩展：链表有环，如何判断相交</h4>

<p><strong>题目描述：</strong>上面的问题都是针对链表无环的，那么如果现在，链表是有环的呢?上面的方法还同样有效么?</p>

<p><strong>分析：</strong>如果有环且两个链表相交，则两个链表都有共同一个环，即环上的任意一个节点都存在于两个链表上。因此，就可以判断一链表上俩指针相遇的那个节点，在不在另一条链表上。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//判断两个带环链表是否相交
</span><span class='line'>bool isIntersectWithLoop(Node *h1,Node *h2)
</span><span class='line'>{
</span><span class='line'>    Node *circleNode1,*circleNode2;
</span><span class='line'>    if(!hasCircle(h1,circleNode1))    //判断链表带不带环，并保存环内节点
</span><span class='line'>        return false;                //不带环，异常退出
</span><span class='line'>    if(!hasCircle(h2,circleNode2))
</span><span class='line'>        return false;
</span><span class='line'>
</span><span class='line'>    Node *temp = circleNode2-&gt;next;
</span><span class='line'>    while(temp != circleNode2)
</span><span class='line'>    {
</span><span class='line'>        if(temp == circleNode1)
</span><span class='line'>            return true;
</span><span class='line'>        temp = temp-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    return false;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h4>9、扩展：两链表相交的第一个公共节点</h4>

<p><strong>题目描述：</strong>如果两个无环单链表相交，怎么求出他们相交的第一个节点呢？</p>

<p><strong>分析：</strong>采用对齐的思想。计算两个链表的长度 L1 , L2，分别用两个指针 p1 , p2 指向两个链表的头，然后将较长链表的 p1（假设为 p1）向后移动L2 - L1个节点，然后再同时向后移动p1 , p2，直到 p1 = p2。相遇的点就是相交的第一个节点。</p>

<p><strong>代码如下：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//求两链表相交的第一个公共节点
</span><span class='line'>Node* findIntersectNode(Node *h1,Node *h2)
</span><span class='line'>{
</span><span class='line'>    int len1 = listLength(h1);          //求链表长度
</span><span class='line'>    int len2 = listLength(h2);
</span><span class='line'>    //对齐两个链表
</span><span class='line'>    if(len1 &gt; len2)
</span><span class='line'>    {
</span><span class='line'>        for(int i=0;i&lt;len1-len2;i++)
</span><span class='line'>            h1=h1-&gt;next;
</span><span class='line'>    }
</span><span class='line'>    else 
</span><span class='line'>    {
</span><span class='line'>        for(int i=0;i&lt;len2-len1;i++)
</span><span class='line'>            h2=h2-&gt;next;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    while(h1 != NULL)
</span><span class='line'>    {
</span><span class='line'>        if(h1 == h2)
</span><span class='line'>            return h1;
</span><span class='line'>        h1 = h1-&gt;next;
</span><span class='line'>        h2 = h2-&gt;next;    
</span><span class='line'>    }
</span><span class='line'>    return NULL;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>原文链接，请戳<a href="http://wuchong.me/blog/2014/03/25/interview-link-questions/">这里</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS测试之UIAutomation介绍]]></title>
    <link href="http://summertreee.github.io/blog/2016/02/29/iosce-shi-zhi-uiautomationjie-shao/"/>
    <updated>2016-02-29T07:47:18+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/02/29/iosce-shi-zhi-uiautomationjie-shao</id>
    <content type="html"><![CDATA[<p>UIAutomation是随着iOS SDK 4.0引入的，帮助开发者在<code>while you sleep</code>的时候也能帮你进行自动化的UI测试，它的测试代码使用Javascript编写，不过别担心，如果你对Javascript不熟悉的话，可以使用Instrument中<code>UIAutomation</code>的录制功能，它能将你的操作转换为测试代码，你只需要保存这些自动生成的代码就行，稍后我们将介绍该功能。</p>

<p>使用<code>UIAutomation</code>做自动化UI测试时，使用者需要做最基本的两件事情是：</p>

<ul>
<li>如何找到界面上的UI元素</li>
<li>如何针对找到的UI元素进行测试操作</li>
</ul>


<!--more-->


<h4>如何找到界面上的UI元素</h4>

<p>在<code>UIAutomation</code>中，界面就是一堆UI元素构建的层级结构，这些元素需要一个叫<code>Accessibility label</code>去标记，它可以在如下所示的地方进行设置：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1q07rxj20bn0d83zs.jpg" alt="image" /></p>

<p><code>UI Accessibility</code>在iOS3.0就被引入了，它是用来辅助身体不便的人士使用APP的，VoiceOver是Apple的屏幕阅读技术，而<code>UI Accessibility</code>的基本原则就是对屏幕上的UI元素进行分类和标记，两者配合，通过阅读和聆听这些元素，用户就可以在不接触屏幕的情况下通过声音使用APP。</p>

<p><code>Accessibility</code> 的核心思想是对 UI 元素进行分类和标记，将屏幕上的UI分类为像是按钮，文本框，Cell或者是静态文本(也就是label) 这样的类型，然后使用<code>identifier</code>来区分不同的UI元素。用户可以通过语音控制app的按钮点击，或是询问某个label的内容等等，十分方便。iOS SDK 中的控件都实现了默认的<code>Accessibility</code>支持，而我们如果使用自定义的控件的话，则需要自行使用 <code>Accessibility</code> 的 API 来进行添加。</p>

<h4>对找到的UI元素进行测试操作</h4>

<h5>1、启动Instruments</h5>

<p>由于<code>UIAutomation</code>被集成到了<code>Instruments</code>中，所以要进行<code>UIAutomation</code>测试，首先打开如下所示的工具<code>Automation</code></p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1qinz2j20l90bz774.jpg" alt="image" /></p>

<h6>2、编写测试代码</h6>

<p>打开<code>Automation</code>如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1r6ehaj20ou0jdq6l.jpg" alt="image" /></p>

<p>在这里我们可以进行测试代码的编写或者在右边区域直接导入已经写好的测试代码，正如前面提到的，这些测试代码需要使用JavaScript进行编写，如果你不熟悉或者嫌麻烦，可以使用底部的录制功能，启用录制后你对屏幕的测试操作都会被自动的转为测试代码，非常方便。</p>

<p>测试如果不通过，就会在顶部的时间轴上标红，测试也会自动停止。</p>

<h6>3、测试代码相关的简介</h6>

<p>在<code>UIAutomation</code>中所有元素都继承自<code>UIAElement</code>，这个对象提供了每个UI元素所应具备的如下属性：</p>

<ul>
<li>name</li>
<li>value</li>
<li>elements</li>
<li>parent</li>
</ul>


<p>一、Target application<br/>
获取方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIAtarget.localTarget().ftontMostApp()  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1rmjppj208u0dw769.jpg" alt="image" /></p>

<p>二、Main Window<br/>
获取到他的方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIAtarget.localTarget().ftontMostApp().mainWindow()  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1rmjppj208u0dw769.jpg" alt="image" /></p>

<p>三、View<br/>
获取主视图的方法如下(eg:UITableView):</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().mainWindow ().tableViews()[0]  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1se2hij208u0dwac1.jpg" alt="image" /></p>

<p>四、Element<br/>
例如获取tableView下的第一行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().mainWindow ().tableViews()[0].cells()[0]  </span></code></pre></td></tr></table></div></figure>


<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1t0c7rj208w0dwtao.jpg" alt="image" /></p>

<p>五、Child Element<br/>
例如想获取第一行里面的显示标题的label：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().mainWindow ().tableViews()[0].cells()[0].elements()[“第一章 会计法律制度”]  </span></code></pre></td></tr></table></div></figure>


<p>
<img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f1fv1te5d2j208u0dwabz.jpg" alt="image" /></p>

<p>六、button的点击事件<br/>
例如一个叫<code>Edit</code>的button，我们要模拟对他的点击，可以如下测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().frontMostApp().navigationBar().buttons()["Add"].tap();  </span></code></pre></td></tr></table></div></figure>


<p>
七、文本的输入<br/>
例如界面上只有一个<code>UITextField</code>，我们要测试对它输入一段文字：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var name = “Turtle Pie”; UIATarget.localTarget().frontMostApp().mainWindow().textFields()[0].setValue(name);  </span></code></pre></td></tr></table></div></figure>


<p>八、Logging<br/>
开始测试和结束测试：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var testName = "My first test"; UIALogger.logStart(testName); ... // test code ... UIALogger.logPass(testName);</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>测试过程中打印Log信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var testName = "My first test"; UIALogger.logStart(testName); ... UIALogger.logMessage("Logging about my test"); ... UIALogger.logPass(testName);  </span></code></pre></td></tr></table></div></figure>


<p></p>

<p>九、模拟点击Home键进入后台一段时间再自动唤起：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> UIALogger.logMessage("Deactivating app");
</span><span class='line'> //10s后自动唤起 UIATarget.localTarget().deactivateAppForDuration(10); UIALogger.logMessage("Resuming test after deactivation");</span></code></pre></td></tr></table></div></figure>


<p>
十、模拟Orientation切换：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> var target = UIATarget.localTarget(); var app = target.frontMostApp(); // set landscape left target.setDeviceOrientation(UIA_DEVICE_ORIENTATION_LANDSCAPELEFT); UIALogger.logMessage("Current orientation is " + app.interfaceOrientation()); // portrait target.setDeviceOrientation(UIA_DEVICE_ORIENTATION_PORTRAIT); UIALogger.logMessage("Current orientation is " + app.interfaceOrientation());   </span></code></pre></td></tr></table></div></figure>


<p></p>

<h5>模拟手势操作</h5>

<p>一、Taps</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().tap({x:100, y:200});UIATarget.localTarget().doubleTap({x:100, y:200});UIATarget.localTarget().twoFingerTap({x:100, y:200});</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>二、Pinches</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//指定pinch在2秒内完成
</span><span class='line'>UIATarget.localTarget().pinchOpenFromToForDuration({x:20, y:200}, {x:300, y:200},2);UIATarget.localTarget().pinchCloseFromToForDuration({x:20, y:200}, {x:300, y:200}, 2);</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>三、Drag and Flick</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UIATarget.localTarget().dragFromToForDuration({x:160, y:200}, {x:160, y:400}, 1);UIATarget.localTarget().flickFromTo({x:160, y:200}, {x:160, y:400});</span></code></pre></td></tr></table></div></figure>


<p>虽然从iOS7开始，<code>UIAutomatation</code>苹果不在维护了，转而支持Xcode中的UI Testing，但是它却可以测试复杂的手势操作，这是目前UI Testing无法完成的。</p>

<h5>参考文章</h5>

<p>1、<a href="https://developer.apple.com/videos/play/wwdc2010/306/">https://developer.apple.com/videos/play/wwdc2010/306/</a><br/>
2、<a href="http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation">http://blog.manbolo.com/2012/04/08/ios-automated-tests-with-uiautomation</a><br/>
3、<a href="http://onevcat.com/2015/09/ui-testing/">http://onevcat.com/2015/09/ui-testing/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中如何在一个工程创建多个App]]></title>
    <link href="http://summertreee.github.io/blog/2016/01/23/ioszhong-ru-he-zai-%5B%3F%5D-ge-gong-cheng-chuang-jian-duo-ge-app/"/>
    <updated>2016-01-23T20:11:40+08:00</updated>
    <id>http://summertreee.github.io/blog/2016/01/23/ioszhong-ru-he-zai-[?]-ge-gong-cheng-chuang-jian-duo-ge-app</id>
    <content type="html"><![CDATA[<p>一般情况下，我们是一个App应用对应一个<code>Xcode Project</code>，但是如果你需要同时开发多个产品，而这些产品90%的数据结构以及交互方式都一样，呈现在用户面前的这两个产品，最大的不一样就是UI元素以及某些配色时，如果这个时候还是一个App一个<code>Xcode Project</code>，普遍的做法是：</p>

<p>你会先开发完成一个产品，然后在复制到其他的产品中，非常的麻烦而且效率很低，你需要一个一个文件去比对。如果你使用模块的方式，开发完一个模块，然后再利用<code>Pod</code>的方式导入到其他产品中，虽然这样可行，但是涉及到产品的迭代开发以及产品的随时会变的交互，模块的细化分很难实现。</p>

<p>如果你也面临这样的问题，不放考虑一下下面讲的<code>一个工程来开发多个App</code>：</p>

<!--more-->


<h4>1、创建新的Target</h4>

<p>如果现在你已经有个一个产品叫<code>MultipleTargetA</code>，如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f09onfv2lnj20e709xabz.jpg" alt="image" /></p>

<p>这时你想添加一个叫<code>MultipleTargetB</code>的产品，你需要做的是按如下的步奏进行创建：
选择<code>Project -&gt; Targets -&gt; 右击MultipleTargetsA -&gt; 选择Duplicate</code>，这时我们就按照<code>MultipleTargetsA</code>复制了一个产品<code>MultipleTargetsA copy</code>，并且你会看到多出了一个文件<code>MultipleTargetsA copy-Info.plist</code>，如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f09onggesdj20cr0b8q53.jpg" alt="image" /></p>

<p>将<strong>TARGETS</strong>里面的<code>MultipleTargetsA copy</code>改名为<code>MultipleTargetsB</code>（选中回车进入编辑）。</p>

<h4>2、编辑plist文件</h4>

<p>上面讲到了当我们创建新的<code>Target</code>后会多出一个<code>MultipleTargetsA copy-Info.plist</code>文件，这个<code>plist</code>文件就是控制<code>MultipleTargetsB</code>的名称，版本等信息的文件，我们为了统一将他改为<code>MultipleTargetsB-Info.plist</code>，在修改名字之前你需要在<code>MultipleTargetsB</code>的<code>Build Settings</code>中找到<code>MultipleTargetsA copy-Info.plist</code>一项，待会儿我们修改完这个<code>plist</code>文件以后，还需要在这里填入它正切的位置信息。这样程序执行时才能找到它，不然程序是不能通过编译的：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1f09ongryr7j20oq0algnp.jpg" alt="image" /></p>

<p>处理完上面的操作后，程序能正常通过编译后我们还需要修改<code>plist</code>文件里面的一下符合我们预期的信息：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f09onhbzvjj20h20aydj0.jpg" alt="image" /></p>

<h4>3、定义Preprocessor Macros</h4>

<p>现在我们的工程里面同时包含了两个<code>Target</code>，现在工程里面的类是这两个<code>Target</code>公用的，如果你想在一个类里面区分是<code>MultipleTargetsA</code>还是<code>MultipleTargetsB</code>，这时你就需要用到<code>Preprocessor Macros</code>了，它的定义很简单，选中一个<code>Target</code>，然后在<code>Build Settings</code>里面搜索<code>Preprocessor Macros</code>一项，然后在里面添加表明是<code>MultipleTargetsA</code>的宏：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f09oni1sa6j20ol0fbwhe.jpg" alt="image" /></p>

<p>假如我们为<code>MultipleTargetsA</code>和<code>MultipleTargetsB</code>分别按如上步奏添加了标识：<code>MultipleTargetsA</code>和<code>MultipleTargetsB</code>,那在某个类里面判断现在编译的目标是哪个<code>Target</code>就变得简单了</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)someFunction
</span><span class='line'>{
</span><span class='line'>#ifdef MultipleTargetsA
</span><span class='line'>    NSLog(@"Build For Target MultipleTargetsA!");
</span><span class='line'>#else
</span><span class='line'>    NSLog(@"Build For Target MultipleTargetsB!");
</span><span class='line'>#endif
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<h4>4、修改Scheme</h4>

<p>现在<code>MultipleTargetsB</code>的<code>Scheme</code>还是<code>MultipleTargetsA copy</code>:</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f09onihy4tj20c20820uh.jpg" alt="image" /></p>

<p>我们可以通过<code>Manage Schemes</code>，选择<code>MultipleTargetsA copy</code>，然后按回车键进行编辑，将它改为<code>MultipleTargetsB</code>：</p>

<p><img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0gw1f09onj571gj20m00d4dh4.jpg" alt="image" /></p>

<h4>5、资源文件和类文件</h4>

<p>上面说了几个<code>APP</code>%90是相同的，不同的地方的资源文件和类文件如果要加以区分，比如<code>A.m</code>类属于<code>MultipleTargetsA</code>而不属于<code>MultipleTargetsB</code>，这时我们可以利用<code>Xcode</code>的<code>Target Membership</code>功能，来选择该类属于哪个<code>Target</code>。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0gw1f09onjlay4j20dw0a5dh8.jpg" alt="image" /></p>

<p>对于<code>Assets</code>文件来说，它只能整体的选择某个<code>Target</code>，所以不同的<code>Target</code>你可能需要建立不同的<code>Assets</code>文件。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Classes and Metaclasses]]></title>
    <link href="http://summertreee.github.io/blog/2015/12/28/classes-and-metaclasses/"/>
    <updated>2015-12-28T13:53:36+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/12/28/classes-and-metaclasses</id>
    <content type="html"><![CDATA[<p>这是一篇译文，原文<a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">在这里</a>，水平有限，翻译难免有错误的地方。</p>

<p><code>Objective-C</code>是一个基于类别对象的系统。每一个对象都是某个类的实例，对象的<code>isa</code>指向它自己的类(Class),这个类描述了该对象所有的数据信息：开辟的空间大小，成员变量类型以及其他信息的排列，这个类同样也描述了该对象可以执行的一些行为：可以响应哪些<code>selector</code>以及它自己实例方法的实现。</p>

<p>类的方法列表里面其实就是该类的所有实例方法的集合，通俗的讲就是该对象可以响应的所有<code>selectors</code>。当你向一个类发送消息时，会通过<code>objc_msgSend()</code>去查找它自身的类的方法列表(如果它有父类的话，也会在它的父类方法列表中去查找)来决定调用哪一个方法。</p>

<!--more-->


<p><code>Objective-C</code>的每一个类也是一个对象，它也有<code>isa</code>指针以及其他的一些信息，同样它也能响应<code>selector</code>，当你调用类方法时，比如：<code>[NSObject alloc]</code>，其实你是在向该类发送消息。</p>

<p>上面说了，类也是一个对象，那它必定也是其他某一个类的一个实例，这就是<code>metaclass</code>，<code>metaclass</code>里面存放了类对象的所有信息，类和<code>metaclass</code>的关系就和刚才上面讲的实例对象和该实例的类的关系一样，<code>metaclass</code>的方法列表里面存放的该类对象能够响应的方法。当你向一个类(这个类是某个metaclass的一个实例对象)发送一个消息时，<code>objc_msgSend()</code>回去遍历<code>metaclass</code>的方法列表，如果它有父类的话，同样也会遍历父类的所有方法列表，从而决定调用哪一个方法。类方法的定义存放与类对象的<code>metaclass</code>，与之相对应的是实例方法的定义存放于实例对象对应的类里面。</p>

<p><code>metaclass</code>究竟是个啥？它也是一直向下的吗？NO，一个<code>metaclass</code>又是某个类的根类的<code>metaclass</code>实例对象，根<code>metaclass</code>又是它自身的一个实例对象，在这里<code>isa</code>指针的指向形成了一个环：实例对象->类->metaclass->根metaclass->它自己(根metaclass)，在实际的使用中我们很少和metaclass直接打交道。</p>

<p><code>metaclass</code>的父类和类的父类直接形成了两条平行线，所有类方法的继承类似于实例方法的继承，并且根<code>metaclass</code>的父类就是根类，所以每个类对象都能响应根类的实例方法，最后需要说一下的是一个类对象是它根类或者根类的一个子类的实例。</p>

<p>是不是觉得有些迷惑，下面的图或许能给你一点帮助，你需要记住的是，当向一个对象发送任何消息是，都是从该对象的<code>isa</code>指针开始，然后按着它的父类一直寻找，直到找到合适的方法去调用，实例方法定义在类里面，类方法定义在<code>metaclass</code>和根类里面。<br/>
<img src="http://ww4.sinaimg.cn/mw690/8f7a6fe0jw1ezfb7ybjzqj20gw0hm40e.jpg" alt="image" /></p>

<p><code>Objective-C</code>为了它的实用性，将类方法由<code>metaclass</code>管理，但另一方面它又想把<code>metaclass</code>影藏起来，例如<code>[NSObject class]</code>和<code>[NSObject self]</code>是完全等价的，其实它这个时候是返回的<code>metaclass</code>，也就是<code>NSObject-&gt;isa</code>所指向的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ContentCompressionResistance和ContentHugging详解]]></title>
    <link href="http://summertreee.github.io/blog/2015/12/13/contentcompressionresistancehe-contenthuggingxiang-jie/"/>
    <updated>2015-12-13T17:07:53+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/12/13/contentcompressionresistancehe-contenthuggingxiang-jie</id>
    <content type="html"><![CDATA[<p>在Auto Layout的使用中，有两个很重要的布局概念：<code>Content Compression Resistance</code>和<code>Content Hugging</code>，从字面的翻译我们大概可以分别翻译为：<code>压缩阻力</code>以及<code>内容吸附</code>。但是光从字面意思来理解很难知道它们如何使用以及确切的设计意图。我最开始也是很迷糊而且在使用Auto Layout的过程中也没有使用过它们，直到最近稍稍研究了一下，发现它们的作用甚是巨大，所以我为了加深记忆，把我最近学习到的关于它们的概念在此稍作整理加以记录。</p>

<blockquote><p>注：以下为了表述方便，将<code>Content Compression Resistance</code>记为<code>压缩阻力</code>，将<code>Content Hugging</code>记为<code>内容吸附</code>。</p></blockquote>

<!--more-->


<h4>Content Compression Resistance</h4>

<p><strong>压缩阻力</strong>属性为了记忆更加形象我们可以把它理解为<strong>离我远点，不许挤到我</strong>，它的优先级（Priority）越高，它的这种抗挤压的能力也就越强，我们可以通过代码在控件的水平或垂直方向上分别设置1（最低优先级）到1000（最高优先级）之间的优先级，默认是750，例如我们可以为一个<strong>UILabel</strong>控件设置一个它在水平方向上优先级为<em>500</em>的压缩阻力：</p>

<pre><code>[label setContentCompressionResistancePriority:500 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>用图来表示，我们可以大致表示如下，视图的压缩阻力就好似它自身往外的张力，优先级越高，视图自己维持自身显示完整性的能力就越强：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwdofkoj208r08r74s.jpg" alt="image" /></p>

<h4>Content Hugging</h4>

<p><strong>内容吸附</strong>属性为了记忆方便我们可以把它理解为<strong>抱紧（Hug）</strong>，视图的大小不会随着superView的变大而扩大，而是只维持能完全显示自己内容的大小，它的这种优先级越高，吸附的能力就越强，和<strong>压缩阻力</strong>一样，<strong>内容吸附</strong>的优先级也可以通过代码来设置，只是它的默认优先级是<em>250</em>：</p>

<pre><code>[label setContentHuggingPriority:251 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>用图来表示，我们可以大致表示如下，视图的内容吸附就好似视图自己有向内抱紧自己的力量一样，优先级越高，它的这种能力就越强：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwdllbej208n08mq3e.jpg" alt="image" /></p>

<p>以上讲了<code>内容吸附</code>和<code>压缩阻力</code>的基本概念，但是这两个属性是建立在<code>Intrinsic Content Size</code>这一概念上的，我们暂且把它翻译为<code>固有尺寸</code>，所有基于UIView的视图都有<code>intrinsicContentSize</code>这个属性，下面我们就介绍一下什么是<code>固有尺寸</code>。</p>

<h4>Intrinsic Content Size</h4>

<p>每个视图都有压缩阻力优先级（Content Compression Resistance Priority）和内容吸附优先级（Content Hugging Priority），但只有视图明确了它的<code>固有尺寸</code>后，这两种优先级才会起作用。我们首先来看一下官方的解释：</p>

<blockquote><p> Custom views typically have content that they display of which the layout system is unaware. Overriding this method allows a custom view to communicate to the layout system what size it would like to be based on its content. This intrinsic size must be independent of the content frame, because there’s no way to dynamically communicate a changed width to the layout system based on a changed height, for example.
If a custom view has no intrinsic size for a given dimension, it can return UIViewNoIntrinsicMetric for that dimension.</p></blockquote>

<p>大致的意思就是我们自定义的视图在默认情况下，它的固有尺寸是返回(UIViewNoIntrinsicMetric，UIViewNoIntrinsicMetric)，也就是(-1,-1)，只有我们根据自定义视图本身的Content来重写该方法，我们自定义的视图才能明确的知道他在显示系统中该展示的大小。<br/>
UILabel和UIButton等这些控件，系统默认是根据他们的内容实现了固有尺寸，所以我们在使用的时候只需要确定origin或者Center它们就能正确的显示。<br/>
由此可见，固有尺寸是为了实现视图的<strong>大小自适应</strong>而存在的。</p>

<p>以下我来自定义一个视图，来测试一下<code>固有尺寸</code>是否有效，由于项目中大家都是用<a href="http://https://github.com/SnapKit/Masonry">Masonry</a>来处理Auto Layout，所以一下的例子都使用<code>Masonry</code>来布局。</p>

<h5>重写Intrinsic Content Size</h5>

<p>我们新建一个继承自<code>UIView</code>的自定义视图<code>IntrinsicView</code>，在一个ViewController中添加一个我们自定义的视图,设置它水平居中，顶部和父视图对齐。</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *intrinsicView = [IntrinsicView new];
    intrinsicView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:intrinsicView];
    [intrinsicView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.mas_equalTo(self.view);
    make.top.mas_equalTo(self.mas_topLayoutGuideBottom);
}];
}
</code></pre>

<p>运行后发现什么也没显示，因为我们没有设置它的宽高，而它默认的固有尺寸是（-1 ，-1）。我们去重写<code>IntrinsicView</code>的<code>- (CGSize)intrinsicContentSize</code>方法：</p>

<pre><code>@implementation IntrinsicView

- (CGSize)intrinsicContentSize
{
    return CGSizeMake(150, 66);
}

@end  
</code></pre>

<p>运行后显示如下：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw65tsuj208y0ddaa5.jpg" alt="image" /></p>

<p>显示出来，它的大小刚好是我们定义的<code>intrinsicContentSize</code>大小。上面介绍了内容吸附和压缩阻力以及固有尺寸的基本概念，下面来测试一下它们应该如何使用。</p>

<h6>1、测试内容吸附优先级</h6>

<p>为了测试内容吸附优先级我们在页面上添加两个<code>IntrinsicView</code>，分别是<code>topView</code>和<code>bottomView</code>，设置他们都水平居中，然后分别和页面的顶部和底部对齐：</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *topView = [IntrinsicView new];
    topView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:topView];
    [topView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(self.mas_topLayoutGuideBottom);//和导航栏底部对齐
    }];

    IntrinsicView *bottomView = [IntrinsicView new];
    bottomView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:bottomView];
    [bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.bottom.mas_equalTo(self.mas_bottomLayoutGuideBottom);//和页面底部对齐
    }];
}  
</code></pre>

<p>运行后展示如下：<br/>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw6ih8aj208w0ddglq.jpg" alt="image" /></p>

<p>下面我们设置<strong>topView</strong>和<strong>bottomView</strong>之间的间距为<em>40</em>，也就是<code>topView.bottom + 40 = bottomView.top</code>。</p>

<pre><code>- (void)layoutSubIntrinsicView
{
    IntrinsicView *topView = [IntrinsicView new];
    topView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:topView];
    [topView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(self.mas_topLayoutGuideBottom);//和导航栏底部对齐
}];

    IntrinsicView *bottomView = [IntrinsicView new];
    bottomView.backgroundColor = [UIColor colorWithRed:.2 green:.4 blue:.6 alpha:1];
    [self.view addSubview:bottomView];
    [bottomView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.centerX.mas_equalTo(self.view);
        make.top.mas_equalTo(topView.mas_bottom).offset(40);
        make.bottom.mas_equalTo(self.mas_bottomLayoutGuideBottom);//和页面底部对齐
 }];
}  
</code></pre>

<p>运行后展示效果如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw6xva7j208v0dcmxb.jpg" alt="image" /></p>

<p>我们发现<code>topView</code>被拉伸了，如果我们不想<code>topView</code>被拉伸，就可以利用<code>内容吸附</code>的特性，因为我们定义了<code>IntrinsicView</code>的固有尺寸，设置<code>topView</code>的<code>内容吸附</code>优先级比<code>bottomView</code>的优先级高，我们上面介绍了<code>内容吸附</code>的默认优先级是<em>250</em>，我们把<code>topView</code>的<code>内容吸附</code>优先级设置为<em>251</em>，在原来<code>layoutSubIntrinsicView</code>函数的最后添加如下语句：</p>

<pre><code>[topView setContentHuggingPriority:251 forAxis:UILayoutConstraintAxisVertical];  
</code></pre>

<p>运行后如下所示，达到了我们想要的效果：</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw7a0tqj208w0ddt8v.jpg" alt="image" /></p>

<blockquote><p>251是我随意定的比250大的值，可以是大于250小于1000的任何值。</p></blockquote>

<h6>2、测试压缩阻力优先级</h6>

<p>我们通常会遇到如下图所示的需求：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrw7yw9hj20e007cdgi.jpg" alt="image" /></p>

<p>在某个页面上水平放置两个UILabel，<code>leftLabel</code>的左边和父视图的间距固定，<code>rightLabel</code>的右边和父视图的右边有一个小于等于某个间隔的约束，<code>leftLabel</code>和<code>rightLabel</code>之间有一个固定间距，它们的宽度根据他们显示的内容自适应，关键代码如下:</p>

<pre><code>[leftLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    //左边和父视图间隔固定为10
    make.left.mas_equalTo(self.view).offset(10);
    make.top.mas_equalTo(80);//随意设定的值
}];

[rightLabel mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.mas_equalTo(leftLabel);
    //和leftLabel的右边间距固定为20
    make.left.mas_equalTo(leftLabel.mas_right).offset(20);
    //这里注意是‘lessThanOrEqualTo’，也就是‘rightLabel’的右边界
    //和父视图的间距至少为10，内容少时，间距自动调大
    make.right.mas_lessThanOrEqualTo(self.view).offset(-10);
}];  
</code></pre>

<p>在他们的显示内容宽度不超过父视图宽度时，两个label的内容都能正常的完全显示，但是当它们需要显示的内容长度总和超过父视图的宽度时，就会显示如下：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwckaf2j208x0ddglw.jpg" alt="image" /></p>

<p>一个label被压缩了， <code>rightLabel</code>显示不完全，如果在这种情况下，我们想<code>leftLabel</code>被压缩，而<code>rightLabel</code>尽量完全显示，由于UILabel这类控件，系统自己已经根据它们显示的实际内容实现了<code>固有尺寸</code>的方法，我们可以利用<code>压缩阻力</code>的特性，将<code>rightLabel</code>的<code>压缩阻力</code>优先级设置得比<code>leftLabel</code>高，上面介绍了<code>压缩阻力</code>的默认优先级是<em>750</em>，我们把<code>rightLabel</code>的优先级设置为<em>751</em>，在上面代码的最下面添加如下代码：</p>

<pre><code>[rightLabel setContentCompressionResistancePriority:751 forAxis:UILayoutConstraintAxisHorizontal];  
</code></pre>

<p>运行后显示如下，达到了我们预期的效果：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eyqrwd0cbqj208x0dddg4.jpg" alt="image" /></p>

<h6>3、在自动计算UITableViewCell高度中的使用</h6>

<p>对于变高cell的处理，以前我们都是在<code>heightForRowAtIndexPath</code>方法里面，拼凑要展示的变高cell的高度，当我们改变cell中两个控件在垂直方向的布局，或者再添加一个控件时，还要去修改计算cell高度的方法来适应新的变化，非常不方便。但是有了自动布局后，利用好<code>压缩阻力</code>和<code>内容吸附</code>的优先级，可以很精确很简单的由系统来计算出变高cell的高度。</p>

<p>假定我们有如下需求：<br/>
<img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxt9hqfj20e1097dgw.jpg" alt="image" /></p>

<p>我们看到，这个变高cell里面高度不定的是中间的<code>ContentLabel</code>，它会根据内容长度来折行显示，<strong>UILabel</strong>要折行显示我们需要设置它的<code>preferredMaxLayoutWidth</code>和<code>numberOfLines</code>两个属性的值。</p>

<p>首先假定<code>Model</code>的定义如下：</p>

<pre><code>@interface CellModel : NSObject

@property (nonatomic, copy) NSString *name;
@property (nonatomic, copy) NSString *company;
@property (nonatomic, copy) NSString *content;
@property (nonatomic, assign) CGFloat cacheHeight;//缓存当前Model显示的cell高度

@end
</code></pre>

<p>自定义的<code>UITableViewCell</code>的关键代码如下：</p>

<pre><code>//图片距左边距离为10，上下居中
    [_cellImageView mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.contentView).offset(10);
        make.centerY.mas_equalTo(self.contentView);
        make.top.mas_greaterThanOrEqualTo(self.contentView).offset(10);
        make.bottom.mas_lessThanOrEqualTo(self.contentView).offset(-10);
    }];
    //标题Label,一行显示
    [_nameLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.cellImageView.mas_right).offset(6);
        make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
        make.top.mas_equalTo(self.contentView).offset(10);
    }];
    //内容label,多行显示
    _contentLabel.numberOfLines = 0;
    [self.contentView addSubview:_contentLabel];
    [_contentLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.nameLabel);
        make.top.mas_equalTo(self.nameLabel.mas_bottom).offset(6);
    }];
    //标题Label,一行显示
    [_companyLabel mas_makeConstraints:^(MASConstraintMaker *make) {
        make.left.mas_equalTo(self.contentLabel);
        make.right.mas_lessThanOrEqualTo(self.contentView).offset(-10);
        make.top.mas_equalTo(self.contentLabel.mas_bottom).offset(6);
        make.bottom.mas_equalTo(self.contentView).offset(-10);//设定了这个自动计算cell高度时才知道具体cell的高度
    }];

    [_nameLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
    [_companyLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];
    [_contentLabel setContentHuggingPriority:UILayoutPriorityRequired forAxis:UILayoutConstraintAxisVertical];  
</code></pre>

<p>上面的代码中设置了几个<code>UILabel</code>的<code>内容吸附</code>优先级为最高，这样它们就不会随着cell高度的变化而拉伸高度。上面设置了<code>contentLabel</code>的<code>numberOfLines = 0</code>，还需要设置<code>preferredMaxLayoutWidth</code>才能正确换行显示。由于<code>UITableViewCell</code>在显示出来之前是不知道宽度的，但是为了获取正确的宽度我们可以在<code>- (void)layoutSubviews</code>方法里面设置：</p>

<pre><code>- (void)layoutSubviews
{
    _contentLabel.preferredMaxLayoutWidth = CGRectGetWidth(self.contentView.frame) - 128 - 10 - 6;//后面的数字是前后以及图片的宽度
    [super layoutSubviews];//这个调用是为了改变后更新布局
}
</code></pre>

<p>这样我们设置好cell以及Model以后，其他的方法都和普通的使用一样，唯一不一样的就是计算cell高度的<code>UITableView</code>代理方法<code>heightForRowAtIndexPath</code>，它的实现如下：</p>

<pre><code>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
{
    static CodeLayoutCell *singleCell = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
    //这里持有一个cell是为了下面自动计算cell高度的需要
        singleCell = [tableView dequeueReusableCellWithIdentifier:kCellIdentifier];
    });
    //取出Model，如果有缓存的高度值就不计算了
    CellModel *model = _dataSourceArray[indexPath.row];
    if (model.cacheHeight != 0) {
        return model.cacheHeight;
    }
    [singleCell layoutIfNeeded];//强制布局，得到contentView的宽度
    [singleCell setNewCellModel:model];
    //由系统根据我们设定的Layout规则来计算cell显示的Size
    CGSize size = [singleCell.contentView systemLayoutSizeFittingSize:UILayoutFittingCompressedSize];
    model.cacheHeight = size.height + 1;//cell和cell.contentView的高度相差1

    return model.cacheHeight;
}  
</code></pre>

<p>运行的效果如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxuuzclg208u0d51kx.gif" alt="image" /></p>

<p>当图片的高度大于三个<code>UIlabel</code>加上各自上下的间隔的高度时，由于我们设置了三个Label的<code>内容吸附</code>最高的优先级，所以为了满足它们的高度，图片的内容就进行了压缩，如下:</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0gw1eyvfxtyebuj208w0dbdhk.jpg" alt="image" /></p>

<p>第二个cell的图片被压缩了，如何才能保证它不被压缩呢？留给读到这里的人自己实现吧！😄</p>

<p>暂时先写到这里吧，由于刚接触这两个属性，难免会有遗误之处，请大家多多谅解！</p>

<p>完整的Demo，请戳<a href="https://github.com/liangwei518/AutolayoutDemo1">这里</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Auto Layout使用小技巧]]></title>
    <link href="http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao/"/>
    <updated>2015-11-22T22:58:51+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/11/22/auto-layoutshi-yong-xiao-ji-qiao</id>
    <content type="html"><![CDATA[<p>目前由于Apple自己的Auto Layout写法比较啰嗦，所以出现了许多对原生语句进行封装的第三方开发库，这其中<code>Masonry</code>广受开发者的喜爱，所以以下都以<code>Masonry</code>来做演示说明，但对于Apple原生的写法也同样适用。</p>

<h3>1、图片+文字居中显示</h3>

<p>很多时候我们都会遇到这样的需求：一张图片旁边接上一段文字，然后让他们相对于父视图居中显示，以前我的做法是先知道图片的尺寸，然后来计算他们相对于父视图中心的偏移量，再进行布局。需求的样式大致如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4nyp8qbj208w014a9v.jpg" alt="大致效果" /></p>

<p>但是这样的缺点是每次都需要去据算距离中心的偏移量，很麻烦，对于这种情况其实可以添加一个辅助视图，让这个辅助视图的左边等于图片的左边，右边和文字的右边对齐，然后这个辅助视图相对于父视图居中显示就行。</p>

<!--more-->


<pre><code>- (void)layoutImageAndText {
UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@"av_colum"]];
[self.view addSubview:imageView];
[imageView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.equalTo(@10);
    make.left.greaterThanOrEqualTo(self.view);
}];

UILabel *label = [UILabel new];
label.text = @"梁朝伟";
label.font = [UIFont systemFontOfSize:17];
label.textAlignment = NSTextAlignmentLeft;
label.backgroundColor = [UIColor clearColor];
[self.view addSubview:label];
[label mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView.mas_right).offset(5);
    make.centerY.equalTo(imageView);
}];

UIView *limitView = [UIView new];
[self.view addSubview:limitView];
[limitView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.equalTo(imageView);//和图片左边对齐
    make.right.equalTo(label);//和文字右边对齐
    make.centerX.equalTo(self.view);//指定limitView居中显示
}];
}
</code></pre>

<h3>2、处理复合型布局</h3>

<p>直接上图说明需求，页面上有四个可见的视图：红、绿、蓝三个<code>UIView</code>，最下面是一个<code>UIButton</code>,想要达到的效果是点击button触发事件将中间的绿色视图隐藏，下面的蓝色视图和button移动到红色视图下，我们想要的效果如下：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4nz1i8hg208p0bjmxi.gif" alt="需要的效果" /></p>

<p>如果只是将中间的绿色的视图hidden掉，是达不到这样的效果的：</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eya4nza0mfj208w0a8748.jpg" alt="影藏中间的绿色视图" /></p>

<p>要达到这样的效果可以利用<code>MASConstraint</code>的<code>deactivate</code>和<code>activate</code>方法，他们的作用是让一个constraint<strong>不生效</strong>和<strong>生效</strong>，<code>Masonry</code>的每个Constraint都会产生一个<code>MASConstraint</code>，所以我们可以保存一些需要改变的constraint，在需要的时候使用这两个方法。</p>

<pre><code>//.h
@interface ViewController ()

@property (nonatomic, strong) UIView *greenView;
@property (nonatomic, strong) MASConstraint *gHeightConstraint;//保存关键的constraint

@end
//.m
@implementation ViewController

- (void)testComplexLayout {
NSNumber *viewHeight = @80;
UIView *redView = [UIView new];
redView.backgroundColor = [UIColor redColor];
[self.view addSubview:redView];
[redView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.top.left.right.equalTo(self.view);
    make.height.equalTo(viewHeight);
}];

_greenView = [UIView new];
[self.view addSubview:_greenView];
[_greenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.left.right.equalTo(redView);
    make.top.equalTo(redView.mas_bottom);
    self.gHeightConstraint = make.height.equalTo(@0).priorityHigh();//设为高优先级，首先满足它的需求
}];
[self.gHeightConstraint deactivate];//最开始让它不生效，就是高为0的限制暂不生效
_greenView.clipsToBounds = YES;//不显示超过bounds本身的部分，因为在它里面加了subView
//subGreenView是真实的显示绿色部分，它添加在greenView上
UIView *subGreenView = [UIView new];
subGreenView.backgroundColor = [UIColor greenColor];
[_greenView addSubview:subGreenView];
[subGreenView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.edges.equalTo(self.greenView).priorityLow();
    make.height.equalTo(viewHeight);
}];

UIView *blueView = [UIView new];
blueView.backgroundColor = [UIColor blueColor];
[self.view addSubview:blueView];
[blueView mas_makeConstraints:^(MASConstraintMaker *make) {
    make.height.left.right.equalTo(redView);
    make.top.equalTo(self.greenView.mas_bottom);
}];

UIButton *hiddenButton = [UIButton buttonWithType:UIButtonTypeCustom];
[hiddenButton setTitle:@"影藏中间的View" forState:UIControlStateNormal];
[hiddenButton addTarget:self action:@selector(hiddenAction:) forControlEvents:UIControlEventTouchUpInside];
[hiddenButton setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];
[self.view addSubview:hiddenButton];
[hiddenButton mas_makeConstraints:^(MASConstraintMaker *make) {
    make.centerX.equalTo(self.view);
    make.top.equalTo(blueView.mas_bottom).offset(40);
}];
}

static bool isActive = NO;
- (void)hiddenAction:(id)sender {
if (isActive) {
    [_gHeightConstraint deactivate];
} else {
    [_gHeightConstraint activate];
}
//动画展示
[UIView animateWithDuration:.25 animations:^{
    [self.view layoutIfNeeded];
}];

isActive = !isActive;
}
</code></pre>

<h3>3、Preview的使用</h3>

<p>这段时间在学习storyBoard相关的一些知识，RW上的两篇文章：<a href="http://www.raywenderlich.com/50308/storyboards-tutorial-in-ios-7-part-1">Part1</a>和<a href="http://www.raywenderlich.com/50310/storyboards-tutorial-in-ios-7-part-2">Part2</a>非常适合初学者学习，已经有人翻译成了中文<a href="http://www.cocoachina.com/industry/20131213/7537.html">Part1</a>，<a href="http://blog.sina.com.cn/s/blog_5c5c87d80101dzyh.html">Part2</a>。</p>

<p><code>Xcode</code>提供了一个很重要的功能<code>Preview</code>。当我们在<code>Storyboard</code>上使用<code>Auto Layout</code>上进行布局以后，由于目前的画布<code>canvas</code>已经没有尺寸的概念，我们布局完成后需要在3.5、4.0、4.7、5.5英寸的设备上测试，如果支持旋转或者支持iPad，一个效果我们会build多次在不同的设备上查看效果。非常的麻烦，但是有了<code>Preview</code>后一切都变得简单起来。
使用<code>Preview</code>的步奏如下：</p>

<p>1、选中<code>Main.storyboard</code>,如下图所示，选取的时候按下<code>option+shift</code>按键。</p>

<p><img src="http://ww2.sinaimg.cn/mw690/8f7a6fe0jw1eya4nzk6ywj20b204p74o.jpg" alt="选择storyboard" /></p>

<p>2、选取<code>Preview</code>后会出来如下的界面，选择界面右边的<code>+</code>号，按<code>回车</code>。</p>

<p><img src="http://ww1.sinaimg.cn/mw690/8f7a6fe0jw1eya4nzzeuxj20bc05daae.jpg" alt="image" /></p>

<p>3、通过步骤<code>2</code>后，会出现以下的界面：</p>

<p><img src="http://ww3.sinaimg.cn/mw690/8f7a6fe0jw1eya4o08srqj20f70gh0t6.jpg" height="520" width="500" alt="Preview界面" /></p>

<p>关键的几个地方我都用红方框圈了起来，左下角的<code>+</code>能模拟不同的设备，中间的红框部位可以模拟设备的旋转，
右下角的<code>English</code>部位可以模拟布局中的文学信息双倍后的布局表现，这几个功能都非常的方便。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App中拨打电话一点小总结]]></title>
    <link href="http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-%5B%3F%5D-dian-xiao-zong-jie/"/>
    <updated>2015-08-23T12:27:08+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/08/23/appzhong-bo-da-dian-hua-[?]-dian-xiao-zong-jie</id>
    <content type="html"><![CDATA[<h3>App内发起电话拨打的一点小技巧</h3>

<h4>一、拨打电话</h4>

<p>在App内发起电话拨打主要有两种方式：</p>

<p>1、利用这种方式发起的电话拨打，通话结束后不会直接返回App内，而是停留在通信录里面：</p>

<pre><code> NSString *str = [[NSString alloc] initWithFormat:@"tel:%@",@"131xxxx1909"];
[[UIApplication sharedApplication] openURL:[NSURL URLWithString:str]];
</code></pre>

<!--more-->


<p>2、利用<code>UIWebView</code>实现电话拨打，会弹出拨打提示，并且拨打完成后会返回App内：</p>

<pre><code>NSString *phone = @"131****1909";
NSString *cleanedString =[[phone componentsSeparatedByCharactersInSet:[[NSCharacterSet characterSetWithCharactersInString:@"0123456789-+()"] invertedSet]] componentsJoinedByString:@""];
NSString *escapedPhoneNumber = [cleanedString stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];
NSURL *telURL = [NSURL URLWithString:[NSString stringWithFormat:@"tel://%@",escapedPhoneNumber]];
UIWebView *mCallWebview = [[UIWebView alloc] init] ;

[self.view addSubview:mCallWebview];
[mCallWebview loadRequest:[NSURLRequest requestWithURL:telURL]];
</code></pre>

<h4>二、检测通话时间</h4>

<p>利用<code>CTCallCenter</code>我们可以检测在使用App期间拨打电话出去以及电话打入的时机，以及通话结束的时机。实现如下：</p>

<pre><code> #import &lt;CoreTelephony/CTCallCenter.h&gt;
 #import &lt;CoreTelephony/CTCall.h&gt;

 @interface AppDelegate : UIResponder&lt;UIApplicationDelegate&gt;
 @property (nonatomic, strong) CTCallCenter *callCenter;
 @end

@implementation AppDelegate

- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
  self.callCenter = [[CTCallCenter alloc] init];
  [self handleCall];
  return YES;
}

-(void)handleCall
{
   self.callCenter.callEventHandler = ^(CTCall *call) {
    if ([call.callState isEqualToString: CTCallStateConnected])
    {
        NSLog(@"接通电话");
    }
    else if ([call.callState isEqualToString: CTCallStateDialing])
    {
        NSLog(@"发起呼叫");
    }
    else if ([call.callState isEqualToString: CTCallStateDisconnected])
    {
        NSLog(@"结束电话");
    }
    else if ([call.callState isEqualToString: CTCallStateIncoming])
    {
        NSLog(@"打入电话");
    }
   };
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode控制台打印CGRect]]></title>
    <link href="http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect/"/>
    <updated>2015-06-15T21:15:58+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/06/15/xcodekong-zhi-tai-da-yin-cgrect</id>
    <content type="html"><![CDATA[<p>在用Xcode调试开发的时候，我们经常需要在控制台打印某个视图的frame，以前的时候相当麻烦，但是从Xcode6.3以后，打印frame变得很简单：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Before
</span><span class='line'>(lldb) p (CGRect) [self frame]
</span><span class='line'>(CGRect) $0 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span><span class='line'> 
</span><span class='line'>// After
</span><span class='line'>(lldb) expr @import UIKit
</span><span class='line'>(lldb) p self.frame
</span><span class='line'>(CGRect) $1 = (origin = (x = 0, y = 0), size = (width = 50, height = 100))
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking2.0使用心得]]></title>
    <link href="http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de/"/>
    <updated>2015-05-13T13:56:23+08:00</updated>
    <id>http://summertreee.github.io/blog/2015/05/13/afnetworking2-dot-0shi-yong-xin-de</id>
    <content type="html"><![CDATA[<p>这段时间要将公司项目中的网络引擎由<a href="http://allseeing-i.com/ASIHTTPRequest/">ASIHTTPRequest</a>替换为<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>,替换的过程比较曲折，在此记录下自己替换过程中得心得：</p>

<h3>1、建立数据请求中介者</h3>

<p>建立<code>中介者</code>是指项目中的数据请求都通过它去实现，而不是每一个数据请求都直接与<code>AFNetworking</code>打交道，这样做的好处是：</p>

<ul>
<li>将网络请求与第三方库依赖隔离开来，方便以后对第三方库的替换。</li>
<li>方便处理网络请求的公共逻辑。</li>
</ul>


<!--more-->


<h3>2、使用completionQueue</h3>

<p>默认情况下<code>AFURLConnectionOperation</code>或者<code>AFHTTPRequestOperation</code>请求结束以后会在主线程将结果传递回来，如果你要将请求的结果做一些耗时的复杂的处理，就会<em>block</em>住主线程，所以这种情况下你就需要对请求的Operation传递<code>completionQueue</code>参数：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperation *request = [[AFHTTPRequestOperation alloc] initWithRequest:urlrequest];
</span><span class='line'>
</span><span class='line'>request.responseSerializer = [AFJSONResponseSerializer serializer];
</span><span class='line'>//设置回调的queue，默认是在mainQueue执行block回调
</span><span class='line'>request.completionQueue = your_request_operation_completion_queue();
</span><span class='line'>[request setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>         //设置了'completionQueue'后，就可以在这里处理复杂的逻辑
</span><span class='line'>         //不用担心block住了主线程
</span><span class='line'>    } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>
</span><span class='line'> }];
</span><span class='line'> [request start];
</span></code></pre></td></tr></table></div></figure>


<h3>3、如何知道AFHTTPRequestOperationManager执行完成</h3>

<p>开始以为直接设置<code>AFHTTPRequestOperationManager</code>的<em>completionGroup</em>，然后利用<code>dispatch_group_notify</code>来获取operationQueue执行结束的通知，最后才发现，这样根本不行，看了源码才知道：<code>AFHTTPRequestOperationManager</code>直接将<em>completionGroup</em>赋值给了他的每一个<em>operation</em>，在<em>operation</em>的completionBlock里面利用<em>completionGroup</em>，来确保在operation的处理完成后，将completionBlock置为nil，防止循环引用。</p>

<p>虽然说这样不能知道<code>AFHTTPRequestOperationManager</code>什么时候执行完成，但是生活还得继续下去啊！在<code>AFURLConnectionOperation</code>中有一个方法叫：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSArray *)batchOfRequestOperations:(NSArray *)operations
</span><span class='line'>                        progressBlock:(void (^)(NSUInteger numberOfFinishedOperations, NSUInteger totalNumberOfOperations))progressBlock
</span><span class='line'>                      completionBlock:(void (^)(NSArray *operations))completionBlock;
</span></code></pre></td></tr></table></div></figure>


<p>这个方法就是能够发一组请求，跟<code>AFHTTPRequestOperationManager</code>比起来的缺点就是没法设置并发数，但是它却能实现检测一组请求什么时候结束，能检测完成了多少请求，它是怎么做到的呢？</p>

<p>原来他也是利用<strong>dispatch_group_async</strong>和<strong>dispatch_group_notify</strong></p>

<p>一般的我们要把一个任务加入一个group里是这样：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    block();
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这个写法等价于</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_async(queue, ^{
</span><span class='line'>    dispatch_group_enter(group);
</span><span class='line'>    block()
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>如果要把一个异步任务加入group，这样就行不通了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_async(group, queue, ^{
</span><span class='line'>    [self performBlock:^(){
</span><span class='line'>        block();
</span><span class='line'>    }];
</span><span class='line'>    //未执行到block() group任务就已经完成了
</span><span class='line'>});
</span></code></pre></td></tr></table></div></figure>


<p>这是就需要用到<code>batchOfRequestOperations</code>里的实现了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>dispatch_group_enter(group);
</span><span class='line'>[self performBlock:^(){
</span><span class='line'>    block();
</span><span class='line'>    dispatch_group_leave(group);
</span><span class='line'>}];
</span></code></pre></td></tr></table></div></figure>


<p>其实这个和引用计数差不多，<em>dispatch_group_enter</em>时引用计数+1，<em>dispatch_group_leave</em>时引用计数-1，引用计数为0时执行<em>dispatch_group_notify</em>的内容。具体过程大致如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>AFHTTPRequestOperationManager *downloadManager = [AFHTTPRequestOperationManager manager];
</span><span class='line'>    //设置最大并发数
</span><span class='line'>    [downloadManager.operationQueue setMaxConcurrentOperationCount:([NSProcessInfo processInfo].processorCount) * 2];
</span><span class='line'>    //创建一个group
</span><span class='line'>    __block dispatch_group_t group = dispatch_group_create();
</span><span class='line'>    for (NSURL *url in urlArray) {
</span><span class='line'>        NSURLRequest *requestUrl = [NSURLRequest requestWithURL:url];
</span><span class='line'>        AFHTTPRequestOperation *requestOperation = [[AFHTTPRequestOperation alloc] initWithRequest:requestUrl];
</span><span class='line'>        [requestOperation setCompletionBlockWithSuccess:^(AFHTTPRequestOperation *operation, id responseObject) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        } failure:^(AFHTTPRequestOperation *operation, NSError *error) {
</span><span class='line'>            dispatch_group_leave(group);
</span><span class='line'>            
</span><span class='line'>        }];
</span><span class='line'>        //将请求加入队列中
</span><span class='line'>        [downloadManager.operationQueue addOperation:requestOperation];
</span><span class='line'>        dispatch_group_enter(group);
</span><span class='line'>    }
</span><span class='line'>    
</span><span class='line'>    dispatch_group_notify(group, dispatch_get_main_queue(), ^{
</span><span class='line'>        //全部请求完成
</span><span class='line'>        
</span><span class='line'>    });  </span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>4、实现断点续传</h3>

<p><code>AFNetworking</code>虽然支持文件下载的暂停和继续，但是当缓存清空重新启动时，它并没有记录下下载的状态，无法续传，但是可以通过<a href="http://https://github.com/steipete/AFDownloadRequestOperation">AFDownloadRequestOperation</a>来简单的实现，其实过程也不是很复杂，大致如下，感兴趣的朋友可以阅读<code>AFDownloadRequestOperation</code>是实现部分：</p>

<p>1、设置<code>AFHTTPRequestOperation</code>的请求<code>NSMutableURLRequest</code><em>HTTPHeader</em>的<strong>Range</strong>字段。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NSMutableURLRequest *mutableURLRequest = [self.request mutableCopy];
</span><span class='line'>//offset是指断点续传文件已经下载的大小
</span><span class='line'>[mutableURLRequest setValue:[NSString stringWithFormat:@"bytes=%llu-", offset] forHTTPHeaderField:@"Range"];</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>2、设置<code>AFHTTPRequestOperation</code>的<em>outputStream</em>属性。</p>

<pre><code class="` "> //downloadPath是指文件下载存放的路径
downloadOperation.outputStream = [NSOutputStream outputStreamToFileAtPath:downloadPath append:YES];
</code></pre>

<h3>结尾</h3>

<p>对于<code>ASIHTTPRequest</code>和<code>AFNetworking</code>的比较网上有很多很好的文章，一搜一大把，对于普通的使用来说感觉区别不大，请求速度什么的也没什么感觉，以上若有错误，还望大家多多
指正😃。</p>
]]></content>
  </entry>
  
</feed>
